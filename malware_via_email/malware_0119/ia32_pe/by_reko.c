// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00403640(35100, dwLoc14);
	word32 eax_17 = fn004035B0();
	if (eax_17 != 0x00)
	{
		*(fp - 0x08) = eax_17;
		*(fp - 0x0C) = ~0x034A2B0F;
		*(fp - 0x10) = 2976162152;
		<anonymous> * eax_123 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(fp - 0x0C) = fp - 616;
		*(fp - 0x10) = 0x0104;
		globals->ptr406014 = eax_123;
		struct Eq_59 * esp_128;
		word32 ebp_129;
		word32 eax_130;
		word32 edi_131;
		word32 esi_132;
		word32 ebx_133;
		byte SZO_134;
		byte C_135;
		byte Z_136;
		word32 edx_137;
		word32 ecx_138;
		byte SCZO_139;
		byte cl_140;
		byte CZ_141;
		byte dl_142;
		word16 dx_143;
		byte al_144;
		word16 bx_145;
		word16 ax_146;
		word16 cx_147;
		byte S_148;
		byte ah_149;
		byte bl_150;
		eax_123();
		esp_128->dw0000 = eax_17;
		*(esp_128 - 0x04) = 3096863366;
		*(esp_128 - 0x08) = 2976162152;
		<anonymous> * eax_157 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(esp_128 - 0x08) = fp - 616;
		esp_128->ptr0004 = fp - 0x0164;
		esp_128->dw0000 = 0x00;
		*(esp_128 - 0x04) = 0x00;
		globals->ptr406010 = eax_157;
		struct Eq_123 * esp_164;
		word32 ebp_165;
		word32 eax_166;
		word32 edi_167;
		word32 esi_168;
		word32 ebx_169;
		byte SZO_170;
		byte C_171;
		byte Z_172;
		word32 edx_173;
		word32 ecx_174;
		byte SCZO_175;
		byte cl_176;
		byte CZ_177;
		byte dl_178;
		word16 dx_179;
		byte al_180;
		word16 bx_181;
		word16 ax_182;
		word16 cx_183;
		byte S_184;
		byte ah_185;
		byte bl_186;
		eax_157();
		*(esp_164 - 0x08) = eax_17;
		*(esp_164 - 0x0C) = 266432455;
		*(esp_164 - 0x10) = 2976162152;
		<anonymous> * eax_193 = fn004034A0(dwArg00, dwArg04, dwArg08);
		*(esp_164 - 0x0C) = 0x5F21224B;
		*(esp_164 - 0x10) = 2976162152;
		*(esp_164 - 0x08) = eax_17;
		globals->ptr406028 = eax_193;
		<anonymous> * eax_199 = fn004034A0(dwArg00, dwArg04, dwArg08);
		esp_164->dw0008 = 0x00;
		esp_164->dw0004 = 0x00;
		esp_164->dw0000 = 0x02;
		*(esp_164 - 0x04) = 0x00;
		*(esp_164 - 0x08) = 0x01;
		globals->ptr406004 = eax_199;
		*(esp_164 - 0x0C) = 0xC0000000;
		*(esp_164 - 0x10) = fp - 0x0164;
		ptr32 esp_209;
		word32 ebp_210;
		word32 eax_211;
		word32 edi_212;
		word32 esi_213;
		word32 ebx_214;
		byte SZO_215;
		byte C_216;
		byte Z_217;
		word32 edx_218;
		word32 ecx_219;
		byte SCZO_220;
		byte cl_221;
		byte CZ_222;
		byte dl_223;
		word16 dx_224;
		byte al_225;
		word16 bx_226;
		word16 ax_227;
		word16 cx_228;
		byte S_229;
		byte ah_230;
		byte bl_231;
		eax_199();
		if (eax_211 != 0x01)
		{
			Eq_250 ecx_237 = globals->t40603C;
			struct Eq_253 * ebx_240 = null;
			ui32 * esi_1852 = (char *) fp - 15352;
			int32 eax_244 = ecx_237 * 0x04 + 0x04;
			ui32 edi_246 = ~0x27C4E228 << (byte) ecx_237;
			do
			{
				*esi_1852 = ebx_240->dw401BC0 ^ edi_246;
				ebx_240 = ebx_240 + eax_244 / 4201412;
				esi_1852 = esi_1852 + (uint32) (0x04 % (ecx_237 - 0x01));
			} while (ebx_240 <= (struct Eq_253 *) 5999);
			struct Eq_283 * edx_270 = null;
			int32 ecx_274 = ecx_237 - 0x01 & 0x04;
			while (true)
			{
				*esi_1852 = (0x00 - (globals->t40603C < 0x01) & 667214377) - 1334428754 ^ edx_270->dw404060;
				edx_270 = edx_270 + ecx_274 / 0x00404064;
				int32 eax_295 = (0x00 - (ecx_237 < 0x01) & ~0x03) + 0x08;
				if (edx_270 > (struct Eq_283 *) 7151)
					break;
				esi_1852 = esi_1852 + eax_295;
			}
			byte * dwLoc88C4_1024 = (char *) fp - 15352;
			ui32 esi_308 = 0x0108 << (byte) ((word32) bLoc88DC);
			if (esi_308 != 0x00)
			{
				struct Eq_332 * ebx_1789 = fp->aFFFFF768;
				ui32 edx_1792 = 0x00;
				byte dl_1794 = 0x00;
				word16 dx_1795 = 0x00;
				do
				{
					ebx_1789->w0000 = dx_1795;
					if ((dl_1794 & 0x01) == 0x00)
					{
						ebx_1789->b0004 = (byte) ((word32) *dwLoc88C4_1024 >> (byte) ((0x00 - (ecx_237 < 0x01) & ~0x03) + 0x08));
						edx_1792 = edx_1792 + 0x01;
						dl_1794 = (byte) edx_1792;
						dx_1795 = (word16) edx_1792;
						ebx_1789 = ebx_1789 + 0x01;
						if (edx_1792 == esi_308)
							break;
						continue;
					}
					ebx_1789->b0004 = (byte) ((word32) *dwLoc88C4_1024 & 0x0F);
					edx_1792 = edx_1792 + 0x01;
					dl_1794 = (byte) edx_1792;
					dx_1795 = (word16) edx_1792;
					dwLoc88C4_1024 = dwLoc88C4_1024 + 0x01;
					ebx_1789 = ebx_1789 + 0x01;
				} while (edx_1792 != esi_308);
			}
			int32 eax_326 = 0x02;
			do
			{
				eax_326 - 0x01 + (fp - 0x20) = (byte *) 0x00;
				eax_326 = eax_326 + 0x01;
			} while (eax_326 != 0x11);
			int32 ebx_341 = ~0x088F;
			do
			{
				ci8 al_357 = (byte) (word32) (ebx_341 + 0x00 + (fp - 0x04));
				if (al_357 > 0x00)
				{
					int32 esi_1775 = (int32) al_357;
					int32 eax_1785 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (esi_1775 | 0x01)) + esi_1775;
					(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x20)[eax_1785].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] = (Eq_425) ((&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(fp - 0x20)[eax_1785].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000 + 0x01).a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000.a0000;
				}
				ebx_341 = ebx_341 + 0x06;
			} while (ebx_341 != 0x0EC0);
			int32 edx_376 = 0x01;
			ui32 dwLoc88F8_380 = 0x00;
			ui32 ebx_382 = DPB(ebx_341, 0x01, 0) << (byte) ((word32) bLoc88DC);
			do
			{
				ui32 v25_393 = dwLoc88F8_380 + (int32) ((edx_376 - 0x01) + (fp - 0x20)) << (byte) ebx_382;
				(fp - 0x60)[edx_376] = ecx_237 ^ v25_393;
				dwLoc88F8_380 = v25_393;
				edx_376 = edx_376 + 0x01;
			} while (edx_376 != 0x10);
			struct Eq_470 * ecx_404 = &fp->aFFFFF76C->b0000;
			do
			{
				int32 edx_409 = (int32) ecx_404->b0000;
				word32 eax_410 = (fp - 0x60)[edx_409];
				*(ecx_404 - 0x02) = (word16) eax_410;
				(fp - 0x60)[edx_409] = eax_410 + 0x01;
				ecx_404 = ecx_404 + 0x01;
			} while (ecx_404 != fp - 0x0264);
			uint32 ebx_446;
			byte cl_422 = 0x00;
			uint32 edx_424 = 0x00;
			uint32 eax_428 = (ecx_237 << 0x08) + 0x0107;
			if (0x00 >= eax_428)
			{
				do
				{
					if (cl_422 == 0x00)
					{
						int32 edi_1000 = 0x80;
						Eq_550 dwLoc88BC_566 = 0x00;
						Eq_552 ecx_569 = (word32) ecx_237 + 0x01 << 0x08;
						while (true)
						{
							while (true)
							{
								Eq_250 ebx_1680 = ecx_237;
								int32 esi_1028 = edi_1000;
								int32 edi_600 = 0x00;
								int32 dwLoc88A4_603 = 0x00;
								Eq_552 dwLoc88C0_1722 = ~0x00;
								do
								{
									ui32 edx_622 = (word32) ecx_237 + 0x01;
									ui32 ecx_1770 = 0x00;
									do
									{
										ecx_1770 = ecx_1770 * 0x02;
										if (((word32) *dwLoc88C4_1024 & esi_1028) != 0x00)
											ecx_1770 = ecx_1770 | 0x01;
										esi_1028 = esi_1028 >> 0x01;
										if (esi_1028 == 0x00)
										{
											dwLoc88C4_1024 = dwLoc88C4_1024 + 0x01;
											esi_1028 = 0x80;
										}
										edx_622 = edx_622 - 0x01;
									} while (edx_622 != 0x00);
									int32 v30_668 = dwLoc88A4_603 << 0x01 | ecx_1770;
									ui32 eax_667 = ebx_1680 * 0x03;
									edi_600 = edi_600 + 0x01;
									dwLoc88A4_603 = v30_668;
									int32 edx_1753 = (int32) fp->aFFFFF76C[eax_667].b0000;
									if (edi_600 > edx_1753)
									{
										struct Eq_650 * eax_1746 = fp->aFFFFF768 + eax_667 + 0x0A;
										do
										{
											edx_1753 = (int32) eax_1746->b0000;
											ebx_1680 = (word32) ebx_1680.u1 + 0x01;
											eax_1746 = eax_1746 + 0x01;
										} while (edi_600 > edx_1753);
									}
									if (edi_600 == edx_1753)
									{
										ui32 eax_1693 = ebx_1680 * 0x03;
										struct Eq_672 * edx_1699 = fp->aFFFFF768 + eax_1693;
										if ((int32) fp->aFFFFF76A[eax_1693] != v30_668)
										{
											do
											{
												ebx_1680 = (word32) ebx_1680 + 0x01;
												if ((int32) edx_1854->b000A != edi_600)
													goto l004016BD;
												edx_1699 = (struct Eq_672 *) ((char *) edx_1854 + 0x06);
												struct Eq_672 * edx_1854 = edx_1699;
											} while ((int32) edx_1854->w0008 != v30_668);
										}
										int32 eax_1712 = (int32) fp->aFFFFF768[ebx_1680 * 0x03];
										Eq_552 eax_1721 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (eax_1712 | 0x01)) + eax_1712;
										dwLoc88C0_1722 = eax_1721;
										if (eax_1721 >= 0x00)
											break;
										continue;
									}
l004016BD:
								} while (dwLoc88C0_1722 < 0x00);
								if (dwLoc88C0_1722 >= (word32) ecx_237 + 0x0100)
									break;
								Mem718[fp + ~0x8897 + dwLoc88BC_566:byte] = (byte) (word32) bLoc88C0;
								edi_1000 = esi_1028;
								dwLoc88BC_566 = (word32) dwLoc88BC_566.u0 + 0x01;
							}
							if (dwLoc88C0_1722 == ecx_569)
								break;
							word32 eax_729 = 0x00 - (ecx_237 < 0x01);
							Eq_745 ecx_734 = dwLoc88C0_1722 - (DPB(eax_729, SLICE(eax_729, byte, 8) & ~0x01, 8) + 0x0202);
							int32 eax_740 = (int32) (ecx_734 * 0x03)->a405C62[ecx_734].w0000;
							uint32 dwLoc88B0_1022 = ~0x00;
							int32 ebx_746 = (int32) (ecx_734 * 0x03)->a405C60[ecx_734].w0000 & ecx_237 - 0x01;
							if (eax_740 != ~0x00)
								dwLoc88B0_1022 = (uint32) ((uint64) (uint32) eax_740 % (ecx_237 - 0x01));
							ui32 edx_1006;
							byte bl_1004;
							byte bLoc88DD_1005;
							int32 dwLoc88B4_1076;
							word16 cx_761 = (word16) (word32) (ecx_734 * 0x03)->a405C64[ecx_734].w0000;
							if (ebx_746 != 0x00)
							{
								bl_1004 = (byte) (word32) *dwLoc88C4_1024;
								dwLoc88B4_1076 = ebx_746;
								edi_1000 = esi_1028 >> 0x01;
								bLoc88DD_1005 = bl_1004;
								edx_1006 = (word32) bl_1004;
							}
							else
							{
								bl_1004 = (byte) (word32) *dwLoc88C4_1024;
								ui32 eax_1011 = 0x00;
								bLoc88DD_1005 = bl_1004;
								do
								{
									edx_1006 = (word32) bl_1004;
									eax_1011 = eax_1011 * 0x02;
									if ((edx_1006 & esi_1028) != 0x00)
										eax_1011 = eax_1011 | 0x01;
									esi_1028 = esi_1028 >> 0x01;
									if (esi_1028 == 0x00)
									{
										byte * v44_1081 = dwLoc88C4_1024 + 0x01;
										uint32 v45_1089 = dwLoc88B0_1022 - 0x01;
										bl_1004 = (byte) (word32) *v44_1081;
										dwLoc88C4_1024 = v44_1081;
										esi_1028 = 0x80;
										edi_1000 = 0x40;
										dwLoc88B0_1022 = v45_1089;
										bLoc88DD_1005 = bl_1004;
										edx_1006 = (word32) bl_1004;
										if (v45_1089 == 0x00)
											break;
										continue;
									}
									uint32 v46_1100 = dwLoc88B0_1022 - 0x01;
									edi_1000 = esi_1028 >> 0x01;
									dwLoc88B0_1022 = v46_1100;
								} while (v46_1100 != 0x00);
								int32 ecx_1066 = (int32) cx_761 *s ((word32) ecx_237 + 0x01);
								if (ecx_237 != 0x00)
									ecx_1066 = ecx_1066 * 0x02;
								dwLoc88B4_1076 = ecx_1066 + eax_1011;
							}
							int32 dwLoc88F8_786;
							ui32 eax_796;
							if (edi_1000 != 0x00)
							{
								eax_796 = edx_1006;
								dwLoc88F8_786 = edi_1000 >> 0x01;
							}
							else
							{
								byte * v42_982 = dwLoc88C4_1024 + 0x01;
								bl_1004 = (byte) (word32) *v42_982;
								dwLoc88C4_1024 = v42_982;
								edi_1000 = 0x80;
								dwLoc88F8_786 = 0x40;
								eax_796 = (word32) bl_1004;
								bLoc88DD_1005 = bl_1004;
							}
							ui32 dwLoc88B8_803 = 0x07;
							if ((edx_1006 & esi_1028) != 0x00)
							{
								if (dwLoc88F8_786 == 0x00)
								{
									byte * v36_964 = dwLoc88C4_1024 + 0x01;
									dwLoc88C4_1024 = v36_964;
									dwLoc88F8_786 = 0x80;
									bLoc88DD_1005 = (byte) (word32) *v36_964;
								}
								bl_1004 = (byte) (word32) bLoc88DD_1005;
								edi_1000 = dwLoc88F8_786;
								dwLoc88B8_803 = (word32) ((eax_796 & edi_1000) != 0x00) + (0x08 << (byte) ((word32) bLoc88DC));
							}
							struct Eq_825 * eax_816 = dwLoc88B8_803 * 0x03;
							word32 esi_818 = (int32) Mem419[eax_816 + 0x00405C62 + eax_816:word16];
							int32 edx_826 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (esi_818 | 0x01)) + esi_818;
							ui32 esi_830 = 0x00;
							while (true)
							{
								esi_830 = esi_830 * 0x02;
								if (((word32) bl_1004 & edi_1000) != 0x00)
									esi_830 = esi_830 | 0x01;
								edi_1000 = edi_1000 >> 0x01;
								if (edi_1000 == 0x00)
								{
									dwLoc88C4_1024 = dwLoc88C4_1024 + 0x01;
									edi_1000 = 0x80;
								}
								edx_826 = edx_826 - 0x01;
								if (edx_826 == 0x00)
									break;
								bl_1004 = (byte) (word32) *dwLoc88C4_1024;
							}
							struct Eq_1662 * eax_866 = dwLoc88B8_803 * 0x03;
							word16 ax_872 = (word16) (word32) Mem419[eax_866 + 0x00405C64 + eax_866:word16];
							if (dwLoc88B4_1076 > 0x00)
							{
								word32 ebx_894 = fp + ~0x8897 + dwLoc88BC_566;
								int32 esi_902 = 0x00;
								byte * edx_904 = ebx_894 - (esi_830 + ((int32) ax_872 << (byte) ((word32) bLoc88DC)) ^ ecx_237);
								do
								{
									word32 ecx_912 = (word32) *edx_904;
									*ebx_894 = (byte) ((ecx_237 << (byte) ecx_912) + ecx_912);
									esi_902 = esi_902 + 0x01;
									edx_904 = edx_904 + 0x01;
									ebx_894 = ebx_894 + 0x01;
								} while (esi_902 != dwLoc88B4_1076);
							}
							dwLoc88BC_566 = (word32) dwLoc88BC_566 + ((word32) globals->t40603C + 0x01) *s dwLoc88B4_1076;
						}
						int32 ebx_1126;
						struct Eq_737 * esp_1125;
						if (dwLoc88BC_566 > 0x00)
						{
							struct Eq_1020 * esi_1385 = (struct Eq_1020 *) ~0x00;
							struct Eq_1022 * edi_1386 = null;
							Eq_550 ebx_1387 = 0x00;
							do
							{
								ui32 edx_1411 = (word32) ((word32) ebx_1387.u0 - 0x00008894 + (fp - 0x04));
								int32 ecx_1422 = (uint32) ((uint64) (uint32) ecx_237 /u (edx_1411 | 0x01)) + edx_1411;
								byte cl_1423 = (byte) ecx_1422;
								if (esi_1385 <= (struct Eq_1020 *) 0x43)
								{
									if (edi_1386 < (struct Eq_1022 *) 0x0F0F0F1F)
										edi_1386 = (word32) (edi_1386->b404000 != cl_1423) - 0x01 & edi_1386 + 0x01;
									else
									{
										esi_1385 = esi_1385 + 0x01;
										if (esi_1385 <= (struct Eq_1020 *) 0x2F)
										{
											int32 ecx_1566 = (int32) esi_1385[0x00404010];
											ecx_1422 = (word32) (uint32) ((uint64) (uint32) ecx_237 /u (ecx_1566 | 0x01)) + ecx_1566;
										}
										else if (esi_1385 <= (struct Eq_1020 *) 0x3F)
											ecx_1422 = (int32) (esi_1385 - (ecx_237 << 0x30))->b404010;
										else
											ecx_1422 = (int32) (esi_1385 - (uint32) (0x40 % (ecx_237 - 0x01)))->b406000;
									}
								}
								byte al_1437 = (byte) ecx_1422;
								if (ecx_237 != 0x00)
									al_1437 = (byte) (ecx_1422 * 0x02);
								(word32) ebx_1387.u0 - 0x00008894 + (fp - 0x04) = (byte *) al_1437;
								ebx_1387 = (word32) ebx_1387.u0 + 0x01;
							} while (ebx_1387 != dwLoc88BC_566);
							*(esp_209 - 0x18) = 2441920163;
							*(esp_209 - 0x1C) = 2976162152;
							*(esp_209 - 0x14) = eax_17;
							<anonymous> * eax_1457 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_209 - 0x08) = 0x00;
							*(esp_209 - 0x10) = 0x00;
							*(esp_209 - 0x1C) = eax_211;
							*(esp_209 - 0x0C) = (union Eq_550 *) dwLoc88BC_566;
							globals->ptr40602C = eax_1457;
							*(esp_209 - 0x14) = 0x04;
							*(esp_209 - 0x18) = 0x00;
							ptr32 esp_1467;
							word32 ebp_1468;
							word32 eax_1469;
							word32 edi_1470;
							word32 esi_1471;
							word32 ebx_1472;
							byte SZO_1473;
							byte C_1474;
							byte Z_1475;
							word32 edx_1476;
							word32 ecx_1477;
							byte SCZO_1478;
							byte cl_1479;
							byte CZ_1480;
							byte dl_1481;
							word16 dx_1482;
							byte al_1483;
							word16 bx_1484;
							word16 ax_1485;
							word16 cx_1486;
							byte S_1487;
							byte ah_1488;
							byte bl_1489;
							eax_1457();
							*(esp_1467 - 0x10) = eax_17;
							*(esp_1467 - 0x14) = ~0x6A2DD289;
							*(esp_1467 - 0x18) = 2976162152;
							<anonymous> * eax_1497 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_1467 - 0x08) = 0x00;
							*(esp_1467 - 0x0C) = 0x00;
							*(esp_1467 - 0x10) = 0x00;
							*(esp_1467 - 0x14) = 0x02;
							*(esp_1467 - 0x18) = eax_1469;
							globals->ptr406030 = eax_1497;
							word32 esp_1504;
							word32 ebp_1505;
							int32 eax_1506;
							word32 edi_1507;
							word32 esi_1508;
							word32 ebx_1509;
							byte SZO_1510;
							byte C_1511;
							byte Z_1512;
							word32 edx_1513;
							word32 ecx_1514;
							byte SCZO_1515;
							byte cl_1516;
							byte CZ_1517;
							byte dl_1518;
							word16 dx_1519;
							byte al_1520;
							word16 bx_1521;
							word16 ax_1522;
							word16 cx_1523;
							byte S_1524;
							byte ah_1525;
							byte bl_1526;
							eax_1497();
							Eq_550 edx_1527 = 0x00;
							esp_1125 = esp_1504 - 0x14;
							ebx_1126 = eax_1506;
							do
							{
								*((word32) edx_1527 + eax_1506) = (byte) (word32) ((word32) edx_1527 - 0x00008894 + (fp - 0x04));
								edx_1527 = (word32) edx_1527 + 0x01;
							} while (edx_1527 != dwLoc88BC_566);
						}
						else
						{
							*(esp_209 - 0x18) = 2441920163;
							*(esp_209 - 0x1C) = 2976162152;
							*(esp_209 - 0x14) = eax_17;
							<anonymous> * eax_1604 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_209 - 0x08) = 0x00;
							*(esp_209 - 0x10) = 0x00;
							*(esp_209 - 0x1C) = eax_211;
							*(esp_209 - 0x0C) = (union Eq_550 *) dwLoc88BC_566;
							globals->ptr40602C = eax_1604;
							*(esp_209 - 0x14) = 0x04;
							*(esp_209 - 0x18) = 0x00;
							ptr32 esp_1614;
							word32 ebp_1615;
							word32 eax_1616;
							word32 edi_1617;
							word32 esi_1618;
							word32 ebx_1619;
							byte SZO_1620;
							byte C_1621;
							byte Z_1622;
							word32 edx_1623;
							word32 ecx_1624;
							byte SCZO_1625;
							byte cl_1626;
							byte CZ_1627;
							byte dl_1628;
							word16 dx_1629;
							byte al_1630;
							word16 bx_1631;
							word16 ax_1632;
							word16 cx_1633;
							byte S_1634;
							byte ah_1635;
							byte bl_1636;
							eax_1604();
							*(esp_1614 - 0x10) = eax_17;
							*(esp_1614 - 0x14) = ~0x6A2DD289;
							*(esp_1614 - 0x18) = 2976162152;
							<anonymous> * eax_1644 = fn004034A0(dwArg00, dwArg04, dwArg08);
							*(esp_1614 - 0x08) = 0x00;
							*(esp_1614 - 0x0C) = 0x00;
							*(esp_1614 - 0x10) = 0x00;
							*(esp_1614 - 0x14) = 0x02;
							*(esp_1614 - 0x18) = eax_1616;
							globals->ptr406030 = eax_1644;
							word32 esp_1651;
							word32 ebp_1652;
							int32 eax_1653;
							word32 edi_1654;
							word32 esi_1655;
							word32 ebx_1656;
							byte SZO_1657;
							byte C_1658;
							byte Z_1659;
							word32 edx_1660;
							word32 ecx_1661;
							byte SCZO_1662;
							byte cl_1663;
							byte CZ_1664;
							byte dl_1665;
							word16 dx_1666;
							byte al_1667;
							word16 bx_1668;
							word16 ax_1669;
							word16 cx_1670;
							byte S_1671;
							byte ah_1672;
							byte bl_1673;
							eax_1644();
							esp_1125 = esp_1651 - 0x14;
							ebx_1126 = eax_1653;
						}
						esp_1125->dw0004 = 3533983127;
						esp_1125->dw0000 = 2976162152;
						esp_1125->dw0008 = eax_17;
						<anonymous> * eax_1132 = fn004034A0(dwArg00, dwArg04, dwArg08);
						esp_1125->dw0000 = ebx_1126;
						globals->ptr406034 = eax_1132;
						struct Eq_1304 * esp_1135;
						word32 ebp_1136;
						word32 eax_1137;
						word32 edi_1138;
						word32 esi_1139;
						word32 ebx_1140;
						byte SZO_1141;
						byte C_1142;
						byte Z_1143;
						word32 edx_1144;
						word32 ecx_1145;
						byte SCZO_1146;
						byte cl_1147;
						byte CZ_1148;
						byte dl_1149;
						word16 dx_1150;
						byte al_1151;
						word16 bx_1152;
						word16 ax_1153;
						word16 cx_1154;
						byte S_1155;
						byte ah_1156;
						byte bl_1157;
						eax_1132();
						esp_1135->dw0004 = edi_1138;
						esp_1135->dw0000 = ~0x0C1531BF;
						*(esp_1135 - 0x04) = 2976162152;
						<anonymous> * eax_1163 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1135 - 0x04) = esi_1139;
						globals->ptr406008 = eax_1163;
						ptr32 esp_1166;
						word32 ebp_1167;
						word32 eax_1168;
						word32 edi_1169;
						word32 esi_1170;
						word32 ebx_1171;
						byte SZO_1172;
						byte C_1173;
						byte Z_1174;
						word32 edx_1175;
						word32 ecx_1176;
						byte SCZO_1177;
						byte cl_1178;
						byte CZ_1179;
						byte dl_1180;
						word16 dx_1181;
						byte al_1182;
						word16 bx_1183;
						word16 ax_1184;
						word16 cx_1185;
						byte S_1186;
						byte ah_1187;
						byte bl_1188;
						eax_1163();
						*(esp_1166 - 0x04) = eax_211;
						struct Eq_1377 * esp_1193;
						word32 ebp_1194;
						word32 eax_1195;
						word32 edi_1196;
						word32 esi_1197;
						word32 ebx_1198;
						byte SZO_1199;
						byte C_1200;
						byte Z_1201;
						word32 edx_1202;
						word32 ecx_1203;
						byte SCZO_1204;
						byte cl_1205;
						byte CZ_1206;
						byte dl_1207;
						word16 dx_1208;
						byte al_1209;
						word16 bx_1210;
						word16 ax_1211;
						word16 cx_1212;
						byte S_1213;
						byte ah_1214;
						byte bl_1215;
						globals->ptr406008();
						esp_1193->dw0004 = edi_1196;
						esp_1193->dw0000 = ~0x456B9945;
						*(esp_1193 - 0x04) = 2976162152;
						<anonymous> * eax_1221 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1193 - 0x04) = fp - 0x0164;
						globals->ptr40601C = eax_1221;
						struct Eq_1426 * esp_1225;
						word32 ebp_1226;
						word32 eax_1227;
						word32 edi_1228;
						word32 esi_1229;
						word32 ebx_1230;
						byte SZO_1231;
						byte C_1232;
						byte Z_1233;
						word32 edx_1234;
						word32 ecx_1235;
						byte SCZO_1236;
						byte cl_1237;
						byte CZ_1238;
						byte dl_1239;
						word16 dx_1240;
						byte al_1241;
						word16 bx_1242;
						word16 ax_1243;
						word16 cx_1244;
						byte S_1245;
						byte ah_1246;
						byte bl_1247;
						eax_1221();
						esp_1225->dw0004 = edi_1228;
						esp_1225->ptr0000 = 2721421706;
						*(esp_1225 - 0x04) = 2976162152;
						<anonymous> * eax_1255 = fn004034A0(dwArg00, dwArg04, dwArg08);
						esp_1225->ptr0000 = fp - 616;
						esp_1225->dw0004 = 0x0104;
						*(esp_1225 - 0x04) = 0x00;
						globals->ptr406018 = eax_1255;
						ptr32 esp_1261;
						word32 ebp_1262;
						word32 eax_1263;
						word32 edi_1264;
						word32 esi_1265;
						word32 ebx_1266;
						byte SZO_1267;
						byte C_1268;
						byte Z_1269;
						word32 edx_1270;
						word32 ecx_1271;
						byte SCZO_1272;
						byte cl_1273;
						byte CZ_1274;
						byte dl_1275;
						word16 dx_1276;
						byte al_1277;
						word16 bx_1278;
						word16 ax_1279;
						word16 cx_1280;
						byte S_1281;
						byte ah_1282;
						byte bl_1283;
						eax_1255();
						*(esp_1261 - 0x04) = ebx_1266;
						*(esp_1261 - 0x08) = 3646652680;
						*(esp_1261 - 0x0C) = 2976162152;
						<anonymous> * eax_1289 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1261 - 0x0C) = fp - 616;
						globals->ptr406038 = eax_1289;
						struct Eq_1532 * esp_1292;
						word32 ebp_1293;
						word32 eax_1294;
						word32 edi_1295;
						word32 esi_1296;
						word32 ebx_1297;
						byte SZO_1298;
						byte C_1299;
						byte Z_1300;
						word32 edx_1301;
						word32 ecx_1302;
						byte SCZO_1303;
						byte cl_1304;
						byte CZ_1305;
						byte dl_1306;
						word16 dx_1307;
						byte al_1308;
						word16 bx_1309;
						word16 ax_1310;
						word16 cx_1311;
						byte S_1312;
						byte ah_1313;
						byte bl_1314;
						eax_1289();
						esp_1292->dw0004 = eax_17;
						esp_1292->dw0000 = 840618587;
						*(esp_1292 - 0x04) = 2976162152;
						<anonymous> * eax_1321 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1292 - 0x04) = ebx_1297;
						globals->ptr406020 = eax_1321;
						struct Eq_1577 * esp_1324;
						word32 ebp_1325;
						word32 eax_1326;
						word32 edi_1327;
						word32 esi_1328;
						word32 ebx_1329;
						byte SZO_1330;
						byte C_1331;
						byte Z_1332;
						word32 edx_1333;
						word32 ecx_1334;
						byte SCZO_1335;
						byte cl_1336;
						byte CZ_1337;
						byte dl_1338;
						word16 dx_1339;
						byte al_1340;
						word16 bx_1341;
						word16 ax_1342;
						word16 cx_1343;
						byte S_1344;
						byte ah_1345;
						byte bl_1346;
						eax_1321();
						esp_1324->dw0004 = eax_17;
						esp_1324->dw0000 = 0x30E1FE37;
						*(esp_1324 - 0x04) = 2976162152;
						<anonymous> * eax_1353 = fn004034A0(dwArg00, dwArg04, dwArg08);
						*(esp_1324 - 0x04) = 0x00;
						globals->ptr406024 = eax_1353;
						word32 esp_1356;
						word32 ebp_1357;
						word32 eax_1358;
						word32 edi_1359;
						word32 esi_1360;
						word32 ebx_1361;
						byte SZO_1362;
						byte C_1363;
						byte Z_1364;
						word32 edx_1365;
						word32 ecx_1366;
						byte SCZO_1367;
						byte cl_1368;
						byte CZ_1369;
						byte dl_1370;
						word16 dx_1371;
						byte al_1372;
						word16 bx_1373;
						word16 ax_1374;
						word16 cx_1375;
						byte S_1376;
						byte ah_1377;
						byte bl_1378;
						eax_1353();
						return 0x00;
					}
					cl_422 = 0x00;
					ebx_446 = 0x00;
l00401330:
					edx_424 = ebx_446;
l00401332:
				} while (edx_424 >= eax_428);
			}
			struct Eq_514 * edi_441 = fp - 0x10 + (edx_424 * 0x03) * 0x02;
			ebx_446 = edx_424 + 0x01;
			byte al_445 = (byte) (word32) edi_441->tFFFFF77C;
			struct Eq_530 * eax_453 = fp - 0x10 + (ebx_446 * 0x03) * 0x02;
			if ((byte) (word32) al_445 > *(eax_453 - 0x0884))
			{
				word16 dx_466 = (word16) (word32) edi_441->wFFFFF77A;
				Eq_565 cx_468 = (word16) (word32) edi_441->tFFFFF778;
				edi_441->tFFFFF778 = eax_453->tFFFFF778;
				edi_441->tFFFFF77C = (word16) (word32) *(eax_453 - 0x0884);
				*(eax_453 - 0x0886) = dx_466;
				*(eax_453 - 0x0884) = (byte) (word32) al_445;
				eax_453->tFFFFF778 = cx_468;
				cl_422 = 0x01;
				edx_424 = ebx_446;
				goto l00401332;
			}
			goto l00401330;
		}
	}
	return 0x00;
}

// 00403350: Register int32 fn00403350(Stack int32 dwArg04, Stack int32 dwArg08, Stack (ptr byte) dwArg0C)
int32 fn00403350(int32 dwArg04, int32 dwArg08, byte * dwArg0C)
{
	Eq_250 edx_8 = globals->t40603C;
	int32 edi_118 = dwArg04;
	int32 ecx_24 = (0x00 - (edx_8 < 0x01) & ~0x63) + 200;
	byte bl_29 = (byte) (word32) *dwArg0C;
	if (bl_29 != 0x00)
	{
		byte cl_67 = (byte) edx_8;
		int32 ebx_84 = edx_8 - 0x01 & 0x33;
		int32 esi_91 = dwArg08 *s dwArg04;
		int32 edx_90 = ((uint32) (100 % (edx_8 - 0x01)) *s (((word32) edx_8 + 0x01) *s 0x55 + (0x25 << cl_67) *s ecx_24) + ebx_84) *s dwArg08;
		int32 eax_96 = fn00403350((word32) bl_29 + esi_91, edx_90, dwArg0C + 0x01);
		<anonymous> * eax_99 = globals->ptr406028;
		if (eax_99 != null)
		{
			word32 esp_122;
			word32 ebp_123;
			byte SCZO_124;
			word32 edx_125;
			word32 eax_126;
			word32 esi_127;
			word32 edi_128;
			byte C_129;
			word32 ecx_130;
			byte SZO_131;
			word32 ebx_132;
			byte bl_133;
			byte Z_134;
			byte cl_135;
			eax_99();
		}
		edi_118 = eax_96;
	}
	return edi_118;
}

// 00403420: Register ui32 fn00403420(Stack ui32 dwArg04, Stack (ptr byte) dwArg08)
ui32 fn00403420(ui32 dwArg04, byte * dwArg08)
{
	Eq_250 esi_16 = globals->t40603C;
	uint32 edx_23 = SLICE(esi_16 * 98685563, word32, 32);
	return dwArg04 ^ fn00403350(0x00, (((word32) (edx_23 + (esi_16 - edx_23 >> 0x01) >> 0x09) + 1000) *s ((word32) ((esi_16 - 0x04104105 >> 0x01) + 0x04104105 >> 0x05) + 0x003F) + 0x02B1) + (SLICE(esi_16 * 797903939, word32, 32) >> 0x07), dwArg08);
}

// 004034A0: Register ptr32 fn004034A0(Stack ui32 dwArg04, Stack int32 dwArg08, Stack (ptr Eq_40) dwArg0C)
ptr32 fn004034A0(ui32 dwArg04, int32 dwArg08, Eq_40 * dwArg0C)
{
	struct Eq_1878 * esi_192;
	Eq_250 ebx_121 = globals->t40603C;
	word32 edi_33 = dwArg0C *s (ebx_121 + 0x01) + Mem0[((uint32) ((uint64) ((uint32) ebx_121) /u (dwArg0C | 0x01)) + 0x78) + (dwArg0C + Mem0[dwArg0C + 0x3C:word32]):word32];
	word32 eax_34 = edi_33->dw0020;
	word32 ecx_36 = edi_33->dw0024;
	if (eax_34 != ~0x00)
		esi_192 = (uint32) ((uint64) (uint32) eax_34 % (ebx_121 - 0x01));
	else
		esi_192 = (struct Eq_1878 *) ~0x00;
	if ((edi_33->dw0018 & ebx_121 - 0x01) != 0x00)
	{
		word32 esi_107[] = esi_192 + dwArg0C;
		word32 eax_109 = (dwArg0C << (byte) ebx_121) + ecx_36;
		uint32 esi_111 = 0x00;
		do
		{
			word16 * edx_129 = eax_109 + esi_111 * 0x02;
			word32 eax_131 = esi_107[esi_111];
			ui32 edx_132 = dwArg04;
			if (ebx_121 != 0x00)
				edx_132 = dwArg04 * 0x02;
			int32 eax_140 = fn00403420(edx_132, dwArg0C + eax_131 / 0x0040);
			ebx_121 = globals->t40603C;
			if (eax_140 == ((word32) ebx_121.u0 + 0x01) *s dwArg08)
			{
				Eq_1983 ecx_150[] = dwArg0C + edi_33->dw001C / 0x0040;
				word32 esi_156 = dwArg0C + Mem0[(ecx_150 + (word32) (*edx_129) * 0x04) + (ebx_121 << (byte) ecx_150):word32];
				return esi_156 + (uint32) ((uint64) ((uint32) ebx_121) /u (esi_156 | 0x01));
			}
			esi_111 = esi_111 + 0x01;
		} while ((ebx_121 - 0x01 & edi_33->dw0018) > esi_111);
	}
	return 0x00;
}

// 004035B0: Register ui32 fn004035B0()
ui32 fn004035B0()
{
	Eq_250 esi_19 = globals->t40603C;
	uint32 eax_27 = *((word32) esi_19.u0 + (((fs->ptr0018)->dw0030 ^ esi_19)->ptr000C + 0x1C));
	byte dl_34 = (byte) (uint32) (0x6B % (esi_19 - 0x01));
	struct Eq_2018 * ebx_37 = eax_27 >> (byte) esi_19;
	do
	{
		ui32 eax_100;
		struct Eq_2022 * ecx_51 = ebx_37->dw0020 & esi_19 - 0x01;
		if (ecx_51->b0000 == dl_34 && (ecx_51->b0002 == (byte) ((word32) bLoc18) && ecx_51->b0004 == (byte) (esi_19 ^ 114)))
		{
			eax_100 = ebx_37->dw0008 | esi_19;
			return eax_100;
		}
		ebx_37 = ebx_37->dw0000 >> (byte) esi_19;
	} while (eax_27 != ebx_37->dw0000);
	eax_100 = 0x00;
	return eax_100;
}

// 00403640: void fn00403640(Register uint32 eax, Stack (ptr code) dwArg00)
void fn00403640(uint32 eax, code * dwArg00)
{
	struct Eq_2060 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	byte C_36;
	byte SZO_37;
	bcuiposr0 None_38;
	dwArg00();
}

