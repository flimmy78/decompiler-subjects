// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004011F8: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	byte al_14 = (byte) ebx;
	word32 edx_17 = __rol(edx, 0x02);
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	*ebx = *ebx + al_14;
	Eq_112 esp_52;
	byte SCZO_54;
	word32 ebx_55;
	word32 edi_56;
	word32 esi_57;
	word32 eax_58;
	word32 edx_59;
	byte C_60;
	byte al_61;
	word16 di_62;
	byte SZO_63;
	byte Z_64;
	int32 ebp_65;
	byte dl_66;
	word16 dx_67;
	word16 cx_68;
	word16 ax_69;
	word16 si_70;
	struct Eq_130 * fs_71;
	ui32 ecx_53;
	globals->ptr401075();
	Eq_112 esi_72 = esp_52;
	do
	{
		ui32 eax_80 = *esi_72;
		esi_72 = (word32) esi_72 + 0x01;
		ecx_53 = __ror(ecx_53, 0x0A);
	} while (eax_80 != 0x00);
	__ror(eax_80, 0x12);
	ui32 esi_108 = esi_72 - 0x6CC206AD | ~0x1B035D12;
	if (DPB(0x90, 0x90 - (~~0x07 + ebp_65), 0) == 0x00)
	{
		word16 ax_146 = (word16) esp_52;
		struct Eq_169 * edi_154 = DPB(1233235, ax_146, 0) + 0x00;
		__rol(ax_146, 0x04);
		ui32 ecx_158 = 0x004010E8;
		ui32 eax_161 = globals->dw40110D;
		do
		{
			edi_154 = edi_154 + 0x01;
			ecx_158 = edi_154 + ecx_158 ^ edi_154;
			word32 edx_174 = edi_154->dw0000 - eax_161;
		} while (edx_174 != 0x00);
		__ror(ecx_158, 0x02);
		ui32 eax_183 = ~(eax_161 | 0x93D50305);
		ui32 edx_189 = DPB(edx_174, edi_154->wFFFFFFFD, 0);
		ui32 eax_195 = &edi_154->wFFFFFFFD + DPB(eax_183, __rol((word16) eax_183, 0x0C), 0);
		*(esp_52 - 0x04) = (union Eq_112 *) esp_52;
		word32 * ecx_199 = *(esp_52 - 0x04);
		__rol(eax_195, 0x1E);
		*(esp_52 - 0x04) = *ecx_199;
		ui32 edi_214 = globals->dw40104D;
		Eq_2 edx_208 = *(esp_52 - 0x04);
		ui32 esi_216 = edi_214 & 0x0040104D;
		do
		{
			int32 eax_224 = *edx_208;
			esi_216 = esi_216 - eax_224;
			edx_208 = (word32) edx_208 + 0x01;
			word16 si_231 = (word16) esi_216;
			word16 ax_236 = (word16) (eax_224 >> 0x11);
		} while ((eax_224 ^ edi_214) != 0x00);
		int32 eax_246 = DPB(eax_224 >> 0x11, __ror(ax_236, 0x0C), 0);
		__ror(si_231, 0x0A);
		uint32 eax_256 = edx_189 << 0x10 >> 0x10;
		*(esp_52 - 0x04) = eax_256 + 4133933;
		*(esp_52 - 0x08) = fs_71->ptr0000;
		fs_71->ptr0000 = esp_52 - 0x08;
		*(esp_52 - 0x0C) = 0x00;
		__ror((word16) ((eax_256 + 4133933 ^ eax_246) << 11), 0x04);
		*(esp_52 - 0x10) = (union Eq_2 *) edx_208;
		return edx_208;
	}
	else
	{
		*(esp_52 - 0x04) = 0x56EF2652;
		*(esp_52 - 0x08) = esi_108;
		ImageList_GetDragImage(*(esp_52 - 0x08), *(esp_52 - 0x04));
		*(esp_52 - 0x0C) = esi_108;
		return RegLoadKeyW(*(esp_52 - 0x0C), *(esp_52 - 0x08), *(esp_52 - 0x04));
	}
}

