// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401005: Register word32 fn00401005(Stack ui32 dwArg04, Register out ptr32 ebxOut)
word32 fn00401005(ui32 dwArg04, ptr32 & ebxOut)
{
	ptr32 eax_12 = fs->ptr0000;
	fs->ptr0000 = fp - 0x10;
	struct Eq_14 * esp_111 = fp - 44;
	if (dwArg04 == ~0x08)
	{
		word32 ebp_133;
		word32 eax_134;
		word32 ecx_136;
		byte SCZO_137;
		word32 ebx_138;
		word32 esi_139;
		word32 edi_140;
		byte SZO_141;
		byte C_142;
		byte Z_143;
		word32 edx_144;
		CxxThrowException();
	}
	if (dwArg04 == 0x00)
	{
		word32 * esp_106 = esp_111 - 0x04;
		*esp_106 = 0x00405070;
		*(esp_106 - 0x04) = fp - 0x1C;
		word32 ebp_112;
		word32 eax_113;
		word32 ecx_115;
		byte SCZO_116;
		word32 ebx_117;
		word32 esi_118;
		word32 edi_119;
		byte SZO_120;
		byte C_121;
		byte Z_122;
		word32 edx_123;
		CxxThrowException();
	}
	fs->ptr0000 = eax_12;
	word32 ebx_100;
	*ebxOut = esp_111->dw000C;
	return dwArg04 + 0x0A;
}

// 004014A8: Register Eq_70 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	word32 esi_2 = fn00401A50();
	ptr32 esp_15 = fp - 0x08;
	word32 * ebp_10 = fn00401970(ebx, esi_2, edi, dwLoc0C, 4215192, 0x10);
	Eq_94 ebx_11 = null;
	if (globals->dw4064E4 == 0x00)
	{
		*(fp - 0x0C) = 0x00;
		*(fp - 0x10) = 0x00;
		*(fp - 0x14) = 0x01;
		*(fp - 0x18) = 0x00;
		HeapSetInformation(*(fp - 0x18), Mem256[fp - 0x14 + 0x00:HEAP_INFORMATION_CLASS], Mem256[fp - 0x14 + 0x00:PVOID], Mem256[fp - 0x10 + 0x00:SIZE_T]);
		esp_15 = fp - 0x18;
	}
	*(ebp_10 - 0x04) = 0x00;
	Eq_94 esi_19 = fs->ptr0018->t0004;
	*(ebp_10 - 0x1C) = 0x00;
	while (true)
	{
		LONG * esp_23 = esp_15 - 0x04;
		*esp_23 = (LONG *) null;
		*(esp_23 - 0x04) = (LONG *) esi_19;
		*(esp_23 - 0x08) = 0x004064CC;
		ptr32 esp_140 = esp_23 - 0x08;
		Eq_94 eax_29 = InterlockedCompareExchange(*(esp_23 - 0x08), *(esp_23 - 0x04), *esp_23);
		if (eax_29 == null)
			break;
		if (eax_29 == esi_19)
		{
			*(ebp_10 - 0x1C) = 0x01;
			break;
		}
		*(esp_23 - 0x0C) = 1000;
		Sleep(*(esp_23 - 0x0C));
		esp_15 = esp_23 - 0x0C;
	}
	int32 eax_123;
	word32 esi_200 = 0x01;
	word32 eax_35 = globals->dw4064BC;
	if (eax_35 == 0x01)
	{
		*(esp_23 - 0x0C) = 0x1F;
		word32 esp_191;
		byte SZO_193;
		byte C_194;
		byte SCZO_195;
		byte Z_196;
		word32 eax_197;
		struct Eq_260 * fs_199;
		word32 edi_201;
		word32 ecx_202;
		amsg_exit();
		esp_140 = esp_191 + 0x04;
	}
	else
	{
		word32 eax_205 = globals->dw4064BC;
		if (eax_205 == 0x00)
		{
			globals->dw4064BC = 0x01;
			*(esp_23 - 0x0C) = 4212248;
			*(esp_23 - 0x10) = 0x0040430C;
			word32 esp_214;
			byte SZO_216;
			byte C_217;
			byte SCZO_218;
			byte Z_219;
			word32 eax_220;
			struct Eq_295 * fs_222;
			word32 edi_224;
			word32 ecx_225;
			initterm_e();
			esp_140 = esp_214 + 0x08;
			if (eax_220 != 0x00)
			{
				*(ebp_10 - 0x04) = ~0x01;
				eax_123 = 0xFF;
				goto l004013A1;
			}
		}
		else
			globals->dw406184 = 0x01;
	}
	word32 eax_63 = globals->dw4064BC;
	if (eax_63 == esi_200)
	{
		word32 * esp_167 = esp_140 - 0x04;
		*esp_167 = 0x00404208;
		*(esp_167 - 0x04) = 0x00404000;
		word32 esp_171;
		byte SZO_173;
		byte C_174;
		byte SCZO_175;
		byte Z_176;
		word32 eax_177;
		struct Eq_350 * fs_179;
		word32 esi_180;
		word32 edi_181;
		word32 ecx_182;
		initterm();
		globals->dw4064BC = 0x02;
		esp_140 = esp_171 + 0x08;
	}
	if (*(ebp_10 - 0x1C) == ebx_11)
	{
		LONG * esp_162 = esp_140 - 0x04;
		*esp_162 = (LONG *) ebx_11;
		*(esp_162 - 0x04) = 0x004064CC;
		InterlockedExchange(*(esp_162 - 0x04), *esp_162);
		esp_140 = esp_162 - 0x04;
	}
	if (globals->t4064E8 != ebx_11)
	{
		LONG * esp_136 = esp_140 - 0x04;
		*esp_136 = &globals->t4064E8;
		word32 eax_138 = fn004018A0(dwArg00);
		esp_140 = (char *) esp_136 + 0x04;
		if (eax_138 != 0x00)
		{
			*esp_136 = (LONG *) ebx_11;
			*(esp_136 - 0x04) = 0x02;
			*(esp_136 - 0x08) = (LONG *) ebx_11;
			word32 ebx_151;
			byte SZO_152;
			byte C_153;
			byte SCZO_154;
			byte Z_155;
			word32 eax_156;
			struct Eq_465 * fs_158;
			word32 esi_159;
			word32 edi_160;
			word32 ecx_161;
			globals->t4064E8();
		}
	}
	*_initenv = globals->dw40616C;
	int32 * esp_93 = esp_140 - 0x04;
	*esp_93 = globals->dw40616C;
	*(esp_93 - 0x04) = globals->dw406170;
	*(esp_93 - 0x08) = globals->dw406168;
	word32 ebx_101;
	int32 eax_102 = fn00401005(dwArg00, out ebx_101);
	globals->dw406180 = eax_102;
	if (globals->dw406174 == ebx_101)
	{
		*esp_93 = eax_102;
		exit(*esp_93);
	}
	if (globals->dw406184 == ebx_101)
	{
		word32 esp_124;
		word32 ebx_125;
		byte SZO_126;
		byte C_127;
		byte SCZO_128;
		byte Z_129;
		word32 eax_130;
		struct Eq_499 * fs_132;
		word32 esi_133;
		word32 edi_134;
		word32 ecx_135;
		cexit();
	}
	*(ebp_10 - 0x04) = ~0x01;
	eax_123 = globals->dw406180;
l004013A1:
	fn004019B5(ebp_10, 0x10, dwArg00, dwArg04, dwArg08, dwArg0C);
	return eax_123;
}

// 00401810: Register word32 fn00401810(Stack (ptr Eq_506) dwArg04)
word32 fn00401810(Eq_506 * dwArg04)
{
	if (dwArg04->w0000 == 23117)
	{
		struct Eq_512 * eax_39 = dwArg04 + dwArg04->dw003C / 0x0040;
		if (eax_39->dw0000 == 0x4550)
			return (word32) (eax_39->w0018 == 0x010B);
	}
	return 0x00;
}

// 00401850: Register (ptr Eq_529) fn00401850(Stack (ptr Eq_530) dwArg04, Stack uint32 dwArg08)
Eq_529 * fn00401850(Eq_530 * dwArg04, uint32 dwArg08)
{
	struct Eq_532 * ecx_12 = dwArg04 + dwArg04->dw003C / 0x0040;
	uint32 esi_20 = (word32) ecx_12->w0006;
	uint32 edx_21 = 0x00;
	struct Eq_529 * eax_24 = &(ecx_12 + ((word32) ecx_12->w0014 + 0x18) / 22)->w0006 + 0x03;
	if (esi_20 != 0x00)
	{
		do
		{
			uint32 ecx_56 = eax_24->dw0000;
			if (dwArg08 >= ecx_56 && dwArg08 < eax_24->dw0008 + ecx_56)
				return eax_24;
			edx_21 = edx_21 + 0x01;
			eax_24 = eax_24 + 0x01;
		} while (edx_21 < esi_20);
	}
	eax_24 = null;
	return eax_24;
}

// 004018A0: Register ui32 fn004018A0(Stack ui32 dwArg04)
ui32 fn004018A0(ui32 dwArg04)
{
	ptr32 eax_16 = fs->ptr0000;
	fs->ptr0000 = fp - 0x14;
	if (fn00401810(&globals->t400000) != 0x00)
	{
		struct Eq_591 * eax_92 = fn00401850(&globals->t400000, dwArg04 - 0x00400000);
		if (eax_92 != null)
		{
			uint32 eax_99 = ~(eax_92->dw0024 >> 0x1F);
			fs->ptr0000 = eax_16;
			return eax_99 & 0x01;
		}
	}
	fs->ptr0000 = eax_16;
	return 0x00;
}

// 00401970: Register ptr32 fn00401970(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn00401970(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = globals->dw406020 ^ fp + 0x08;
	*(esp_14 - 0x14) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 004019B5: void fn004019B5(Register (ptr word32) ebp, Stack word32 dwArg00, Stack ui32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack word32 dwArg10)
void fn004019B5(word32 * ebp, word32 dwArg00, ui32 dwArg04, word32 dwArg08, word32 dwArg0C, word32 dwArg10)
{
	fs->dw0000 = *(ebp - 0x10);
	*ebp = dwArg00;
}

// 00401A50: Register ptr32 fn00401A50()
ptr32 fn00401A50()
{
	ui32 eax_10 = globals->dw406020;
	if (eax_10 != 0xBB40E64E && (eax_10 & 0xFFFF0000) != 0x00)
		globals->dw406024 = ~eax_10;
	else
	{
		GetSystemTimeAsFileTime(fp - 0x0C);
		ui32 esi_60 = dwLoc08 & 0x00 ^ dwLoc0C & 0x00 ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(fp - 0x14);
		ui32 esi_69 = esi_60 ^ (dwLoc10 ^ dwLoc14);
		if (esi_69 == 0xBB40E64E)
			esi_69 = ~0x44BF19B0;
		else if ((esi_69 & 0xFFFF0000) == 0x00)
			esi_69 = esi_69 | (esi_69 | 0x4711) << 0x10;
		globals->dw406020 = esi_69;
		globals->dw406024 = ~esi_69;
		esi = fp - 0x14;
	}
	return esi;
}

