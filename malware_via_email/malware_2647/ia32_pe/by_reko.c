// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: void fn00401000()
void fn00401000()
{
}

// 00401102: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	ptr32 esp_37;
	word32 ebp_38;
	word32 edx_39;
	byte SZO_40;
	byte C_41;
	byte SCZO_42;
	word32 esi_43;
	word32 edi_44;
	word32 ecx_45;
	word32 ebx_46;
	word32 eax_47;
	byte Z_48;
	byte al_49;
	byte bl_50;
	byte cl_51;
	NTDLL.dll!NtSetSystemEnvironmentValue();
	if (eax_47 != 0xC0000005)
	{
		int3();
		word32 esp_515;
		word32 ebp_516;
		word32 edx_517;
		byte SZO_518;
		byte C_519;
		byte SCZO_520;
		word32 esi_521;
		word32 edi_522;
		word32 ecx_523;
		word32 ebx_524;
		word32 eax_525;
		byte Z_526;
		byte al_527;
		byte bl_528;
		byte cl_529;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_530;
		word32 ebp_531;
		word32 edx_532;
		byte SZO_533;
		byte C_534;
		byte SCZO_535;
		word32 esi_536;
		word32 edi_537;
		word32 ecx_538;
		word32 ebx_539;
		word32 eax_540;
		byte Z_541;
		byte al_542;
		byte bl_543;
		byte cl_544;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_545;
		word32 ebp_546;
		word32 edx_547;
		byte SZO_548;
		byte C_549;
		byte SCZO_550;
		word32 esi_551;
		word32 edi_552;
		word32 ecx_553;
		word32 ebx_554;
		word32 eax_555;
		byte Z_556;
		byte al_557;
		byte bl_558;
		byte cl_559;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_560;
		word32 ebp_561;
		word32 edx_562;
		byte SZO_563;
		byte C_564;
		byte SCZO_565;
		word32 esi_566;
		word32 edi_567;
		word32 ecx_568;
		word32 ebx_569;
		word32 eax_570;
		byte Z_571;
		byte al_572;
		byte bl_573;
		byte cl_574;
		RTUTILS.dll!TraceDumpExA();
		word32 esp_575;
		word32 ebp_576;
		word32 edx_577;
		byte SZO_578;
		byte C_579;
		byte SCZO_580;
		word32 esi_581;
		word32 edi_582;
		word32 ecx_583;
		word32 ebx_584;
		word32 eax_585;
		byte Z_586;
		byte al_587;
		byte bl_588;
		byte cl_589;
		RTUTILS.dll!TraceDumpExW();
		word32 esp_590;
		word32 ebp_591;
		word32 edx_592;
		byte SZO_593;
		byte C_594;
		byte SCZO_595;
		word32 esi_596;
		word32 edi_597;
		word32 ecx_598;
		word32 ebx_599;
		Eq_2 eax_600;
		byte Z_601;
		byte al_602;
		byte bl_603;
		byte cl_604;
		RTUTILS.dll!TraceDumpExA();
		fn00401000();
		return eax_600;
	}
	else
	{
		*(esp_37 - 0x04) = fp - 0x40;
		*(esp_37 - 0x08) = fp - 0x40;
		*(esp_37 - 0x0C) = fp - 0x40;
		*(esp_37 - 0x10) = fp - 0x40;
		*(esp_37 - 0x14) = fp - 0x40;
		word32 ebp_106;
		word32 edx_107;
		byte SZO_108;
		byte C_109;
		byte SCZO_110;
		word32 esi_111;
		word32 edi_112;
		word32 ecx_113;
		word32 ebx_114;
		word32 eax_115;
		byte Z_116;
		byte al_117;
		byte bl_118;
		byte cl_119;
		word32 esp_105;
		NTDLL.dll!NtQuerySemaphore();
		if (eax_115 != 0xC0000003 && eax_115 != 0xC0000004)
		{
			fn00401000();
			esp_105 = esp_105 + 0x04;
		}
		word32 * esp_129 = esp_105 - 0x04;
		*esp_129 = 0x00;
		*(esp_129 - 0x04) = 0x00;
		*(esp_129 - 0x08) = 0x00;
		*(esp_129 - 0x0C) = 0x00;
		*(esp_129 - 0x10) = 0x00;
		*(esp_129 - 0x14) = 0x00;
		*(esp_129 - 0x18) = 0x00;
		ptr32 esp_143;
		ptr32 ebp_144;
		word32 edx_145;
		byte SZO_146;
		byte C_147;
		byte SCZO_148;
		word32 esi_149;
		word32 edi_150;
		ui32 ecx_151;
		word32 ebx_152;
		ui32 eax_153;
		byte Z_154;
		byte al_155;
		byte bl_156;
		byte cl_157;
		RTUTILS.dll!TraceDumpExA();
		if (eax_153 != 0x57)
		{
			fn00401000();
			return eax_153 - 0x57;
		}
		else
		{
			word32 v16_169 = 0x00 - (0x800FF9D2 - eax_153);
			ui32 v17_175 = v16_169 + ((dwLoc4C & (ecx_151 & 0x00) + (eax_153 - 0x57)) + 2272615812 ^ 0x077AA4FF);
			fp - 0x04 + -0x18 = v17_175;
			struct Eq_267 * v20_201 = (dwLoc14 & 0x00) + ((fp - 0x04) + -424);
			*(esp_143 - 0x04) = 0x00415000;
			uint32 edi_219 = ~((dwLoc08 & v17_175) + -((v20_201 - (struct Eq_285 *) ~0x0F) *s 0x00 | 0x30));
			*(esp_143 - 0x08) = edi_219 - ~0x00;
			Eq_301 ecx_189 = v17_175 - ((v16_169 + 0x8070A97B ^ ~0x00) + 0x01) + dwLoc1C;
			*(esp_143 - 0x0C) = (LPVOID *) ecx_189;
			*(esp_143 - 0x10) = fp - 0x01AC;
			int32 edi_236 = fn00401354(ebp_144, edi_219);
			*(esp_143 - 0x0C) = 0x40;
			*(esp_143 - 0x10) = 0x3000;
			*(esp_143 - 0x14) = fp - 0x28;
			*(esp_143 - 0x18) = 0x00;
			Eq_2 eax_260 = VirtualAlloc(*(esp_143 - 0x18), *(esp_143 - 0x14), *(esp_143 - 0x10), *(esp_143 - 0x0C));
			struct Eq_381 * dwLoc20_210 = v20_201 - (struct Eq_285 *) ~0x0F;
			int32 dwLoc08_222 = edi_219 - ~0x00;
			Eq_385 dwLoc1C_250 = dwLoc1C & 0x00;
			Eq_388 edx_255 = fp - 0x28;
			ptr32 esp_258 = esp_143 - 0x18;
			Eq_2 dwLoc0C_261 = eax_260;
			union Eq_2 * ecx_262 = null;
			uint32 dwLoc01B0_270 = dwLoc01B0 & 0x00;
			if (0x00 == 0x00)
			{
				while (true)
				{
					uint32 edi_434 = v20_201[0x01];
					if (dwLoc01B0_270 >= edi_434)
						break;
					word32 * esp_438 = esp_258 - 0x04;
					*esp_438 = 0x00415000;
					*(esp_438 - 0x04) = (word32) dwLoc20_210->t0004;
					*(esp_438 - 0x08) = dwLoc20_210->dw0000 + 0x00400000;
					Mem453[esp_438 - 0x0C + 0x00:word32] = eax_260 + dwLoc1C_250;
					fn00401349(ebp_144, edi_434);
					esp_258 = esp_438 - 0x0C;
					dwLoc1C_250 = dwLoc1C_250 + Mem453[dwLoc20_210 + 0x04:word32];
					dwLoc01B0_270 = dwLoc01B0_270 + 0x01;
					dwLoc20_210 = dwLoc20_210 + 0x08;
				}
				word32 * esp_468 = esp_258 - 0x04;
				*esp_468 = 0x00400000;
				*(esp_468 - 0x04) = v14;
				ui32 ebx_495 = (word32) (v20_201 + (edi_434 & 0x00) / 0x08)->t0004 + ((edi_434 & 0x00) - v16);
				*(esp_468 - 0x08) = ebx_495;
				ui32 ebx_499 = ebx_495 & 0x00 | v13;
				*(esp_468 - 0x0C) = ebx_499;
				*(esp_468 - 0x10) = ebx_499 + 0x24000000;
				*(esp_468 - 0x14) = (union Eq_2 *) v13;
				return v13;
			}
			else
			{
				do
				{
					*(esp_143 - 0x1C) = (union Eq_2 **) ecx_262;
					edx_255 = edx_255 *s 0x00;
					Eq_2 v43_305 = dwLoc0C_261 & edx_255 | dwLoc0C_261 - ecx_189;
					dwLoc0C_261 = v43_305;
					Eq_2 eax_308 = v43_305;
					if (v43_305 >= dwArg0C)
						return eax_308;
					ui32 ebx_362 = (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg10[dwLoc08_222].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00] & 0xFF ^ ~0x00;
					union Eq_2 * ebx_372 = (word32) v43_305 + (ebx_362 + 0x01 & 0x00 ^ dwArg04);
					word32 ebx_383 = DPB(Mem294[ebx_372 + 0x00:word32], (byte) ((~(-ecx_189 - 0x01 | ~Mem294[dwArg08 + v43_305:word32]) & 0xFF) + (ebx_362 + 0x01)), 0);
					*(esp_143 - 0x1C) = 0x00;
					*ebx_372 = *(esp_143 - 0x1C);
					*(esp_143 - 0x1C) = (union Eq_2 **) ebx_372;
					Mem399[ebx_372 + 0x00:word32] = Mem395[ebx_372 + 0x00:word32] + -ebx_383 + fn004013B3();
					eax_308 = (*ebx_372 ^ ~0x00) + 0x01;
					*ebx_372 = (union Eq_2 *) eax_308;
					int32 edi_411 = (edi_236 & 0x00) + dwLoc08_222;
					ecx_262 = ebx_372;
					dwLoc08_222 = edi_411 + 0x01;
					edi_236 = edi_411;
					if (edi_411 == 0x00)
						dwLoc08_222 = edi_411 + 0x01 & 0x00;
				} while (dwLoc08_222 != 116);
				return eax_308;
			}
		}
	}
}

// 00401349: void fn00401349(Register ptr32 ebp, Register uint32 edi)
void fn00401349(ptr32 ebp, uint32 edi)
{
	if (true)
		fn00401000();
	else
		fn00401354(ebp, edi);
}

// 00401354: Register uint32 fn00401354(Register ptr32 ebp, Register uint32 edi)
uint32 fn00401354(ptr32 ebp, uint32 edi)
{
	if (true)
	{
		fn00401000();
		return edi;
	}
	else
	{
		word32 edx_29 = *(ebp - 0x08) + -~0x152F;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + edx_29;
		uint32 edi_41 = (edi & 0x00) + *(ebp - 0x10);
		*(ebp - 0x08) = -*(ebp - 0x08);
		return edi_41;
	}
}

// 004013B3: FlagGroup bool fn004013B3()
bool fn004013B3()
{
	return false;
}

