// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401010: Register word32 fn00401010(Register (arr Eq_7572) ebx, Stack uint32 dwArg04)
word32 fn00401010(Eq_7572 ebx[], uint32 dwArg04)
{
	struct Eq_5 * esp_107 = fp - 0x40;
	Eq_7572 ebp_106[] = null;
	uint32 edi_104 = (uint32) (0x40 /u dwArg04);
	if (true)
	{
		esp_107 = fp - 0x40;
		do
		{
			esp_107->ptr0014 = ebp_106;
			esp_107->dw001C = ebp_106;
			if (esp_107[0x01] > 0x14)
			{
				ptr32 esp_360;
				union Eq_46 * esp_339 = esp_107 - 0x04;
				*esp_339 = (union Eq_46 *) 0x00;
				Eq_50 eax_341 = GetDC(*esp_339);
				*(esp_339 - 0x04) = 0x20;
				*(esp_339 - 0x08) = 0x004030E8;
				*(esp_339 - 0x0C) = 0x0A;
				*(esp_339 - 0x10) = 0x0A;
				*(esp_339 - 0x14) = (HDC *) eax_341;
				TextOutA(*(esp_339 - 0x14), *(esp_339 - 0x10), *(esp_339 - 0x0C), *(esp_339 - 0x08), *(esp_339 - 0x04));
				ptr32 esp_351 = esp_339 - 0x14;
				if (eax_341 != null)
				{
					*(esp_339 - 0x18) = 0x00;
					*(esp_339 - 0x1C) = 0x0A;
					*(esp_339 - 0x20) = 0x0A;
					*(esp_339 - 0x24) = (HDC *) eax_341;
					esp_351 = esp_339 - 0x24;
					if (MoveToEx(*(esp_339 - 0x24), *(esp_339 - 0x20), *(esp_339 - 0x1C), *(esp_339 - 0x18)) != 0x00)
						goto l004010A7;
					*(esp_339 - 0x28) = 0x14;
					*(esp_339 - 44) = 0x00324345;
					*(esp_339 - 0x30) = (HDC *) eax_341;
					Polyline(*(esp_339 - 0x30), *(esp_339 - 44), *(esp_339 - 0x28));
					esp_360 = esp_339 - 0x30;
				}
				else
				{
l004010A7:
					int32 * esp_370 = esp_351 - 0x04;
					*esp_370 = 200;
					*(esp_370 - 0x04) = 0x96;
					Mem376[esp_370 - 0x08 + 0x00:word32] = eax_341 + 0x0A;
					LineTo(*(esp_370 - 0x08), *(esp_370 - 0x04), *esp_370);
					esp_360 = esp_370 - 0x08;
				}
				HDC * esp_361 = esp_360 - 0x04;
				*esp_361 = (HDC *) eax_341;
				*(esp_361 - 0x04) = 0x00;
				ReleaseDC(*(esp_361 - 0x04), *esp_361);
				esp_107 = esp_361 - 0x04;
			}
			else
				esp_107->ptr0014 = (Eq_7572 (*)[]) (ebp_106 + ((word32) (esp_107->b0013 != 0x00) * 0x08 + 0x0F) / 0x04);
			if (esp_107->dw0024 > 0x56)
			{
				Eq_46 eax_242 = GetForegroundWindow();
				esp_107->dw002C = (word32) eax_242;
				if (eax_242 != 0x00)
				{
					esp_107 = esp_107 - 0x04;
					esp_107->dw0000 = (word32) eax_242;
					Eq_50 eax_251 = GetDC(esp_107->dw0000);
					if (eax_251 != null)
					{
						ptr32 esp_280;
						*(esp_107 - 0x04) = 0x00101010;
						*(esp_107 - 0x08) = 0x03;
						*(esp_107 - 0x0C) = 0x02;
						Eq_338 eax_271 = CreatePen(*(esp_107 - 0x0C), *(esp_107 - 0x08), *(esp_107 - 0x04));
						if (eax_271 != null)
						{
							*(esp_107 - 0x10) = (HPEN *) eax_271;
							*(esp_107 - 0x14) = (HDC *) eax_251;
							SelectObject(*(esp_107 - 0x14), *(esp_107 - 0x10));
							esp_280 = esp_107 - 0x14;
						}
						else
						{
							*(esp_107 - 0x10) = (HDC *) eax_251;
							Eq_50 eax_294 = CreateCompatibleDC(*(esp_107 - 0x10));
							*(esp_107 - 0x14) = 0x00;
							*(esp_107 - 0x18) = (HDC *) eax_294;
							SelectObject(*(esp_107 - 0x18), *(esp_107 - 0x14));
							*(esp_107 - 0x1C) = 0x00CC0020;
							*(esp_107 - 0x20) = 0x00;
							*(esp_107 - 0x24) = 0x00;
							*(esp_107 - 0x28) = (HDC *) eax_294;
							*(esp_107 - 44) = 0x32;
							*(esp_107 - 0x30) = 0x32;
							*(esp_107 - 0x34) = 0x00;
							*(esp_107 - 0x38) = 0x00;
							*(esp_107 - 0x3C) = (HDC *) eax_251;
							BitBlt(*(esp_107 - 0x3C), *(esp_107 - 0x38), *(esp_107 - 0x34), *(esp_107 - 0x30), *(esp_107 - 44), *(esp_107 - 0x28), *(esp_107 - 0x24), *(esp_107 - 0x20), *(esp_107 - 0x1C));
							*(esp_107 - 0x40) = (HDC *) eax_294;
							DeleteDC(*(esp_107 - 0x40));
							esp_280 = esp_107 - 0x40;
						}
						struct Eq_544 * esp_281 = esp_280 - 0x04;
						esp_281->t0000 = eax_251;
						*(esp_281 - 0x04) = esp_281->dw0030;
						ReleaseDC(*(esp_281 - 0x04), esp_281->t0000);
						esp_107 = esp_281 - 0x04;
					}
					edi_104 = esp_107->dw0020;
				}
			}
			else
			{
				uint32 eax_326 = esp_107->ptr0014;
				if (eax_326 > edi_104 - 0x01)
					esp_107->ptr0014 = (uint32) ((uint64) (uint32) eax_326 % edi_104);
			}
			if (esp_107->dw0018 > 0x0A)
			{
				union Eq_46 * esp_226 = esp_107 - 0x04;
				*esp_226 = (union Eq_46 *) 0x004030F0;
				*(esp_226 - 0x04) = 0x01;
				*(esp_226 - 0x08) = 0x01;
				*(esp_226 - 0x0C) = 0x00;
				*(esp_226 - 0x10) = (union Eq_46 *) CreateEventA(*(esp_226 - 0x0C), *(esp_226 - 0x08), *(esp_226 - 0x04), *esp_226);
				SetEvent(*(esp_226 - 0x10));
				esp_107 = esp_226 - 0x10;
			}
			else
				esp_107->b0013 = esp_107->b0013 == 0x00;
			Eq_646 cl_155;
			if (esp_107->dw0024 > 0x50)
			{
				struct Eq_657 * esp_181 = esp_107 - 0x04;
				esp_181->t0000.u0 = 0x004030FC;
				*(esp_181 - 0x04) = 0x00;
				esp_107 = esp_181 - 0x04;
				Eq_46 eax_185 = FindWindowA(*(esp_181 - 0x04), esp_181->t0000);
				if (eax_185 != 0x00)
				{
					*(esp_181 - 0x08) = &esp_181->dw002C;
					*(esp_181 - 0x0C) = (union Eq_46 *) eax_185;
					esp_107 = esp_181 - 0x0C;
					if (GetWindowRect(*(esp_181 - 0x0C), *(esp_181 - 0x08)) != 0x00)
					{
						word32 eax_199 = esp_181->dw002C;
						*(esp_181 - 0x10) = 0x04;
						*(esp_181 - 0x14) = esp_181->dw0030;
						*(esp_181 - 0x18) = eax_199 + 0x32;
						*(esp_181 - 0x1C) = esp_181->dw0028;
						*(esp_181 - 0x20) = esp_181->dw0024;
						*(esp_181 - 0x24) = 0x00;
						*(esp_181 - 0x28) = (union Eq_46 *) eax_185;
						SetWindowPos(*(esp_181 - 0x28), *(esp_181 - 0x24), *(esp_181 - 0x20), *(esp_181 - 0x1C), *(esp_181 - 0x18), *(esp_181 - 0x14), *(esp_181 - 0x10));
						esp_107 = esp_181 - 0x28;
					}
				}
				goto l004011FF;
			}
			if (esp_107->dw0044 == 0x01)
			{
				cl_155 = (byte) (word32) Mem112[ebx + ebp_106:byte];
				goto l0040120A;
			}
			esp_107->dw001C = (word32) ebx[ebp_106];
l004011FF:
			if (esp_107->dw0044 == 0x01)
			{
				cl_155.u1 = esp_107->dw001C;
l0040120A:
				word32 eax_161 = Mem112[esp_107 + 0x14:word32] + ebx;
				Mem164[ebx + ebp_106:byte] = Mem112[eax_161 + 0x00:byte];
				*eax_161 = (union Eq_646 *) cl_155;
			}
			else
			{
				word32 * eax_176 = ebx + esp_107->ptr0014;
				ebx[ebp_106].u0 = *eax_176;
				*eax_176 = esp_107->dw001C;
			}
			uint32 ebp_149 = (char *) ebp_106 + 0x01;
			ebp_106 = ebp_149 + 0x01;
		} while (ebp_149 + 0x01 < edi_104);
	}
	word32 * esp_50 = esp_107 - 0x04;
	*esp_50 = 0x40;
	return *esp_50;
}

// 00401241: Register word32 fn00401241(Register (ptr Eq_881) ebx, Stack Eq_46 dwArg08)
word32 fn00401241(Eq_881 * ebx, Eq_46 dwArg08)
{
	uint32 esi_24 = 0x00;
	if (dwArg08 > 0x00)
	{
		do
		{
			word32 eax_26 = fp->dw0004;
			*(fp - 0x0C) = fp->dw000C;
			esi_24 = esi_24 + fn00401010(esi_24 + eax_26, dwArg00);
		} while (esi_24 < fp->dw0008);
	}
	return ebp;
}

// 00401268: void fn00401268(Register (ptr Eq_881) ebx, Register (ptr Eq_911) ebp, Stack Eq_46 dwArg04)
void fn00401268(Eq_881 * ebx, Eq_911 * ebp, Eq_46 dwArg04)
{
	struct Eq_913 * ebp_21 = fn00401241(ebx, dwArg04);
	*(fp - 0x10) = 0x04;
	*(fp - 0x14) = ebp_21->dw0008;
	*(fp - 0x18) = (struct Eq_881 **) ebx;
	struct Eq_913 * ebp_30 = fn00401241(ebx, dwArg04);
	word32 esi_34 = Mem29[ebx + 0x3C:word32] + ebx;
	Eq_46 eax_33 = ebp_30->t000C;
	*(fp - 0x10) = esi_34->dw0054;
	fn00401A5A(eax_33, ebx, dwArg00);
	word32 eax_42 = (word32) esi_34->w0014;
	ebp_30->dw0008 = ebp_30->dw0008 & 0x00;
	word32 eax_47 = esi_34 + (eax_42 + 0x18) / 88;
	if (0x00 < esi_34->w0006)
	{
		struct Eq_986 * edi_62 = eax_47 + 0x14;
		do
		{
			word32 eax_65 = *(edi_62 - 0x08);
			word32 ecx_66 = edi_62->dw0000;
			*(fp - 0x10) = *(edi_62 - 0x04);
			fn00401A5A((word32) ebp_30->t000C + eax_65, ebx + ecx_66, dwArg00);
			int32 eax_74 = (word32) esi_34->w0006;
			ebp_30->dw0008 = ebp_30->dw0008 + 0x01;
			edi_62 = edi_62 + 0x01;
		} while (ebp_30->dw0008 < eax_74);
	}
}

// 004012D3: Register word32 fn004012D3(Register (ptr Eq_1036) edi)
word32 fn004012D3(Eq_1036 * edi)
{
	struct Eq_1037 * ecx_10 = edi + edi->dw003C / 0x0040;
	ptr32 edx_13 = edi - ecx_10->dw0034;
	struct Eq_1036 * eax_109 = edi + ecx_10->dw00A0 / 0x0040;
	if (eax_109 != edi)
	{
		ui32 dwLoc0C_106 = dwLoc0C & 0x00;
		word32 esi_110 = eax_109->dw0004;
		if (esi_110 != 0x00)
		{
			do
			{
				uint32 edx_92 = esi_110 - 0x08;
				if (edx_92 >> 0x01 > 0x00)
				{
					word16 * dwLoc08_117 = &eax_109->dw0004 + 0x01;
					uint32 dwLoc10_118 = edx_92 >> 0x01;
					do
					{
						ui32 edx_123 = (word32) *dwLoc08_117;
						if ((word16) (edx_123 & 0xF000) == 0x3000)
						{
							word32 * edx_145 = edi + (eax_109->dw0000 + (edx_123 & 0x0FFF)) / 0x0040;
							*edx_145 = *edx_145 + edx_13;
						}
						uint32 v20_138 = dwLoc10_118 - 0x01;
						dwLoc08_117 = dwLoc08_117 + 0x01;
						dwLoc10_118 = v20_138;
					} while (v20_138 != 0x00);
				}
				ui32 v18_105 = dwLoc0C_106 + esi_110;
				eax_109 = edi + (ecx_10->dw00A0 + v18_105) / 0x0040;
				dwLoc0C_106 = v18_105;
				esi_110 = eax_109->dw0004;
			} while (esi_110 != 0x00);
		}
		return 0x01;
	}
	else
		return 0x00;
}

// 00401367: Register (ptr Eq_1121) fn00401367(Register (ptr Eq_1121) eax)
Eq_1121 * fn00401367(Eq_1121 * eax)
{
	if (eax->b0000 == 0x01)
	{
		eax = &eax->b0001;
		byte * ecx_20 = &eax->b0001;
		if (eax->b0001 != 0x00)
		{
			do
			{
				byte dl_29;
				byte dl_23 = *ecx_20;
				if (dl_23 != 0x00)
					dl_29 = dl_23 + 0x1E;
				else
					dl_29 = 0x00;
				*ecx_20 = dl_29;
				ecx_20 = ecx_20 + 0x01;
			} while (*ecx_20 != 0x00);
		}
	}
	return eax;
}

// 0040138A: void fn0040138A()
void fn0040138A()
{
}

// 00401390: Register Eq_46 fn00401390(Register (ptr Eq_911) ebp, Stack Eq_46 dwArg04, Stack Eq_46 dwArg08, Stack Eq_46 dwArg0C)
Eq_46 fn00401390(Eq_911 * ebp, Eq_46 dwArg04, Eq_46 dwArg08, Eq_46 dwArg0C)
{
	Eq_46 eax_133;
	if (dwArg04 != 0x00)
	{
		word32 eax_98 = Mem0[dwArg04 + 0x3C:word32] + dwArg04;
		if (eax_98 != null)
		{
			word32 eax_103 = Mem0[eax_98 + 0x78:word32] + dwArg04;
			if (eax_103 != dwArg04)
			{
				uint32 ecx_113 = *((word32) eax_103 + 0x0014);
				uint32 edx_109 = *((word32) eax_103 + 0x0018);
				word16 ecx_111[] = Mem0[eax_103 + 0x24:word32] + dwArg04;
				word32 edi_114[] = Mem0[eax_103 + 0x1C:word32] + dwArg04;
				word32 ebx_115[] = Mem0[eax_103 + 0x20:word32] + dwArg04;
				uint32 dwLoc08_118 = ecx_113;
				if (ecx_113 <= edx_109)
					dwLoc08_118 = edx_109;
				if (dwArg08 < 0x00)
				{
					uint32 edx_128 = (dwArg08 & 0x7FFFFFFF) - *((word32) eax_103 + 0x0010);
					if (edx_128 < ecx_113)
					{
						eax_133 = (word32) dwArg04 + edi_114[edx_128];
						return eax_133;
					}
				}
				else
				{
					uint32 eax_135 = 0x00;
					uint32 dwArg04_136 = 0x00;
					if (dwLoc08_118 > 0x00)
					{
						while (true)
						{
							uint32 ecx_146 = (word32) ecx_111[eax_135];
							if (eax_135 >= edx_109 || ecx_146 >= ecx_113)
								break;
							if (fn0040159A(dwArg08, (word32) dwArg04 + ebx_115[dwArg04_136]) != 0x00)
							{
								struct Eq_1174 ** ebx_171 = edi_114 + ecx_146;
								struct Eq_1174 * ecx_173 = *ebx_171;
								struct Eq_1174 * eax_174 = eax_98->ptr0078;
								if (ecx_173 >= eax_174)
								{
									struct Eq_1174 * edx_183 = eax_174 + eax_98->dw007C;
									if (ecx_173 < edx_183)
									{
										word32 eax_186 = ecx_173 + dwArg04;
										do
										{
											byte dl_189 = eax_186->b0000;
											eax_186 = eax_186 + 0x01;
										} while (dl_189 != 0x2E);
										ptr32 esp_207;
										word32 ebp_208;
										byte SCZO_209;
										struct Eq_1294 ** ebx_210;
										struct Eq_1278 * esi_211;
										<anonymous> ** edi_212;
										byte SZO_213;
										byte C_214;
										byte Z_215;
										Eq_46 eax_216;
										word32 ecx_217;
										word32 edx_218;
										byte CZ_219;
										byte S_220;
										byte dl_221;
										(*((word32) dwArg0C + 0x08))();
										if (eax_216 == 0x00)
											break;
										struct Eq_1294 * eax_226 = *ebx_210;
										*(esp_207 - 0x04) = (struct Eq_1301 **) (eax_186 - eax_226 - esi_211 - (struct Eq_1300 *) 0x01);
										word32 ecx_235 = eax_226 + esi_211;
										fn00401A5A(eax_216, ecx_235, dwArg00);
										*(esp_207 - 0x04) = (<anonymous> ***) edi_212;
										*(esp_207 - 0x08) = (struct Eq_1264 **) eax_186;
										*(esp_207 - 0x0C) = (union Eq_46 *) eax_216;
										struct Eq_1327 * esp_251;
										struct Eq_911 * ebp_252;
										byte SCZO_253;
										word32 ebx_254;
										word32 esi_255;
										struct Eq_1332 * edi_256;
										byte SZO_257;
										byte C_258;
										byte Z_259;
										word32 eax_260;
										word32 ecx_261;
										word32 edx_262;
										byte CZ_263;
										byte S_264;
										byte dl_265;
										(*edi_212)();
										*(esp_251 - 0x04) = eax_260;
										Eq_46 eax_268 = fn00401390(ebp_252, dwArg00, eax_216, eax_186 & 0x00);
										esp_251->dw0004 = ebx_254;
										esp_251->t0000 = eax_268;
										Eq_46 dwArg08_277 = esp_251->t0000;
										esp_251->dw0004 = 0x8000;
										esp_251->t0000.u0 = 0x00;
										*(esp_251 - 0x04) = (union Eq_46 *) eax_216;
										word32 esp_288;
										word32 ebp_289;
										byte SCZO_290;
										word32 ebx_291;
										word32 esi_292;
										word32 edi_293;
										byte SZO_294;
										byte C_295;
										byte Z_296;
										word32 eax_297;
										word32 ecx_298;
										word32 edx_299;
										byte CZ_300;
										byte S_301;
										byte dl_302;
										edi_256->ptr000C();
										eax_133 = dwArg08_277;
										return eax_133;
									}
								}
								eax_133 = ecx_173 + dwArg04;
								return eax_133;
							}
							uint32 v16_162 = dwArg04_136 + 0x01;
							dwArg04_136 = v16_162;
							if (v16_162 >= dwLoc08_118)
								break;
							eax_135 = v16_162;
						}
					}
				}
			}
		}
	}
	eax_133.u0 = 0x00;
	return eax_133;
}

// 004014E5: Register word32 fn004014E5(Register (ptr Eq_911) ebp, Stack Eq_46 dwArg04, Stack Eq_46 dwArg08)
word32 fn004014E5(Eq_911 * ebp, Eq_46 dwArg04, Eq_46 dwArg08)
{
	word32 eax_103;
	struct Eq_1402 * eax_11 = (word32) dwArg04 + ((word32) (*((word32) dwArg04 + 0x003C)) + 0x0078);
	Eq_46 edx_108 = dwArg04;
	Eq_46 esi_115 = (word32) dwArg04 + eax_11->dw0000;
	if (esi_115 == dwArg04)
	{
		eax_103 = 0x01;
		return eax_103;
	}
	uint32 eax_53 = *((word32) esi_115 + 0x0014);
	uint32 ecx_54 = *((word32) esi_115 + 0x0018);
	ptr32 esp_117 = fp - 0x20;
	word32 edi_111 = Mem0[esi_115 + 0x1C:word32] + dwArg04;
	word16 ebx_112[] = Mem0[esi_115 + 0x24:word32] + dwArg04;
	uint32 dwLoc0C_217 = eax_53;
	if (eax_53 <= ecx_54)
		dwLoc0C_217 = ecx_54;
	uint32 eax_113 = 0x00;
	uint32 dwLoc08_110 = 0x00;
	if (dwLoc0C_217 > 0x00)
	{
		while (true)
		{
			if (eax_113 < *((word32) esi_115 + 0x0014))
				eax_113 = (word32) ebx_112[eax_113];
			union Eq_46 * ecx_121 = edi_111 + eax_113 * 0x04;
			word32 eax_123 = Mem0[ecx_121 + 0x00:word32] + edx_108;
			if (eax_123 != edx_108)
			{
				if (eax_123 > esi_115)
				{
					if (eax_123 <u Mem0[eax_11 + 0x04:word32] *s 0x28 + esi_115)
					{
						Eq_46 ecx_181 = eax_123;
						do
							ecx_181 = (word32) ecx_181 + 0x01;
						while (*ecx_181 != 0x2E);
						*ecx_181 = 0x00;
						union Eq_46 * esp_189 = esp_117 - 0x04;
						*esp_189 = (union Eq_46 *) dwArg08;
						*(esp_189 - 0x04) = (word32) ecx_181 + 0x01;
						*(esp_189 - 0x08) = (union Eq_46 *) eax_123;
						ptr32 esp_197;
						struct Eq_911 * ebp_198;
						byte SCZO_199;
						word32 edx_200;
						word32 eax_201;
						byte Z_203;
						byte SZO_204;
						byte C_205;
						word32 ecx_206;
						byte CZ_209;
						(*dwArg08)();
						*(esp_197 - 0x04) = eax_201;
						eax_123 = fn00401390(ebp_198, dwArg00, dwArg04, dwArg08);
						esp_117 = esp_197 + 0x08;
					}
					edx_108 = dwArg04;
				}
				if (eax_123 == 0x00)
				{
					eax_103 = 0x00;
					return eax_103;
				}
				*ecx_121 = (union Eq_46 *) eax_123;
			}
			uint32 v15_137 = dwLoc08_110 + 0x01;
			dwLoc08_110 = v15_137;
			if (v15_137 >= dwLoc0C_217)
				break;
			eax_113 = v15_137;
		}
	}
	eax_103 = 0x01;
	return eax_103;
}

// 0040159A: Register Eq_46 fn0040159A(Register Eq_46 eax, Register ui32 ecx)
Eq_46 fn0040159A(Eq_46 eax, ui32 ecx)
{
	bool bl_9 = *eax == 0x01;
	if (bl_9 != 0x00)
		eax = (word32) eax + 0x01;
	Eq_46 eax_33;
	if (*eax != 0x02)
	{
		int32 esi_53 = ecx - eax;
		do
		{
			bool Z_68;
			byte cl_65;
			if (bl_9 != 0x00)
			{
				byte cl_81 = *eax;
				int32 edx_82 = (int32) cl_81;
				if (cl_81 != 0x00)
					edx_82 = edx_82 + 0x1E;
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = cond((int32) cl_65 - edx_82);
			}
			else
			{
				cl_65 = (byte) *((word32) eax + esi_53);
				Z_68 = cond(cl_65 - *eax);
			}
			if (Z_68)
			{
				eax_33.u0 = 0x00;
				return eax_33;
			}
			if (cl_65 == 0x00)
				break;
			eax = (word32) eax + 0x01;
		} while (*eax != 0x02);
	}
	eax_33.u0 = 0x01;
	return eax_33;
}

// 004015E7: Register word32 fn004015E7(Register (ptr Eq_881) ebx, Register (ptr Eq_911) ebp, Register (ptr Eq_1595) esi, Register out (ptr Eq_1596) ebpOut, Register out ptr32 esiOut)
word32 fn004015E7(Eq_881 * ebx, Eq_911 * ebp, Eq_1595 * esi, Eq_1596 * & ebpOut, ptr32 & esiOut)
{
	*esiOut = esi;
	*ebpOut = ebp;
	word32 eax_103;
	word32 eax_6 = Mem0[Mem0[esi + 0x3C:word32] + 0x80 + esi:word32] + esi;
	if (eax_6 == esi)
		eax_103 = 0x01;
	else
	{
		if (eax_6->dw0000 != 0x00)
		{
			struct Eq_1595 * ebx_69 = eax_6;
			do
			{
				struct Eq_1625 * edi_74 = fp->ptr0004;
				word32 edx_76 = ebx_69->dw0000;
				word32 eax_77 = ebx_69->dw0010;
				word32 ecx_78 = ebx_69->dw000C;
				*(fp - 0x0C) = (struct Eq_1595 **) esi;
				*(fp - 0x10) = esi + edx_76 / 0x0040;
				*(fp - 0x14) = esi + ecx_78 / 0x0040;
				if (fn0040166B(esi + eax_77 / 0x0040, &ebx_69->dw0010 + 0x01, ebp, edi_74, dwArg00, dwArg04, dwArg08, out ebx_69, out ebp, out esi) == 0x00)
				{
					eax_103 = 0x00;
					goto l00401630;
				}
			} while (ebx_69->dw0000 != 0x00);
		}
		eax_103 = 0x01;
l00401630:
	}
	return eax_103;
}

// 00401639: void fn00401639(Register (ptr Eq_1683) eax)
void fn00401639(Eq_1683 * eax)
{
	word32 esp_12;
	struct Eq_1685 * eax_13;
	eax->ptr0008();
	eax_13->b0008 = 0x02;
	eax_13->b0001 = 111;
	eax_13->b0003 = 0x62;
	eax_13->b0006 = 101;
	eax_13->b0002 = 0x6D;
	eax_13->b0005 = 110;
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x52;
	eax_13->b0004 = 0x69;
}

// 0040166B: Register Eq_46 fn0040166B(Register Eq_46 eax, Register ptr32 ebx, Register (ptr Eq_911) ebp, Register (ptr Eq_1625) edi, Stack word32 dwArg04, Stack Eq_46 dwArg08, Stack word32 dwArg0C, Register out (ptr Eq_1668) ebxOut, Register out ptr32 ebpOut, Register out (ptr Eq_1670) esiOut)
Eq_46 fn0040166B(Eq_46 eax, ptr32 ebx, Eq_911 * ebp, Eq_1625 * edi, word32 dwArg04, Eq_46 dwArg08, word32 dwArg0C, Eq_1668 * & ebxOut, ptr32 & ebpOut, Eq_1670 * & esiOut)
{
	struct Eq_1725 * esp_17;
	struct Eq_911 * ebp_18;
	word32 edi_21;
	byte SZO_22;
	byte C_23;
	byte Z_24;
	word32 ebx_25;
	byte SCZO_26;
	word32 ecx_27;
	byte S_28;
	word32 * esi_19;
	Eq_46 eax_117;
	edi->ptr0010();
	if (eax_117 != 0x00)
	{
		*(esp_17 - 0x04) = ebx_25;
		word32 ebx_53 = dwArg08 - esi_19;
		while (true)
		{
			int32 * ecx_59 = esi_19 + ebx_53;
			int32 eax_104 = 0x00;
			if (ecx_59 != null)
				eax_104 = *ecx_59;
			if (esi_19 == null || *esi_19 == 0x00)
				break;
			if (ecx_59 != null)
			{
				*(esp_17 - 0x08) = edi_21;
				if (eax_104 >= 0x00)
					eax_104 = eax_104 + 0x02 + dwArg0C;
				*(esp_17 - 0x0C) = eax_104;
				*(esp_17 - 0x10) = (union Eq_46 *) eax_117;
				Eq_46 eax_111 = fn00401390(ebp_18, dwArg00, eax_117, dwArg08);
				if (eax_111 == 0x00)
				{
					eax_117.u0 = 0x00;
					goto l004016C3;
				}
				*esi_19 = (word32) eax_111;
			}
			esi_19 = esi_19 + 0x01;
		}
		eax_117.u0 = 0x01;
l004016C3:
		word32 ebx_76;
		*ebxOut = *(esp_17 - 0x04);
	}
	word32 esi_42;
	*esiOut = esp_17->dw0000;
	word32 ebp_44;
	*ebpOut = esp_17->dw0004;
	return eax_117;
}

// 004016C9: void fn004016C9(Register (ptr Eq_1816) eax)
void fn004016C9(Eq_1816 * eax)
{
	word32 esp_12;
	struct Eq_1818 * eax_13;
	eax->ptr0008();
	eax_13->b0000 = 0x43;
	eax_13->b0007 = 0x02;
	eax_13->b0002 = 101;
	eax_13->b0005 = 101;
	eax_13->b0003 = 0x61;
	eax_13->b0001 = 114;
	eax_13->b0006 = 0x52;
	eax_13->b0004 = 116;
}

// 004016F7: Register (ptr Eq_1854) fn004016F7(Register (ptr Eq_1854) eax, Stack Eq_46 dwArg04)
Eq_1854 * fn004016F7(Eq_1854 * eax, Eq_46 dwArg04)
{
	word32 esi_13 = Mem0[Mem0[eax + 0x3C:word32] + 0x88 + eax:word32] + eax;
	if (esi_13 != eax)
	{
		ptr32 eax_39 = eax - dwArg04;
		if (eax_39 != 0x00)
		{
			uint32 ebx_47 = 0x00;
			if (0x00 < esi_13->w000E)
			{
				struct Eq_1878 * edi_62 = &esi_13->w000E + 0x03;
				do
				{
					fn00401A35(esi_13 + ((edi_62->dw0000 & 0x7FFFFFFF) + 0x10) / 0x0040, esi_13, eax_39);
					edi_62 = edi_62 + 0x01;
					ebx_47 = ebx_47 + 0x01;
				} while (ebx_47 < (word32) esi_13->w000E);
			}
		}
	}
	return (struct Eq_1854 *) 0x01;
}

// 0040174B: void fn0040174B(Register (ptr Eq_1904) eax)
void fn0040174B(Eq_1904 * eax)
{
	eax->b0000 = 0x47;
	eax->b0001 = 101;
	eax->b0005 = 0x67;
	eax->b0006 = 0x02;
	eax->b0002 = 116;
	eax->b0004 = 101;
	eax->b0003 = 0x52;
}

// 00401767: void fn00401767(Register (ptr Eq_1933) eax)
void fn00401767(Eq_1933 * eax)
{
	word32 esp_12;
	struct Eq_1935 * eax_13;
	eax->ptr0008();
	eax_13->b0007 = 0x6C;
	eax_13->b0006 = 100;
	eax_13->b0003 = 0x33;
	eax_13->b0008 = 0x6C;
	eax_13->b0000 = 0x67;
	eax_13->b0001 = 100;
	eax_13->b0004 = 0x32;
	eax_13->b0005 = 0x2E;
	eax_13->b0002 = 0x69;
}

// 00401799: Register word32 fn00401799(Register (ptr Eq_1976) edx, Register (ptr Eq_911) ebp, Register ptr32 esi)
word32 fn00401799(Eq_1976 * edx, Eq_911 * ebp, ptr32 esi)
{
	word32 eax_10 = Mem0[Mem0[edx + 0x3C:word32] + 0x80 + edx:word32] + edx;
	if (eax_10 != edx)
	{
		ui32 edi_157 = 0x00;
		struct Eq_1976 * ecx_146 = eax_10;
		do
		{
			word32 eax_106;
			if (ecx_234->dw0000 == 0x00)
				goto l00401800;
			ecx_146 = &ecx_234->dw0010 + 0x01;
			struct Eq_1976 * ecx_234 = ecx_146;
		} while (edx[ecx_234->dw000C / 0x0040] != 0x4B);
		word32 eax_151[] = edx + ecx_234->dw0010 / 0x0040;
		struct Eq_2025 * ecx_152[] = edx + ecx_234->dw0000 / 0x0040;
		if (eax_151[0x00] != 0x00)
		{
			do
			{
				struct Eq_2025 * ebx_158 = ecx_152[edi_157];
				if (ebx_158 >= null)
				{
					word32 ebx_168 = ebx_158 + edx;
					if (ebx_168->b0002 == 0x47 && (ebx_168->b0003 == 101 && (ebx_168->b0005 == 77 && ebx_168->b000B == 0x48)))
					{
						<anonymous> * eax_178 = eax_151[edi_157];
						ptr32 esp_199;
						word32 ebp_200;
						struct Eq_2066 * eax_201;
						word32 edx_202;
						byte SCZO_203;
						byte Z_204;
						byte SZO_205;
						byte C_206;
						word32 edi_207;
						word32 ecx_208;
						word32 ebx_209;
						byte S_210;
						byte bl_211;
						struct Eq_2077 * esi_212;
						eax_178();
						*(esp_199 - 0x04) = (struct Eq_2077 **) esi_212;
						fn00401892(eax_201, dwArg00);
						if (esi_212->dw0000 == ebx_209 || (esi_212->dw0010 == ebx_209 || (esi_212->dw0008 == ebx_209 || (esi_212->dw000C == ebx_209 || (esi_212->dw0004 == ebx_209 || esi_212->dw0014 == ebx_209)))))
							break;
						eax_106 = 0x01;
						return eax_106;
					}
				}
				edi_157 = edi_157 + 0x01;
			} while (eax_151[edi_157] != 0x00);
		}
l00401800:
		eax_106 = 0x00;
		return eax_106;
	}
	else
		return 0x00;
}

// 0040186E: void fn0040186E(Register (ptr Eq_2114) eax)
void fn0040186E(Eq_2114 * eax)
{
	eax->b0003 = 0x61;
	eax->b0005 = 101;
	eax->b0000 = 0x43;
	eax->b0001 = 114;
	eax->b0004 = 116;
	eax->b0006 = 0x52;
	eax->b0007 = 111;
	eax->b0008 = 0x02;
	eax->b0002 = 101;
}

// 00401892: void fn00401892(Register (ptr Eq_2066) edi, Stack (ptr Eq_2086) dwArg04)
void fn00401892(Eq_2066 * edi, Eq_2086 * dwArg04)
{
	word32 ecx_11 = Mem0[Mem0[edi + 0x3C:word32] + 0x78 + edi:word32] + edi;
	uint32 eax_25 = ecx_11->dw0014;
	uint32 edx_13 = ecx_11->dw0018;
	word16 eax_19[] = edi + ecx_11->dw0024 / 0x0040;
	word32 esi_26[] = edi + ecx_11->dw001C / 0x0040;
	word32 ebx_27[] = edi + ecx_11->dw0020 / 0x0040;
	uint32 dwLoc10_203 = eax_25;
	if (eax_25 <= edx_13)
		dwLoc10_203 = edx_13;
	uint32 eax_100 = 0x00;
	uint32 dwLoc08_108 = 0x00;
	uint32 dwLoc0C_37 = 0x00;
	if (dwLoc10_203 > 0x00)
	{
		while (dwLoc08_108 < 0x06)
		{
			uint32 edx_72 = (word32) eax_19[eax_100];
			if (eax_100 >= ecx_11->dw0018 || edx_72 >= ecx_11->dw0014)
				return;
			struct Eq_2208 * eax_80 = edi + ebx_27[eax_100] / 0x0040;
			byte bl_81 = eax_80->b0000;
			word32 esi_83 = edi + esi_26[edx_72] / 0x0040;
			if (bl_81 == 0x47)
			{
				byte dl_173 = eax_80->b0001;
				if (dl_173 != 101)
					goto l00401979;
				if (eax_80->b0002 == 116 && (eax_80->b0003 == 77 && eax_80->b000F == 0x41))
				{
					dwArg04->dw0000 = esi_83;
					goto l00401A1D;
				}
				if (dl_173 != 101 || (eax_80->b0002 != 116 || (eax_80->b0003 != 0x54 || (eax_80->b0004 != 0x69 || (eax_80->b0005 != 99 || (eax_80->b0007 != 0x43 || (eax_80->b000B != 116 || eax_80->b000C != 0x00)))))))
					goto l00401979;
				dwArg04->dw0014 = esi_83;
				goto l00401A1D;
			}
l00401979:
			if (bl_81 == 0x56)
			{
				byte dl_132 = eax_80->b0001;
				if (dl_132 != 0x69)
					goto l004019F4;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x41 && (eax_80->b0008 == eax_80->b0009 && eax_80->b000C == 0x00)))
				{
					dwArg04->dw0008 = esi_83;
					goto l00401A1D;
				}
				if (dl_132 != 0x69)
					goto l004019F4;
				if (eax_80->b0002 == 114 && (eax_80->b0007 == 0x50 && (eax_80->b0008 == 114 && eax_80->b000E == 0x00)))
				{
					dwArg04->dw0004 = esi_83;
					goto l00401A1D;
				}
				if (dl_132 != 0x69 || (eax_80->b0002 != 114 || (eax_80->b0007 != 0x46 || (eax_80->b0009 != eax_80->b000A || eax_80->b000B != 0x00))))
					goto l004019F4;
				dwArg04->dw000C = esi_83;
				goto l00401A1D;
			}
l004019F4:
			if (eax_80->b0000 == 0x4C && (eax_80->b0001 == 111 && (eax_80->b0002 == 0x61 && (eax_80->b0003 == 100 && (eax_80->b0004 == 0x4C && eax_80->b000B == 0x41)))))
			{
				dwArg04->dw0010 = esi_83;
l00401A1D:
				dwLoc08_108 = dwLoc08_108 + 0x01;
			}
			uint32 v18_92 = dwLoc0C_37 + 0x01;
			dwLoc0C_37 = v18_92;
			if (v18_92 >= dwLoc10_203)
				return;
			eax_100 = v18_92;
		}
	}
}

// 00401A35: void fn00401A35(Register (ptr Eq_1883) eax, Register (ptr Eq_1854) esi, Stack ptr32 dwArg04)
void fn00401A35(Eq_1883 * eax, Eq_1854 * esi, ptr32 dwArg04)
{
	while (true)
	{
		ui32 ecx_6 = eax->dw0004;
		if ((ecx_6 & 0x80000000) == 0x00)
			break;
		eax = (struct Eq_1883 *) (esi + ((ecx_6 & 0x7FFFFFFF) + 0x10) / 0x0040);
	}
	word32 * eax_14 = esi + ecx_6 / 0x0040;
	*eax_14 = *eax_14 + dwArg04;
}

// 00401A5A: void fn00401A5A(Register Eq_46 eax, Register (ptr Eq_881) ecx, Stack Eq_46 dwArg04)
void fn00401A5A(Eq_46 eax, Eq_881 * ecx, Eq_46 dwArg04)
{
	while (dwArg04 != 0x00)
	{
		*eax = ecx->b0000;
		dwArg04 = dwArg04 - 0x01;
		eax = (word32) eax + 0x01;
		ecx = ecx + 0x01;
	}
}

// 00401A70: Register Eq_462 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_911 * ebp_10 = fn0040267C(ebx, esi, edi, dwLoc0C, 4207048, 0x010C);
	uint64 edx_eax_14 = (uint64) (uint32) ebp_10->dw0010;
	*(fp - 0x0C) = 0x23;
	ptr32 esp_18 = fp - 0x08;
	if ((uint32) (edx_eax_14 % *(fp - 0x0C)) > 0x46)
	{
		*(fp - 0x0C) = 0x00;
		TlsGetValue(*(fp - 0x0C));
		*(fp - 0x10) = 0x6546;
		*(fp - 0x14) = 0x00;
		TlsSetValue(*(fp - 0x14), *(fp - 0x10));
		*(ebp_10 - 0x04) = 0x00;
		esp_18 = fp - 0x14;
		byte * ecx_2321 = globals->a403108;
		byte * edx_2322 = (byte *) 0x00100654;
		do
		{
			byte al_2326 = *ecx_2321;
			*edx_2322 = al_2326;
			ecx_2321 = ecx_2321 + 0x01;
			edx_2322 = edx_2322 + 0x01;
		} while (al_2326 != 0x00);
		globals->dw4050D8 = globals->dw4057FC + 100;
		globals->dw4060D8 = globals->dw4067FC + 100;
		*(ebp_10 - 0x04) = *(ebp_10 - 0x04) | ~0x00;
	}
	*(ebp_10 - 0xA8) = 0x00;
	*(ebp_10 - 0x28) = 0x00;
	word32 eax_35 = ebp_10->dw0008;
	if (eax_35 != 0x00 && (ebp_10->dw000C <= 0x03 && (ebp_10->dw0010 == 0x00 || ebp_10->dw0010 == 0x01)))
	{
		*(ebp_10 - 0xA8) = 0x01;
		*(ebp_10 - 0x28) = eax_35;
	}
	Eq_462 eax_1043;
	*(ebp_10 - 0x44) = 0x00;
	union Eq_46 * esp_45 = esp_18 - 0x04;
	*esp_45 = (union Eq_46 *) 0x17;
	union Eq_46 * esp_101 = (char *) esp_45 + 0x04;
	if ((uint32) ((uint64) (uint32) eax_35 % *esp_45) > 0x32)
	{
		Eq_46 eax_2228 = GetForegroundWindow();
		__wait();
		*(ebp_10 - 0x44) = (union Eq_46 *) eax_2228;
		*esp_45 = (union Eq_46 *) 0x00;
		Eq_2669 eax_2232 = GetModuleHandleA(*esp_45);
		__wait();
		esp_101 = esp_45;
		if (*(ebp_10 - 0x44) != 0x00 && eax_2232 != null)
		{
			*(esp_45 - 0x04) = 0x0A;
			word32 ecx_2244 = *(esp_45 - 0x04);
			esp_101 = esp_45;
			word32 * edi_2252 = ebp_10 - 0x0108;
			while (ecx_2244 != 0x00)
			{
				*edi_2252 = 0x00;
				edi_2252 = edi_2252 + 0x01;
				ecx_2244 = ecx_2244 - 0x01;
			}
			*(ebp_10 - 0x010C) = 0x0F;
			Eq_46 eax_2259 = GetActiveWindow();
			__wait();
			int32 esi_2261 = 0x00;
			do
			{
				*(ebp_10 - 0xF8) = esi_2261;
				*(ebp_10 - 0x0100) = ebp_10 - 0xE0;
				*(ebp_10 - 0x0104) = 0x14;
				*(ebp_10 - 0x0108) = (word32) (esi_2261 >= 0x02);
				union Eq_3718 * esp_2279 = esp_101 - 0x04;
				*esp_2279 = (union Eq_3718 *) (ebp_10 - 0x010C);
				*(esp_2279 - 0x04) = esi_2261;
				*(esp_2279 - 0x08) = 0x1019;
				*(esp_2279 - 0x0C) = (union Eq_46 *) eax_2259;
				Eq_3738 eax_2287 = SendMessageA(*(esp_2279 - 0x0C), *(esp_2279 - 0x08), *(esp_2279 - 0x04), *esp_2279);
				__wait();
				esp_101 = esp_2279 - 0x0C;
				if (eax_2287 == 0x00)
					goto l0040206C;
				esi_2261 = esi_2261 + 0x01;
			} while (esi_2261 < 11);
		}
	}
	else if (*(ebp_10 - 0x28) == 0x00)
		*(ebp_10 - 0x28) = 0x00400000;
	*(ebp_10 - 0x38) = 0x00;
	*(ebp_10 - 0x50) = 0x00;
	*(ebp_10 - 0xA4) = 0x00;
	*(ebp_10 - 0x40) = 0x00;
	*(ebp_10 - 0x9C) = 0x00;
	*(ebp_10 - 0x88) = 0x01;
	*(ebp_10 - 0x87) = 0x50;
	*(ebp_10 - 0x86) = 0x56;
	*(ebp_10 - 133) = 0x46;
	*(ebp_10 - 0x84) = 0x4E;
	*(ebp_10 - 131) = 0x4E;
	*(ebp_10 - 0x82) = 0x10;
	*(ebp_10 - 0x81) = 0x46;
	*(ebp_10 - 0x80) = 0x4E;
	*(ebp_10 - 0x7F) = 0x4E;
	*(ebp_10 - 0x7E) = 0x00;
	*(ebp_10 - 0x7C) = 0x01;
	*(ebp_10 - 0x7B) = 0x2E;
	*(ebp_10 - 122) = 0x46;
	*(ebp_10 - 121) = 0x54;
	*(ebp_10 - 0x78) = 0x28;
	*(ebp_10 - 0x77) = 0x4B;
	*(ebp_10 - 118) = 0x50;
	*(ebp_10 - 117) = 0x46;
	*(ebp_10 - 116) = 0x27;
	*(ebp_10 - 115) = 0x02;
	struct Eq_1976 * edx_129 = *(ebp_10 - 0x28);
	word32 edi_131 = edx_129 + edx_129->ptr003C / 0x0040;
	*(ebp_10 - 0x98) = edi_131;
	*(ebp_10 - 0x90) = 0x00;
	*(ebp_10 - 0x24) = 0x00;
	*(ebp_10 - 0xB4) = 0x00;
	*(ebp_10 - 0x8C) = 0x00;
	*(ebp_10 - 44) = 0x00;
	*(ebp_10 - 0xA0) = 0x00;
	*(ebp_10 - 0xB0) = 0x00;
	*(ebp_10 - 0x3C) = 106194171;
	word32 eax_143 = fn00401799(edx_129, ebp_10, ebp_10 - 0x68);
	__wait();
	if (eax_143 != 0x00)
	{
		ptr32 esp_184;
		word32 * esp_152 = esp_101 - 0x04;
		*esp_152 = 0x04;
		*(esp_152 - 0x04) = 0x3000;
		*(esp_152 - 0x08) = 0x07;
		*(esp_152 - 0x0C) = 0x00;
		ptr32 esp_160;
		word32 eax_161;
		word32 edx_163;
		byte SZO_164;
		byte C_165;
		word32 ecx_166;
		byte SCZO_167;
		Eq_46 ebx_168;
		byte CZ_169;
		byte al_170;
		byte bl_171;
		byte Z_172;
		word32 esi_174;
		byte SO_175;
		word16 ax_176;
		byte S_177;
		bcuiposr0 None_178;
		word16 si_179;
		struct Eq_3001 * ebp_162;
		struct Eq_3002 * edi_173;
		(*(ebp_10 - 0x60))();
		__wait();
		*(ebp_162 - 0xAC) = eax_161;
		if (*(ebp_162 - 0x44) != ebx_168)
		{
			*(esp_160 - 0x04) = 100;
			*(esp_160 - 0x08) = ebp_162->dw0008;
			Eq_3087 eax_2091 = LoadAcceleratorsA(*(esp_160 - 0x08), *(esp_160 - 0x04));
			__wait();
			*(ebp_162 - 0x34) = (HACCEL *) eax_2091;
			*(esp_160 - 0x0C) = (union Eq_46 *) ebx_168;
			*(esp_160 - 0x10) = ebp_162->dw0008;
			*(esp_160 - 0x14) = 0x1992;
			*(esp_160 - 0x18) = *(ebp_162 - 0x44);
			*(esp_160 - 0x1C) = 0x12;
			*(esp_160 - 0x20) = 0x20;
			*(esp_160 - 0x24) = 0x05;
			*(esp_160 - 0x28) = 0x0A;
			*(esp_160 - 44) = 0x50010000;
			*(esp_160 - 0x30) = 0x00403118;
			*(esp_160 - 0x34) = 0x0040311C;
			*(esp_160 - 0x38) = (union Eq_46 *) ebx_168;
			Eq_46 eax_2120 = CreateWindowExA(*(esp_160 - 0x38), *(esp_160 - 0x34), *(esp_160 - 0x30), *(esp_160 - 44), *(esp_160 - 0x28), *(esp_160 - 0x24), *(esp_160 - 0x20), *(esp_160 - 0x1C), *(esp_160 - 0x18), *(esp_160 - 0x14), *(esp_160 - 0x10), *(esp_160 - 0x0C));
			__wait();
			*(ebp_162 - 0x30) = (union Eq_46 *) eax_2120;
			*(esp_160 - 0x3C) = (union Eq_46 *) ebx_168;
			*(esp_160 - 0x40) = ebp_162->dw0008;
			*(esp_160 - 0x44) = 0x0363;
			*(esp_160 - 0x48) = *(ebp_162 - 0x44);
			*(esp_160 - 0x4C) = 100;
			*(esp_160 - 0x50) = 100;
			*(esp_160 - 0x54) = 0x05;
			*(esp_160 - 88) = 0x32;
			*(esp_160 - 0x5C) = 0x50010000;
			*(esp_160 - 0x60) = 0x00403124;
			*(esp_160 - 100) = 0x00403134;
			*(esp_160 - 0x68) = (union Eq_46 *) ebx_168;
			Eq_46 eax_2148 = CreateWindowExA(*(esp_160 - 0x68), *(esp_160 - 100), *(esp_160 - 0x60), *(esp_160 - 0x5C), *(esp_160 - 88), *(esp_160 - 0x54), *(esp_160 - 0x50), *(esp_160 - 0x4C), *(esp_160 - 0x48), *(esp_160 - 0x44), *(esp_160 - 0x40), *(esp_160 - 0x3C));
			__wait();
			esp_184 = esp_160 - 0x68;
			if (*(ebp_162 - 0x30) != ebx_168 && eax_2148 != ebx_168)
			{
				*(esp_160 - 0x6C) = (union Eq_46 *) ebx_168;
				*(esp_160 - 0x70) = (union Eq_46 *) eax_2148;
				ShowWindow(*(esp_160 - 0x70), *(esp_160 - 0x6C));
				__wait();
				*(esp_160 - 116) = 0x0040313C;
				*(esp_160 - 0x78) = *(ebp_162 - 0x30);
				SetWindowTextA(*(esp_160 - 0x78), *(esp_160 - 116));
				__wait();
				ptr32 esp_2164 = esp_160 - 0x78;
				while (true)
				{
					union Eq_46 * esp_2169 = esp_2164 - 0x04;
					*esp_2169 = (union Eq_46 *) ebx_168;
					*(esp_2169 - 0x04) = (union Eq_46 *) ebx_168;
					*(esp_2169 - 0x08) = (union Eq_46 *) ebx_168;
					*(esp_2169 - 0x0C) = ebp_162 - 220;
					Eq_118 eax_2178 = GetMessageA(*(esp_2169 - 0x0C), *(esp_2169 - 0x08), *(esp_2169 - 0x04), *esp_2169);
					__wait();
					esp_184 = esp_2169 - 0x0C;
					if (eax_2178 == 0x00)
						break;
					*(esp_2169 - 0x10) = ebp_162 - 220;
					*(esp_2169 - 0x14) = *(ebp_162 - 0x34);
					*(esp_2169 - 0x18) = *(ebp_162 - 220);
					int32 eax_2191 = TranslateAcceleratorA(*(esp_2169 - 0x18), *(esp_2169 - 0x14), *(esp_2169 - 0x10));
					__wait();
					esp_2164 = esp_2169 - 0x18;
					if (eax_2191 == 0x00)
					{
						*(esp_2169 - 0x1C) = ebp_162 - 220;
						TranslateMessage(*(esp_2169 - 0x1C));
						__wait();
						esp_2164 = esp_2169 - 0x1C;
					}
				}
				fn0040138A();
				__wait();
			}
		}
		else
		{
			*(esp_160 - 0x04) = 0x04;
			*(esp_160 - 0x08) = 0x1000;
			*(esp_160 - 0x0C) = 0x0A;
			*(esp_160 - 0x10) = (union Eq_46 *) ebx_168;
			word32 eax_2208;
			word32 edx_2210;
			byte SZO_2211;
			byte C_2212;
			word32 ecx_2213;
			byte SCZO_2214;
			word32 ebx_2215;
			byte CZ_2216;
			byte al_2217;
			byte bl_2218;
			byte Z_2219;
			word32 esi_2221;
			byte SO_2222;
			word16 ax_2223;
			byte S_2224;
			bcuiposr0 None_2225;
			word16 si_2226;
			(*(ebp_162 - 0x60))();
			__wait();
			*(ebp_162 - 44) = eax_2208;
		}
		*(ebp_162 - 0xB8) = edi_173->dw0050;
		word32 eax_190 = fn00401367(ebp_162 - 0x88);
		word32 * esp_191 = esp_184 - 0x04;
		*esp_191 = eax_190;
		ptr32 esp_193;
		word32 eax_194;
		ptr32 ebp_195;
		word32 edx_196;
		byte SZO_197;
		byte C_198;
		word32 ecx_199;
		byte SCZO_200;
		word32 ebx_201;
		byte CZ_202;
		byte al_203;
		byte bl_204;
		byte Z_205;
		word32 edi_206;
		word32 esi_207;
		byte SO_208;
		word16 ax_209;
		byte S_210;
		bcuiposr0 None_211;
		word16 si_212;
		(*(ebp_162 - 0x68))();
		__wait();
		*(ebp_195 - 0xC0) = eax_194;
		fn00401767(ebp_195 - 0x68);
		__wait();
		*(ebp_195 - 0x30) = ebp_195 - 0x68;
		*(esp_193 - 0x04) = ebp_195 - 0x68;
		ptr32 esp_218;
		word32 eax_219;
		ptr32 ebp_220;
		word32 edx_221;
		byte SZO_222;
		byte C_223;
		word32 ecx_224;
		byte SCZO_225;
		word32 ebx_226;
		byte CZ_227;
		byte al_228;
		byte bl_229;
		byte Z_230;
		word32 edi_231;
		word32 esi_232;
		byte SO_233;
		word16 ax_234;
		byte S_235;
		bcuiposr0 None_236;
		word16 si_237;
		(*(ebp_195 - 88))();
		__wait();
		*(ebp_220 - 0x20) = eax_219;
		*(esp_218 - 0x04) = 0x8000;
		*(esp_218 - 0x08) = ebx_226;
		*(esp_218 - 0x0C) = *(ebp_220 - 0x30);
		ptr32 esp_247;
		word32 eax_248;
		word32 edx_250;
		byte SZO_251;
		byte C_252;
		word32 ecx_253;
		byte SCZO_254;
		uint32 ebx_255;
		byte CZ_256;
		byte al_257;
		byte bl_258;
		byte Z_259;
		ptr32 edi_260;
		word32 esi_261;
		byte SO_262;
		word16 ax_263;
		byte S_264;
		bcuiposr0 None_265;
		word16 si_266;
		(*(ebp_220 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x20) == ebx_255)
			goto l0040206C;
		uint32 eax_269 = *(edi_260 - 0x08);
		*(ebp_10 - 0x6C) = eax_269;
		if (eax_269 <= ebx_255)
			goto l0040206C;
		struct Eq_2114 * eax_273 = *(ebp_10 - 44);
		fn0040186E(eax_273);
		*(esp_247 - 0x04) = ebp_10 - 0x68;
		*(esp_247 - 0x08) = (struct Eq_2114 **) eax_273;
		*(esp_247 - 0x0C) = *(ebp_10 - 0x20);
		Eq_46 eax_282 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
		__wait();
		*(ebp_10 - 0x34) = (union Eq_46 *) eax_282;
		*(esp_247 - 0x04) = esi_261;
		*(esp_247 - 0x08) = ebx_255;
		*(esp_247 - 0x0C) = *(ebp_10 - 44);
		ptr32 esp_292;
		word32 eax_293;
		word32 edx_295;
		byte SZO_296;
		byte C_297;
		word32 ecx_298;
		byte SCZO_299;
		word32 ebx_300;
		byte CZ_301;
		byte al_302;
		byte bl_303;
		byte Z_304;
		struct Eq_3932 * edi_305;
		word32 esi_306;
		byte SO_307;
		word16 ax_308;
		byte S_309;
		bcuiposr0 None_310;
		word16 si_311;
		(*(ebp_10 - 0x5C))();
		__wait();
		if (*(ebp_10 - 0x34) != ebx_300)
		{
			word32 edi_315 = edi_305->dw0088 + *(ebp_10 - 0x28);
			if (edi_315 == *(ebp_10 - 0x28))
			{
				eax_1043 = 0x01;
				goto l0040206E;
			}
			fn00401639(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 0x30) = ebp_10 - 0x68;
			*(esp_292 - 0x04) = ebp_10 - 0x68;
			*(esp_292 - 0x08) = ebp_10 - 0x68;
			*(esp_292 - 0x0C) = *(ebp_10 - 0x20);
			Eq_46 eax_335 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 44) = (union Eq_46 *) eax_335;
			*(esp_292 - 0x04) = esi_306;
			*(esp_292 - 0x08) = ebx_300;
			*(esp_292 - 0x0C) = *(ebp_10 - 0x30);
			ptr32 esp_345;
			word32 eax_346;
			word32 edx_348;
			byte SZO_349;
			byte C_350;
			word32 ecx_351;
			byte SCZO_352;
			byte CZ_354;
			byte al_355;
			byte bl_356;
			byte Z_357;
			word32 edi_358;
			word32 esi_359;
			byte SO_360;
			word16 ax_361;
			byte S_362;
			bcuiposr0 None_363;
			word16 si_364;
			Eq_46 ebx_1886;
			(*(ebp_10 - 0x5C))();
			__wait();
			if (*(ebp_10 - 44) == ebx_1886)
				goto l0040206C;
			uint64 edx_eax_369 = (uint64) (uint32) ebp_10->dw0008;
			*(esp_345 - 0x04) = 0x1B;
			uint32 edx_375 = (uint32) (edx_eax_369 % *(esp_345 - 0x04));
			*(ebp_10 - 0x94) = edx_375;
			ptr32 esp_2047 = esp_345;
			if (edx_375 > 0x32)
			{
				*(esp_345 - 0x04) = ebp_10 - 220;
				*(esp_345 - 0x08) = (union Eq_46 *) ebx_1886;
				*(esp_345 - 0x0C) = 6637399;
				Eq_118 eax_2041 = GetScrollInfo(*(esp_345 - 0x0C), *(esp_345 - 0x08), *(esp_345 - 0x04));
				__wait();
				if (eax_2041 != 0x00)
				{
					*(ebp_10 - 200) = *(ebp_10 - 200) + 0x14;
					*(esp_345 - 0x10) = 0x01;
					*(esp_345 - 0x14) = ebp_10 - 220;
					*(esp_345 - 0x18) = (union Eq_46 *) ebx_1886;
					*(esp_345 - 0x1C) = 0x06547547;
					SetScrollInfo(*(esp_345 - 0x1C), *(esp_345 - 0x18), *(esp_345 - 0x14), *(esp_345 - 0x10));
					esp_2047 = esp_345 - 0x1C;
				}
				else
				{
					*(esp_345 - 0x10) = 0x20;
					*(esp_345 - 0x14) = 0x2000;
					*(esp_345 - 0x18) = 0x0A;
					*(esp_345 - 0x1C) = (union Eq_46 *) ebx_1886;
					Eq_46 eax_2073 = VirtualAlloc(*(esp_345 - 0x1C), *(esp_345 - 0x18), *(esp_345 - 0x14), *(esp_345 - 0x10));
					__wait();
					esp_2047 = esp_345 - 0x1C;
					if (eax_2073 == ebx_1886)
						goto l00401ECE;
					*(esp_345 - 0x20) = esi_359;
					*(esp_345 - 0x24) = (union Eq_46 *) ebx_1886;
					*(esp_345 - 0x28) = (union Eq_46 *) eax_2073;
					VirtualFree(*(esp_345 - 0x28), *(esp_345 - 0x24), *(esp_345 - 0x20));
					esp_2047 = esp_345 - 0x28;
				}
				__wait();
			}
l00401ECE:
			fn004016C9(ebp_10 - 0x68);
			__wait();
			*(ebp_10 - 188) = ebp_10 - 0x68;
			union Eq_46 * esp_389 = esp_2047 - 0x04;
			*esp_389 = (union Eq_46 *) (ebp_10 - 0x68);
			*(esp_389 - 0x04) = ebp_10 - 0x68;
			*(esp_389 - 0x08) = *(ebp_10 - 0x20);
			Eq_46 eax_396 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x30) = (union Eq_46 *) eax_396;
			if (eax_396 == ebx_1886)
				goto l0040206C;
			union Eq_46 * esp_1836;
			*(ebp_10 - 0x48) = edi_358 + 0x10;
			*(ebp_10 - 0x4C) = (union Eq_46 *) ebx_1886;
			uint64 edx_eax_406 = (uint64) (uint32) ebp_10->dw0008;
			*esp_389 = (union Eq_46 *) 0x41;
			if ((uint32) (edx_eax_406 % *esp_389) > 0x4E)
			{
				*esp_389 = *(ebp_10 - 0x44);
				Eq_46 eax_1838 = GetMenu(*esp_389);
				__wait();
				esp_1836 = esp_389;
				if (eax_1838 != ebx_1886)
				{
					*(esp_389 - 0x04) = 0x0040314C;
					*(esp_389 - 0x08) = (union Eq_46 *) ebx_1886;
					*(esp_389 - 0x0C) = 0x0400;
					*(esp_389 - 0x10) = (union Eq_46 *) ebx_1886;
					*(esp_389 - 0x14) = (union Eq_46 *) eax_1838;
					ModifyMenuA(*(esp_389 - 0x14), *(esp_389 - 0x10), *(esp_389 - 0x0C), *(esp_389 - 0x08), *(esp_389 - 0x04));
					__wait();
					esp_1836 = esp_389 - 0x14;
				}
			}
			else
			{
				uint64 edx_eax_1857 = (uint64) (uint32) ebp_10->dw0008;
				*esp_389 = (union Eq_46 *) 0x14;
				Eq_46 ecx_1860 = *esp_389;
				esp_1836 = (union Eq_46 *) ((char *) esp_389 + 0x04);
				uint32 edx_1863 = (uint32) (edx_eax_1857 % ecx_1860);
				if (edx_1863 <= 0x32)
				{
					*esp_389 = (union Eq_46 *) 0x04;
					*(esp_389 - 0x04) = 0x2000;
					*(esp_389 - 0x08) = 0x0A;
					*(esp_389 - 0x0C) = (union Eq_46 *) ebx_1886;
					Eq_46 eax_1879;
					word32 edx_1881;
					byte SZO_1882;
					byte C_1883;
					word32 ecx_1884;
					byte SCZO_1885;
					byte CZ_1887;
					byte al_1888;
					byte bl_1889;
					byte Z_1890;
					word32 edi_1891;
					word32 esi_1892;
					byte SO_1893;
					word16 ax_1894;
					byte S_1895;
					bcuiposr0 None_1896;
					word16 si_1897;
					(*(ebp_10 - 0x60))();
					__wait();
					*(ebp_10 - 0x24) = (union Eq_46 *) eax_1879;
					if (eax_1879 != ebx_1886)
					{
						*(esp_1836 - 0x04) = 0x96;
						*(esp_1836 - 0x08) = 0x23;
						*(esp_1836 - 0x0C) = 0x41;
						*(esp_1836 - 0x10) = 0x3C;
						*(esp_1836 - 0x14) = 0x19;
						*(esp_1836 - 0x18) = 0x0F;
						ptr32 esp_1985;
						word32 eax_1986;
						ptr32 ebp_1987;
						word32 edx_1988;
						byte SZO_1989;
						byte C_1990;
						word32 ecx_1991;
						byte SCZO_1992;
						word32 ebx_1993;
						byte CZ_1994;
						byte al_1995;
						byte bl_1996;
						byte Z_1997;
						word32 edi_1998;
						word32 esi_1999;
						byte SO_2000;
						word16 ax_2001;
						byte S_2002;
						bcuiposr0 None_2003;
						word16 si_2004;
						(*(ebp_10 - 0x34))();
						__wait();
						*(ebp_1987 - 0x3C) = eax_1986;
						*(esp_1985 - 0x04) = esi_1999;
						*(esp_1985 - 0x08) = ebx_1993;
						*(esp_1985 - 0x0C) = *(ebp_1987 - 0x24);
						word32 eax_2014;
						word32 edx_2016;
						byte SZO_2017;
						byte C_2018;
						word32 ecx_2019;
						byte SCZO_2020;
						byte CZ_2022;
						byte al_2023;
						byte bl_2024;
						byte Z_2025;
						word32 edi_2026;
						word32 esi_2027;
						byte SO_2028;
						word16 ax_2029;
						byte S_2030;
						bcuiposr0 None_2031;
						word16 si_2032;
						(*(ebp_1987 - 0x5C))();
						__wait();
						*(ebp_10 - 0x24) = (union Eq_46 *) ebx_1886;
					}
					if (*(ebp_10 - 0x24) == ebx_1886 && *(ebp_10 - 0x3C) != ebx_1886)
					{
						word32 * esp_1944 = esp_1836 - 0x04;
						*esp_1944 = 0x1D;
						*(esp_1944 - 0x04) = 0x1E;
						*(esp_1944 - 0x08) = 0x07;
						*(esp_1944 - 0x0C) = 0x05;
						word32 eax_1953;
						word32 edx_1955;
						byte SZO_1956;
						byte C_1957;
						word32 ecx_1958;
						byte SCZO_1959;
						byte CZ_1961;
						byte al_1962;
						byte bl_1963;
						byte Z_1964;
						word32 edi_1965;
						word32 esi_1966;
						byte SO_1967;
						word16 ax_1968;
						byte S_1969;
						bcuiposr0 None_1970;
						word16 si_1971;
						(*(ebp_10 - 0x30))();
						__wait();
						*(ebp_10 - 0x8C) = eax_1953;
					}
					*(ebp_10 - 0x24) = 0x2D;
				}
			}
			struct Eq_1904 * eax_430 = *(ebp_10 - 0xAC);
			fn0040174B(eax_430);
			ptr32 ecx_431 = ebp_10 - 0x68;
			ptr32 * esp_432 = esp_1836 - 0x04;
			*esp_432 = ecx_431;
			*(esp_432 - 0x04) = (struct Eq_1904 **) eax_430;
			*(esp_432 - 0x08) = *(ebp_10 - 0x20);
			Eq_46 eax_439 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
			__wait();
			*(ebp_10 - 0x20) = (union Eq_46 *) eax_439;
			if (eax_439 != ebx_1886)
			{
				*esp_432 = 0x04;
				*(esp_432 - 0x04) = 0x3000;
				*(esp_432 - 0x08) = 100;
				*(esp_432 - 0x0C) = (union Eq_46 *) ebx_1886;
				ptr32 esp_455;
				word32 eax_456;
				ptr32 ebp_457;
				word32 edx_458;
				byte SZO_459;
				byte C_460;
				word32 ecx_461;
				byte SCZO_462;
				word32 ebx_463;
				byte CZ_464;
				byte al_465;
				byte bl_466;
				byte Z_467;
				word32 edi_468;
				word32 esi_469;
				byte SO_470;
				word16 ax_471;
				byte S_472;
				bcuiposr0 None_473;
				word16 si_474;
				(*(ebp_10 - 0x60))();
				__wait();
				*(ebp_457 - 0x70) = eax_456;
				*(esp_455 - 0x04) = ebx_463;
				*(esp_455 - 0x08) = 0x0A;
				*(esp_455 - 0x0C) = *(ebp_457 - 0x3C);
				ptr32 esp_483;
				word32 eax_484;
				ptr32 ebp_485;
				word32 edx_486;
				byte SZO_487;
				byte C_488;
				word32 ecx_489;
				byte SCZO_490;
				word32 ebx_491;
				byte CZ_492;
				byte al_493;
				byte bl_494;
				byte Z_495;
				word32 edi_496;
				word32 esi_497;
				byte SO_498;
				word16 ax_499;
				byte S_500;
				bcuiposr0 None_501;
				word16 si_502;
				(*(ebp_457 - 0x20))();
				__wait();
				*(ebp_485 - 0x3C) = eax_484;
				*(esp_483 - 0x04) = esi_497;
				*(esp_483 - 0x08) = ebx_491;
				*(esp_483 - 0x0C) = *(ebp_485 - 0x70);
				ptr32 esp_511;
				word32 eax_512;
				word32 edx_514;
				byte SZO_515;
				byte C_516;
				word32 ecx_517;
				byte SCZO_518;
				word32 ebx_519;
				byte CZ_520;
				byte al_521;
				byte bl_522;
				byte Z_523;
				word32 edi_524;
				word32 esi_525;
				byte SO_526;
				word16 ax_527;
				byte S_528;
				bcuiposr0 None_529;
				word16 si_530;
				(*(ebp_485 - 0x5C))();
				__wait();
				if (*(ebp_10 - 0x3C) == 400)
				{
					*(esp_511 - 0x04) = 0x0F;
					*(esp_511 - 0x08) = 0x0F;
					*(esp_511 - 0x0C) = 0x3C;
					*(esp_511 - 0x10) = 0x32;
					*(esp_511 - 0x14) = 0x14;
					*(esp_511 - 0x18) = 0x14;
					Eq_46 eax_611;
					word32 edx_613;
					byte SZO_614;
					byte C_615;
					word32 ecx_616;
					byte SCZO_617;
					byte CZ_619;
					byte al_620;
					byte bl_621;
					byte Z_622;
					word32 esi_624;
					byte SO_625;
					word16 ax_626;
					byte S_627;
					bcuiposr0 None_628;
					word16 si_629;
					Eq_46 ebx_1398;
					struct Eq_4911 * edi_1538;
					ptr32 esp_1481;
					(*(ebp_10 - 0x34))();
					__wait();
					*(ebp_10 - 0x70) = (union Eq_46 *) eax_611;
					if (eax_611 == ebx_1398 || *(ebp_10 - 0x8C) == ebx_1398)
						goto l0040206C;
					if (0x00 < edi_1538->w000E)
					{
						do
						{
							if (**(ebp_10 - 0x48) == 0x17)
							{
								uint64 edx_eax_1570 = (uint64) (uint32) ebp_10->dw0008;
								union Eq_46 * esp_1571 = esp_1481 - 0x04;
								*esp_1571 = (union Eq_46 *) 0x4C;
								Eq_46 ecx_1573 = *esp_1571;
								uint32 edx_1576 = (uint32) (edx_eax_1570 % ecx_1573);
								if (edx_1576 > 100)
								{
									*esp_1571 = (union Eq_46 *) 0x00654674;
									Eq_46 eax_1738 = GetMenu(*esp_1571);
									__wait();
									union Eq_46 * esp_1736 = esp_1571;
									if (eax_1738 != ebx_1398)
									{
										*(esp_1571 - 0x04) = (union Eq_46 *) ebx_1398;
										*(esp_1571 - 0x08) = 0x05;
										*(esp_1571 - 0x0C) = 0x0400;
										*(esp_1571 - 0x10) = 0x05;
										*(esp_1571 - 0x14) = (union Eq_46 *) eax_1738;
										Eq_118 eax_1790 = ModifyMenuA(*(esp_1571 - 0x14), *(esp_1571 - 0x10), *(esp_1571 - 0x0C), *(esp_1571 - 0x08), *(esp_1571 - 0x04));
										__wait();
										esp_1736 = esp_1571 - 0x14;
										if (eax_1790 == 0x00)
											goto l004020FD;
										*(esp_1571 - 0x18) = (union Eq_46 *) ebx_1398;
										*(esp_1571 - 0x1C) = 0x01;
										*(esp_1571 - 0x20) = 0x0001000B;
										*(esp_1571 - 0x24) = 0x00654674;
										SendMessageA(*(esp_1571 - 0x24), *(esp_1571 - 0x20), *(esp_1571 - 0x1C), *(esp_1571 - 0x18));
										esp_1481 = esp_1571 - 0x24;
										goto l0040212F;
									}
l004020FD:
									LPRECT * esp_1755 = esp_1736 - 0x04;
									*esp_1755 = (LPRECT *) (ebp_10 - 0xD0);
									*(esp_1755 - 0x04) = 0x00654674;
									Eq_118 eax_1759 = GetWindowRect(*(esp_1755 - 0x04), *esp_1755);
									__wait();
									esp_1481 = esp_1755 - 0x04;
									if (eax_1759 != 0x00)
									{
										*(ebp_10 - 200) = *(ebp_10 - 200) + 0x0A;
										*(esp_1755 - 0x08) = 0x01;
										*(esp_1755 - 0x0C) = ebp_10 - 0xD0;
										*(esp_1755 - 0x10) = 0x00654674;
										InvalidateRect(*(esp_1755 - 0x10), *(esp_1755 - 0x0C), *(esp_1755 - 0x08));
										esp_1481 = esp_1755 - 0x10;
l0040212F:
										__wait();
									}
								}
								else
								{
									*esp_1571 = (union Eq_46 *) 0x15;
									*(esp_1571 - 0x04) = 0x14;
									*(esp_1571 - 0x08) = 0x10;
									*(esp_1571 - 0x0C) = 0x0F;
									word32 eax_1815;
									word32 edx_1817;
									byte SZO_1818;
									byte C_1819;
									word32 ecx_1820;
									byte SCZO_1821;
									byte CZ_1823;
									byte al_1824;
									byte bl_1825;
									byte Z_1826;
									word32 esi_1828;
									byte SO_1829;
									word16 ax_1830;
									byte S_1831;
									bcuiposr0 None_1832;
									word16 si_1833;
									(*(ebp_10 - 0x30))();
									__wait();
									*(ebp_10 - 0x90) = eax_1815;
								}
								if (*(ebp_10 - 0x90) == ebx_1398)
									goto l0040206C;
								if (*(ebp_10 - 0xB0) == ebx_1398)
								{
									union Eq_46 * esp_1705 = esp_1481 - 0x04;
									*esp_1705 = (union Eq_46 *) ebx_1398;
									*(esp_1705 - 0x04) = (union Eq_46 *) ebx_1398;
									*(esp_1705 - 0x08) = *(ebp_10 - 0x70);
									word32 eax_1713;
									word32 edx_1715;
									byte SZO_1716;
									byte C_1717;
									word32 ecx_1718;
									byte SCZO_1719;
									byte CZ_1721;
									byte al_1722;
									byte bl_1723;
									byte Z_1724;
									word32 esi_1726;
									byte SO_1727;
									word16 ax_1728;
									byte S_1729;
									bcuiposr0 None_1730;
									word16 si_1731;
									(*(ebp_10 - 0x20))();
									__wait();
									*(ebp_10 - 0xA0) = eax_1713;
									*(ebp_10 - 44) = *(ebp_10 - 44) - eax_1713;
								}
								word32 eax_1622 = (Mem1572[Mem1572[ebp_10 - 0x48 + 0x00:word32] + 0x04:word32] & 0x7FFFFFFF) + edi_1538;
								*(ebp_10 - 0xB0) = 0x01;
								*(ebp_10 - 0x34) = (union Eq_46 *) ebx_1398;
								struct Eq_5590 * ecx_1623 = (char *) (&eax_1622->w000E + 0x01) + 0x04;
								Eq_46 eax_1628 = (word32) eax_1622->w000C + (word32) eax_1622->w000E;
								if (eax_1628 > ebx_1398)
								{
									do
									{
										*(ebp_10 - 0x3C) = (union Eq_46 *) ebx_1398;
										Eq_5729 edx_1639 = ecx_1623->dw0000;
										if (edx_1639 >= 0x00)
										{
											if (edx_1639 > 1500)
												goto l004021AF;
											*(ebp_10 - 0x3C) = 0x01;
										}
										if (*(ebp_10 - 0x3C) != ebx_1398)
										{
											word32 eax_1657 = Mem1638[(Mem1638[ecx_1623 + 0x00:word32] & 0x7FFFFFFF) + 0x14 + edi_1538:word32] + edi_1538;
											*(ebp_10 - 0x24) = *(ebp_10 - 0x24) + *(ebp_10 - 0xA0);
											word32 ecx_1662 = eax_1657->dw0000;
											*(ebp_10 - 0xA4) = ecx_1662;
											*(ebp_10 - 0x40) = eax_1657->dw0004;
											word32 eax_1666 = (word32) edi_1538->w000E;
											*(ebp_10 - 0x4C) = eax_1666;
											word32 * esp_1668 = esp_1481 - 0x04;
											*esp_1668 = 0x04;
											*(esp_1668 - 0x04) = 0x03;
											*(esp_1668 - 0x08) = 0x02;
											*(esp_1668 - 0x0C) = 0x01;
											Eq_46 eax_1677;
											word32 edx_1679;
											byte SZO_1680;
											byte C_1681;
											word32 ecx_1682;
											byte SCZO_1683;
											byte CZ_1685;
											byte al_1686;
											byte bl_1687;
											byte Z_1688;
											word32 esi_1690;
											byte SO_1691;
											word16 ax_1692;
											byte S_1693;
											bcuiposr0 None_1694;
											word16 si_1695;
											(*(ebp_10 - 0x30))();
											__wait();
											*(ebp_10 - 0xB4) = (union Eq_46 *) eax_1677;
											if (eax_1677 == ebx_1398)
												goto l0040206C;
											*(ebp_10 - 44) = *(ebp_10 - 44) + 0xB0;
											break;
										}
l004021AF:
										*(ebp_10 - 0x34) = *(ebp_10 - 0x34) + 0x01;
										ecx_1623 = ecx_1623 + 0x01;
									} while (*(ebp_10 - 0x34) < eax_1628);
								}
							}
							*(ebp_10 - 0x48) = *(ebp_10 - 0x48) + 0x08;
							*(ebp_10 - 0x4C) = *(ebp_10 - 0x4C) + 0x01;
						} while (*(ebp_10 - 0x4C) < (word32) edi_1538->w000E);
					}
					word32 edi_655 = *(ebp_10 - 0xA4);
					word32 esi_1519 = edi_655;
					if (*(ebp_10 - 0x94) > 0x36)
					{
						Eq_46 eax_1508 = GetActiveWindow();
						__wait();
						if (eax_1508 != ebx_1398)
						{
							int32 * esp_1514 = esp_1481 - 0x04;
							*esp_1514 = 0x03;
							*(esp_1514 - 0x04) = (union Eq_46 *) eax_1508;
							ShowWindow(*(esp_1514 - 0x04), *esp_1514);
							__wait();
							esp_1481 = esp_1514 - 0x04;
						}
					}
					else
						esi_1519 = edi_655 + 0x01;
					if (esi_1519 == 0x01)
					{
						union Eq_46 * esp_1460 = esp_1481 - 0x04;
						*esp_1460 = (union Eq_46 *) ebx_1398;
						Eq_2669 eax_1462 = GetModuleHandleA(*esp_1460);
						__wait();
						*(esp_1460 - 0x04) = (HMODULE *) eax_1462;
						CloseHandle(*(esp_1460 - 0x04));
						__wait();
						uint64 edx_eax_1468 = (uint64) (uint32) ebp_10->dw0008;
						*(esp_1460 - 0x08) = 0x0A;
						if ((uint32) (edx_eax_1468 % *(esp_1460 - 0x08)) == 0x14)
						{
							*(esp_1460 - 0x08) = esi_1519;
							*(esp_1460 - 0x0C) = 0x54;
							TerminateThread(*(esp_1460 - 0x0C), *(esp_1460 - 0x08));
						}
						else
						{
							uint64 edx_eax_1492 = (uint64) (uint32) ebp_10->dw0008;
							*(esp_1460 - 0x08) = 0x0F;
							if ((uint32) (edx_eax_1492 % *(esp_1460 - 0x08)) != 0x10)
								goto l0040206C;
							Eq_46 eax_1502 = GetCurrentProcess();
							__wait();
							*(esp_1460 - 0x08) = (union Eq_46 *) ebx_1398;
							*(esp_1460 - 0x0C) = (union Eq_46 *) eax_1502;
							TerminateProcess(*(esp_1460 - 0x0C), *(esp_1460 - 0x08));
						}
						__wait();
						esp_1481 = esp_1481 - 0x10;
					}
					*(ebp_10 - 0x60) = *(ebp_10 - 0x60) + *(ebp_10 - 0xA0);
					word32 esi_1451 = *(ebp_10 - 0x28);
					Eq_46 ecx_677 = edi_655 + esi_1451;
					*(ebp_10 - 0x94) = (union Eq_46 *) ecx_677;
					if (ecx_677 == ebx_1398)
						goto l0040206C;
					uint64 edx_eax_683 = (uint64) (uint32) ebp_10->dw0008;
					LPDWORD * esp_684 = esp_1481 - 0x04;
					*esp_684 = (LPDWORD *) (DWORD *) 0x0A;
					Eq_6100 edi_686 = *esp_684;
					ptr32 esp_1390 = (char *) esp_684 + 0x04;
					uint32 edx_689 = (uint32) (edx_eax_683 % edi_686);
					if (edx_689 == 0x1B)
					{
						Eq_46 eax_1413 = GetCurrentThread();
						__wait();
						if (eax_1413 != ebx_1398)
						{
							Eq_462 eax_1417 = GetCurrentThreadId();
							__wait();
							if (eax_1417 != 0x00)
							{
								*esp_684 = (LPDWORD *) (ebp_10 - 0x70);
								*(esp_684 - 0x04) = (union Eq_46 *) eax_1413;
								GetExitCodeThread(*(esp_684 - 0x04), *esp_684);
								__wait();
								esp_1390 = esp_684 - 0x04;
							}
						}
					}
					else
					{
						Eq_6100 eax_1427 = ebp_10 - 0x50;
						*esp_684 = (LPDWORD *) eax_1427;
						*(esp_684 - 0x04) = 0x04;
						*(esp_684 - 0x08) = *(ebp_10 - 0x40);
						*(esp_684 - 0x0C) = (union Eq_46 *) ecx_677;
						word32 eax_1438;
						word32 edx_1440;
						byte SZO_1441;
						byte C_1442;
						word32 ecx_1443;
						byte SCZO_1444;
						byte CZ_1446;
						byte al_1447;
						byte bl_1448;
						byte Z_1449;
						word32 edi_1450;
						byte SO_1452;
						word16 ax_1453;
						byte S_1454;
						bcuiposr0 None_1455;
						word16 si_1456;
						(*(ebp_10 - 100))();
						__wait();
						*(ebp_10 - 0x60) = *(ebp_10 - 0x60) - 0xB0;
					}
					*(ebp_10 - 0x20) = (union Eq_46 *) ebx_1398;
					word32 esi_1404 = esi_1451 + *(ebp_10 - 0xB8);
					while (*(ebp_10 - 0x20) <= 0x0800)
					{
						*(ebp_10 - 0x20) = *(ebp_10 - 0x20) + 0x01;
						word32 * esp_1381 = esp_1390 - 0x04;
						*esp_1381 = 0x04;
						*(esp_1381 - 0x04) = 0x3000;
						*(esp_1381 - 0x08) = *(ebp_10 - 0x6C);
						*(esp_1381 - 0x0C) = esi_2343;
						Eq_46 eax_1391;
						word32 edx_1393;
						byte SZO_1394;
						byte C_1395;
						word32 ecx_1396;
						byte SCZO_1397;
						byte CZ_1399;
						byte al_1400;
						byte bl_1401;
						byte Z_1402;
						word32 edi_1403;
						byte SO_1405;
						word16 ax_1406;
						byte S_1407;
						bcuiposr0 None_1408;
						word16 si_1409;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x38) = (union Eq_46 *) eax_1391;
						word32 esi_2343 = esi_1404;
						if (eax_1391 != ebx_1398)
							break;
					}
					ptr32 esp_1309;
					word32 * esp_738 = esp_1390 - 0x04;
					*esp_738 = 0x8000;
					*(esp_738 - 0x04) = (union Eq_46 *) ebx_1398;
					*(esp_738 - 0x08) = *(ebp_10 - 0xAC);
					ptr32 esp_745;
					word32 eax_746;
					word32 edx_748;
					byte SZO_749;
					byte C_750;
					word32 ecx_751;
					byte SCZO_752;
					byte CZ_754;
					byte al_755;
					byte bl_756;
					byte Z_757;
					word32 edi_758;
					word32 esi_759;
					byte SO_760;
					word16 ax_761;
					byte S_762;
					bcuiposr0 None_763;
					word16 si_764;
					Eq_46 ebx_1362;
					struct Eq_6272 * ebp_1356;
					(*(ebp_10 - 0x5C))();
					__wait();
					uint64 edx_eax_767 = (uint64) (uint32) ebp_1356->dw0008;
					*(esp_745 - 0x04) = 0x11;
					ui32 ecx_770 = *(esp_745 - 0x04);
					uint32 edx_773 = (uint32) (edx_eax_767 % ecx_770);
					if (edx_773 == 0x15)
					{
						*(esp_745 - 0x04) = 0x00100000;
						*(esp_745 - 0x08) = 0x0400;
						*(esp_745 - 0x0C) = (union Eq_46 *) ebx_1362;
						Eq_46 eax_1311 = HeapCreate(*(esp_745 - 0x0C), *(esp_745 - 0x08), *(esp_745 - 0x04));
						__wait();
						esp_1309 = esp_745 - 0x0C;
						if (eax_1311 != ebx_1362)
						{
							*(esp_745 - 0x10) = 0x0400;
							*(esp_745 - 0x14) = 0x08;
							*(esp_745 - 0x18) = (union Eq_46 *) eax_1311;
							Eq_46 eax_1323 = HeapAlloc(*(esp_745 - 0x18), *(esp_745 - 0x14), *(esp_745 - 0x10));
							__wait();
							esp_1309 = esp_745 - 0x18;
							word32 * esi_1328 = *(ebp_1356 - 0x28) + 0x0765;
							word32 ecx_1331 = 0x0100;
							Eq_46 edi_1332 = eax_1323;
							while (ecx_1331 != 0x00)
							{
								*edi_1332 = *esi_1328;
								esi_1328 = esi_1328 + 0x01;
								edi_1332 = edi_1332 + 0x04;
								ecx_1331 = ecx_1331 - 0x01;
							}
						}
					}
					else
					{
						*(esp_745 - 0x04) = 0x03;
						*(esp_745 - 0x08) = *(ebp_1356 - 0x90);
						*(esp_745 - 0x0C) = *(ebp_1356 - 0x8C);
						*(esp_745 - 0x10) = *(ebp_1356 - 0xB4);
						word32 eax_1355;
						word32 edx_1357;
						byte SZO_1358;
						byte C_1359;
						word32 ecx_1360;
						byte SCZO_1361;
						byte CZ_1363;
						byte al_1364;
						byte bl_1365;
						byte Z_1366;
						word32 edi_1367;
						word32 esi_1368;
						byte SO_1369;
						word16 ax_1370;
						byte S_1371;
						bcuiposr0 None_1372;
						word16 si_1373;
						(*(ebp_1356 - 44))();
						__wait();
						*(ebp_1356 - 0x20) = eax_1355;
					}
					word32 * esp_784 = esp_1309 - 0x04;
					*esp_784 = 0x8000;
					*(esp_784 - 0x04) = (union Eq_46 *) ebx_1362;
					*(esp_784 - 0x08) = *(ebp_1356 - 188);
					word32 eax_792;
					word32 edx_794;
					byte SZO_795;
					byte C_796;
					word32 ecx_797;
					byte SCZO_798;
					word32 ebx_799;
					byte CZ_800;
					byte al_801;
					byte bl_802;
					byte Z_803;
					word32 edi_804;
					word32 esi_805;
					byte SO_806;
					word16 ax_807;
					byte S_808;
					bcuiposr0 None_809;
					word16 si_810;
					ptr32 esp_1282;
					(*(ebp_1356 - 0x5C))();
					__wait();
					if (*(ebp_10 - 0x38) == ebx_799)
					{
						*(esp_1282 - 0x04) = 0x04;
						*(esp_1282 - 0x08) = 0x3000;
						*(esp_1282 - 0x0C) = *(ebp_10 - 0x6C);
						*(esp_1282 - 0x10) = ebx_799;
						word32 eax_1283;
						word32 edx_1285;
						byte SZO_1286;
						byte C_1287;
						word32 ecx_1288;
						byte SCZO_1289;
						word32 ebx_1290;
						byte CZ_1291;
						byte al_1292;
						byte bl_1293;
						byte Z_1294;
						word32 edi_1295;
						word32 esi_1296;
						byte SO_1297;
						word16 ax_1298;
						byte S_1299;
						bcuiposr0 None_1300;
						word16 si_1301;
						(*(ebp_10 - 0x60))();
						__wait();
						*(ebp_10 - 0x38) = eax_1283;
						if (eax_1283 == ebx_1290)
							goto l0040206C;
					}
					union Eq_4221 * esp_824 = esp_1282 - 0x04;
					*esp_824 = *(ebp_10 - 0x38);
					*(esp_824 - 0x04) = *(ebp_10 - 0x40);
					struct Eq_881 * ebx_1257 = *(ebp_10 - 0x94) + *(ebp_10 - 0x24) - 0xE0 + *(ebp_10 - 0x20);
					fn00401268(ebx_1257, ebp_10, dwArg00);
					__wait();
					*esp_824 = (union Eq_4221 *) (ebp_10 - 0x68);
					struct Eq_1595 * esi_1263 = *(ebp_10 - 0x38);
					*(esp_824 - 0x04) = (struct Eq_1595 **) esi_1263;
					word32 eax_844 = fn004014E5(ebp_10, dwArg00, dwArg04);
					__wait();
					if (eax_844 != 0x00)
					{
						uint64 edx_eax_851 = (uint64) (uint32) ebp_10->dw0008;
						*esp_824 = 11;
						Eq_4221 ecx_854 = *esp_824;
						ptr32 esp_1235 = (char *) esp_824 + 0x04;
						uint32 edx_857 = (uint32) (edx_eax_851 % ecx_854);
						if (edx_857 == 0x0F)
						{
							*esp_824 = 0x0400;
							*(esp_824 - 0x04) = 0x40;
							Eq_6785 eax_1237 = GlobalAlloc(*(esp_824 - 0x04), *esp_824);
							__wait();
							esp_1235 = esp_824 - 0x04;
							if (eax_1237 != null)
							{
								*(esp_824 - 0x08) = 0x00100546;
								*(esp_824 - 0x0C) = (HGLOBAL *) eax_1237;
								ptr32 esp_1249;
								byte * eax_1250;
								word32 edx_1252;
								byte SZO_1253;
								byte C_1254;
								word32 ecx_1255;
								byte SCZO_1256;
								byte CZ_1258;
								byte al_1259;
								byte bl_1260;
								byte Z_1261;
								word32 edi_1262;
								byte SO_1264;
								word16 ax_1265;
								byte S_1266;
								bcuiposr0 None_1267;
								word16 si_1268;
								(*(ebp_10 - 0x28) + 0x0565)();
								__wait();
								*eax_1250 = 0x01;
								*(esp_1249 - 0x04) = edi_1262;
								GlobalFree(*(esp_1249 - 0x04));
								__wait();
								esp_1235 = esp_1249 - 0x04;
							}
						}
						ptr32 * esp_878 = esp_1235 - 0x04;
						*esp_878 = ebp_10 - 0x68;
						struct Eq_1854 * esi_881;
						word32 eax_882 = fn004015E7(ebx_1257, ebp_10, esi_1263, out ebp_10, out esi_881);
						__wait();
						if (eax_882 != 0x00)
						{
							*esp_878 = *(ebp_10 - 0x28);
							word32 eax_891 = fn004016F7(esi_881, dwArg00);
							__wait();
							if (eax_891 != 0x00)
							{
								*esp_878 = ebp_10 - 0x50;
								*(esp_878 - 0x04) = 0x40;
								*(esp_878 - 0x08) = 0xF8;
								word32 edi_907 = *(ebp_10 - 0x98);
								*(esp_878 - 0x0C) = edi_907;
								ptr32 esp_910;
								ui32 eax_911;
								ptr32 ebp_912;
								word32 edx_913;
								byte SZO_914;
								byte C_915;
								word32 ecx_916;
								byte SCZO_917;
								struct Eq_6912 * ebx_918;
								byte CZ_919;
								byte al_920;
								byte bl_921;
								byte Z_922;
								struct Eq_6917 * edi_923;
								word32 esi_924;
								byte SO_925;
								word16 ax_926;
								byte S_927;
								bcuiposr0 None_928;
								word16 si_929;
								(*(ebp_10 - 100))();
								__wait();
								edi_923->dw0050 = (eax_911 | ~0x00) - *(ebp_912 - 0x28);
								edi_923->dw008C = ebx_918->dw008C;
								edi_923->dw0088 = ebx_918->dw0088 - *(ebp_912 - 0x28) + esi_924;
								cu16 ax_941 = (word16) (word32) ebx_918->w0006;
								edi_923->w0006 = ax_941;
								uint32 edx_943 = 0x00;
								if (0x00 < ax_941)
								{
									*(ebp_912 - 0x40) = &ebx_918->dw008C + 0x001B;
									struct Eq_7051 * eax_1189 = &edi_923->dw008C + 0x001E;
									edx_1194 = edx_943;
									do
									{
										uint32 edx_1194;
										*(esp_910 - 0x04) = 0x0A;
										word32 * edi_1201 = eax_1189 - 0x0C;
										word32 ecx_1204 = *(esp_910 - 0x04);
										word32 * esi_1206 = *(ebp_912 - 0x40);
										while (ecx_1204 != 0x00)
										{
											*edi_1201 = *esi_1206;
											esi_1206 = esi_1206 + 0x01;
											edi_1201 = edi_1201 + 0x01;
											ecx_1204 = ecx_1204 - 0x01;
										}
										eax_1189->dw0000 = eax_1189->dw0000 + (*(ebp_912 - 0x38) - *(ebp_912 - 0x28));
										*(ebp_912 - 0x40) = *(ebp_912 - 0x40) + 0x28;
										edx_1194 = edx_1194 + 0x01;
										eax_1189 = eax_1189 + 0x01;
									} while (edx_1194 < (word32) (*((char *) (*(ebp_912 - 0x98)) + 0x06)));
								}
								*(esp_910 - 0x04) = ebp_912 - 0x50;
								*(esp_910 - 0x08) = *(ebp_912 - 0x50);
								*(esp_910 - 0x0C) = 0xF8;
								*(esp_910 - 0x10) = *(ebp_912 - 0x98);
								ptr32 esp_962;
								word32 eax_963;
								word32 edx_965;
								byte SZO_966;
								byte C_967;
								word32 ecx_968;
								byte SCZO_969;
								word32 ebx_970;
								byte CZ_971;
								byte al_972;
								byte bl_973;
								byte Z_974;
								word32 edi_975;
								word32 esi_976;
								byte SO_977;
								word16 ax_978;
								byte S_979;
								bcuiposr0 None_980;
								word16 si_981;
								(*(ebp_912 - 100))();
								__wait();
								struct Eq_1036 * edi_982 = *(ebp_10 - 0x38);
								if (fn004012D3(edi_982) != 0x00)
								{
									*(esp_962 - 0x04) = ebp_10 - 0x50;
									*(esp_962 - 0x08) = 0x40;
									*(esp_962 - 0x0C) = *(ebp_10 - 0x6C);
									*(esp_962 - 0x10) = (struct Eq_1036 **) edi_982;
									ptr32 esp_1000;
									word32 eax_1001;
									word32 edx_1003;
									byte SZO_1004;
									byte C_1005;
									word32 ecx_1006;
									byte SCZO_1007;
									struct Eq_7168 * ebx_1008;
									byte CZ_1009;
									byte al_1010;
									byte bl_1011;
									byte Z_1012;
									word32 edi_1013;
									word32 esi_1014;
									byte SO_1015;
									word16 ax_1016;
									byte S_1017;
									bcuiposr0 None_1018;
									word16 si_1019;
									(*(ebp_10 - 100))();
									__wait();
									<anonymous> * ebx_1023 = ebx_1008->dw0028 + edi_1013;
									if (*(ebp_10 - 0xA8) != 0x00)
									{
										*(esp_1000 - 0x04) = ebp_10 - 0x68;
										*(esp_1000 - 0x08) = ebp_10 - 0x7C;
										*(esp_1000 - 0x0C) = *(ebp_10 - 0xC0);
										Eq_46 eax_1056 = fn00401390(ebp_10, dwArg00, dwArg04, dwArg08);
										__wait();
										if (eax_1056 != 0x00)
										{
											*(ebp_10 - 0x24) = 0x00;
											*(esp_1000 - 0x04) = ebp_10 - 0x24;
											*(esp_1000 - 0x08) = ebp_10->dw0008;
											ptr32 esp_1067;
											word32 eax_1068;
											word32 edx_1070;
											byte SZO_1071;
											byte C_1072;
											word32 ecx_1073;
											byte SCZO_1074;
											<anonymous> * ebx_1075;
											byte CZ_1076;
											byte al_1077;
											byte bl_1078;
											byte Z_1079;
											word32 edi_1080;
											struct Eq_7368 * esi_1081;
											byte SO_1082;
											word16 ax_1083;
											byte S_1084;
											bcuiposr0 None_1085;
											word16 si_1086;
											eax_1056();
											__wait();
											struct Eq_7368 * eax_1087 = *(ebp_10 - 0x24);
											if (eax_1087 != esi_1081)
											{
												eax_1087->dw0018 = edi_1080;
												*((char *) *(ebp_10 - 0x24) + 0x001C) = (struct Eq_7390 **) ebx_1075;
												struct Eq_7394 * eax_1096 = *(ebp_10 - 0x24);
												word32 ecx_1097 = *(ebp_10 - 0x6C);
												eax_1096->dw0020 = ecx_1097;
												*(esp_1067 - 0x04) = ebp_10->dw0010;
												*(esp_1067 - 0x08) = ebp_10->dw000C;
												*(esp_1067 - 0x0C) = edi_1080;
												*(esp_1067 - 0x10) = 0x01;
												word32 esp_1109;
												word32 eax_1110;
												word32 edx_1112;
												byte SZO_1113;
												byte C_1114;
												word32 ecx_1115;
												byte SCZO_1116;
												word32 ebx_1117;
												byte CZ_1118;
												byte al_1119;
												byte bl_1120;
												byte Z_1121;
												word32 edi_1122;
												word32 esi_1123;
												byte SO_1124;
												word16 ax_1125;
												byte S_1126;
												bcuiposr0 None_1127;
												word16 si_1128;
												ebx_1075();
												__wait();
												*(ebp_10 - 0x9C) = eax_1110;
											}
										}
									}
									else
									{
										*(esp_1000 - 0x04) = ebp_10->dw0010;
										*(esp_1000 - 0x08) = ebp_10->dw000C;
										*(esp_1000 - 0x0C) = ebp_10->dw0008;
										*(esp_1000 - 0x10) = 0x00;
										ptr32 esp_1141;
										word32 eax_1142;
										ptr32 ebp_1143;
										word32 edx_1144;
										byte SZO_1145;
										byte C_1146;
										word32 ecx_1147;
										byte SCZO_1148;
										word32 ebx_1149;
										byte CZ_1150;
										byte al_1151;
										byte bl_1152;
										byte Z_1153;
										word32 edi_1154;
										word32 esi_1155;
										byte SO_1156;
										word16 ax_1157;
										byte S_1158;
										bcuiposr0 None_1159;
										word16 si_1160;
										ebx_1023();
										__wait();
										*(ebp_1143 - 0x9C) = eax_1142;
										*(esp_1141 - 0x04) = 0x8000;
										*(esp_1141 - 0x08) = esi_1155;
										*(esp_1141 - 0x0C) = edi_1154;
										word32 esp_1168;
										word32 eax_1169;
										word32 edx_1171;
										byte SZO_1172;
										byte C_1173;
										word32 ecx_1174;
										byte SCZO_1175;
										word32 ebx_1176;
										byte CZ_1177;
										byte al_1178;
										byte bl_1179;
										byte Z_1180;
										word32 edi_1181;
										word32 esi_1182;
										byte SO_1183;
										word16 ax_1184;
										byte S_1185;
										bcuiposr0 None_1186;
										word16 si_1187;
										(*(ebp_1143 - 0x5C))();
										__wait();
									}
									eax_1043 = (Eq_462) *(ebp_10 - 0x9C);
l0040206E:
									fn004026B7(ebp_10, 0x010C, dwArg00, dwArg04, dwArg08);
									return eax_1043;
								}
							}
						}
					}
					goto l0040206C;
				}
				*(esp_511 - 0x04) = ebx_519;
				word32 esi_535 = *(ebp_10 - 0x44);
				*(esp_511 - 0x08) = esi_535;
				ShowWindow(*(esp_511 - 0x08), *(esp_511 - 0x04));
				__wait();
				*(esp_511 - 0x0C) = 0x004030FC;
				*(esp_511 - 0x10) = esi_535;
				SetWindowTextA(*(esp_511 - 0x10), *(esp_511 - 0x0C));
				__wait();
				*(esp_511 - 0x14) = ebp_10 - 0x011C;
				*(esp_511 - 0x18) = esi_535;
				Eq_118 eax_550 = GetWindowInfo(*(esp_511 - 0x18), *(esp_511 - 0x14));
				__wait();
				ptr32 esp_548 = esp_511 - 0x18;
				if (eax_550 != 0x00)
				{
					*(ebp_10 - 244) = *(ebp_10 - 244) | 0x00040000;
					*(esp_511 - 0x1C) = *(ebp_10 - 244);
					*(esp_511 - 0x20) = ~0x13;
					*(esp_511 - 0x24) = esi_535;
					SetWindowLongA(*(esp_511 - 0x24), *(esp_511 - 0x20), *(esp_511 - 0x1C));
					__wait();
					esp_548 = esp_511 - 0x24;
				}
				Eq_46 eax_555 = GetForegroundWindow();
				__wait();
				BOOL * esp_558 = esp_548 - 0x04;
				*esp_558 = (int32) 0x01;
				*(esp_558 - 0x04) = 0x32;
				*(esp_558 - 0x08) = 0x32;
				*(esp_558 - 0x0C) = 0x0A;
				*(esp_558 - 0x10) = 0x0A;
				*(esp_558 - 0x14) = (union Eq_46 *) eax_555;
				MoveWindow(*(esp_558 - 0x14), *(esp_558 - 0x10), *(esp_558 - 0x0C), *(esp_558 - 0x08), *(esp_558 - 0x04), *esp_558);
				__wait();
				*(esp_558 - 0x18) = ebx_519;
				*(esp_558 - 0x1C) = ebx_519;
				*(esp_558 - 0x20) = 0x0F;
				*(esp_558 - 0x24) = (union Eq_46 *) eax_555;
				Eq_118 eax_579 = PostMessageA(*(esp_558 - 0x24), *(esp_558 - 0x20), *(esp_558 - 0x1C), *(esp_558 - 0x18));
				__wait();
				if (eax_579 == 0x00)
				{
					*(esp_558 - 0x28) = (union Eq_46 *) eax_555;
					UpdateWindow(*(esp_558 - 0x28));
					__wait();
				}
			}
			goto l0040206C;
		}
	}
l0040206C:
	eax_1043 = 0x00;
	goto l0040206E;
}

// 004025B8: Register Eq_46 GetKJfkdsjgksjgd()
Eq_46 GetKJfkdsjgksjgd()
{
	Eq_46 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403154);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 004025DE: Register Eq_46 GetLKVGskgdh()
Eq_46 GetLKVGskgdh()
{
	Eq_46 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403160);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402604: Register Eq_46 GetGHsdjkglkdh()
Eq_46 GetGHsdjkglkdh()
{
	Eq_46 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403170);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040262A: Register Eq_46 GetFJlksdjglkdfjhd()
Eq_46 GetFJlksdjglkdfjhd()
{
	Eq_46 eax_13 = CreateEventA(null, 0x01, 0x01, 0x00403184);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 00402650: Register Eq_46 GetKJGjhgfdhfdkh()
Eq_46 GetKJGjhgfdhfdkh()
{
	Eq_46 eax_13 = CreateEventA(null, 0x01, 0x01, 4207000);
	SetEvent(eax_13);
	CloseHandle(eax_13);
	return eax_13;
}

// 0040267C: Register ptr32 fn0040267C(Register word32 ebx, Register word32 esi, Register word32 edi, Stack word32 dwArg00, Stack word32 dwArg04, Stack ui32 dwArg08)
ptr32 fn0040267C(word32 ebx, word32 esi, word32 edi, word32 dwArg00, word32 dwArg04, ui32 dwArg08)
{
	ptr32 esp_14 = fp - 0x08 - dwArg08;
	*(esp_14 - 0x04) = ebx;
	*(esp_14 - 0x08) = esi;
	*(esp_14 - 0x0C) = edi;
	*(esp_14 - 0x10) = dwArg00;
	fs->ptr0000 = fp - 0x08;
	return fp + 0x08;
}

// 004026B7: void fn004026B7(Register (ptr Eq_911) ebp, Stack word32 dwArg00, Stack Eq_46 dwArg04, Stack Eq_46 dwArg08, Stack Eq_46 dwArg0C)
void fn004026B7(Eq_911 * ebp, word32 dwArg00, Eq_46 dwArg04, Eq_46 dwArg08, Eq_46 dwArg0C)
{
	fs->dw0000 = *(ebp - 0x10);
	ebp->dw0000 = dwArg00;
}

