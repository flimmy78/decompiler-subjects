// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 003E1000: Register word32 fn003E1000(Stack ptr32 dwArg00, Stack (ptr Eq_4) dwArg04, Register out ptr32 ebpOut)
word32 fn003E1000(ptr32 dwArg00, Eq_4 * dwArg04, ptr32 & ebpOut)
{
	word32 ebp_34;
	*ebpOut = dwArg00;
	return dwArg04 + Mem0[dwArg04 + 0x3C:word32];
}

// 003E1021: void fn003E1021(Stack (ptr Eq_4) dwArg04, Stack Eq_13 dwArg08, Stack Eq_14 dwArg0C)
void fn003E1021(Eq_4 * dwArg04, Eq_13 dwArg08, SIZE_T dwArg0C)
{
	fn003E18F3(dwArg08, dwArg04, dwArg0C);
	VirtualProtect(dwArg08, dwArg0C, 0x02, fp - 0x08);
}

// 003E1060: Register byte fn003E1060(Stack ui32 dwArg04)
byte fn003E1060(ui32 dwArg04)
{
	return (byte) (-(dwArg04 & 0x80000000) == 0x00);
}

// 003E1073: Register (ptr Eq_40) fn003E1073(Register (ptr Eq_40) ebp, Stack (ptr Eq_4) dwArg04, Stack Eq_13 dwArg08)
Eq_40 * fn003E1073(Eq_40 * ebp, Eq_4 * dwArg04, Eq_13 dwArg08)
{
	ptr32 esp_196 = fp - 0x28;
	word32 dwLoc08_199 = dwArg08 + Mem0[dwArg04 + 0x80:word32];
	while (*((word32) dwLoc08_199 + 0x0C) != 0x00)
	{
		Eq_13 dwLoc10_150;
		union Eq_13 * esp_62 = esp_196 - 0x04;
		Mem63[esp_62 + 0x00:word32] = dwArg08 + Mem0[dwLoc08_199 + 0x0C:word32];
		*esp_62 = *esp_62;
		Eq_13 eax_68 = LoadLibraryA(*esp_62);
		*(esp_62 - 0x04) = (union Eq_13 *) dwLoc08_199;
		if (*((char *) *(esp_62 - 0x04) + 0x04) == 0x00)
		{
			*(esp_62 - 0x04) = (union Eq_13 *) dwLoc08_199;
			dwLoc10_150 = dwArg08 + Mem202[Mem202[(esp_62 - 0x04) + 0x00:word32] + 0x10:word32];
		}
		else
			dwLoc10_150 = dwArg08 + Mem72[dwLoc08_199 + 0x00:word32];
		union Eq_13 * esp_144 = esp_62;
		word32 dwLoc18_146 = dwArg08 + Mem72[dwLoc08_199 + 0x10:word32];
		while (true)
		{
			union Eq_13 * esp_98 = esp_144 - 0x04;
			*esp_98 = (union Eq_13 *) dwLoc10_150;
			if (**esp_98 == 0x00)
				break;
			Eq_139 dwLoc14_131;
			*esp_98 = (union Eq_13 *) eax_68;
			*(esp_98 - 0x04) = (union Eq_13 *) dwLoc10_150;
			*(esp_98 - 0x04) = **(esp_98 - 0x04);
			*(esp_98 - 0x04) = *(esp_98 - 0x04);
			if ((word32) fn003E1060(dwArg00) != 0x00)
			{
				*esp_98 = (union Eq_13 *) *dwLoc10_150;
				*esp_98 = (union Eq_13 *) (word32) (word16) (*esp_98 & 0xFFFF);
				*(esp_98 - 0x04) = (union Eq_13 *) eax_68;
				dwLoc14_131 = GetProcAddress(*(esp_98 - 0x04), *esp_98);
			}
			else
			{
				*esp_98 = (union Eq_13 *) dwLoc10_150;
				Eq_13 edx_173 = *esp_98;
				*esp_98 = (union Eq_13 *) dwArg08;
				Mem186[esp_98 + 0x00:word32] = Mem177[esp_98 + 0x00:word32] + Mem177[edx_173 + 0x00:word32] + 0x02;
				*(esp_98 - 0x04) = (union Eq_13 *) eax_68;
				dwLoc14_131 = GetProcAddress(*(esp_98 - 0x04), *esp_98);
			}
			union Eq_13 * esp_132 = esp_144 - 0x08;
			*(esp_132 - 0x04) = (FARPROC *) dwLoc14_131;
			*dwLoc18_146 = *(esp_132 - 0x04);
			*(esp_132 - 0x04) = dwLoc18_146;
			esp_144 = esp_132;
			dwLoc18_146 = *(esp_132 - 0x04) + 0x04;
			dwLoc10_150 = (word32) dwLoc10_150 + 0x04;
		}
		*esp_98 = (union Eq_13 *) dwLoc08_199;
		esp_196 = (char *) esp_98 + 0x04;
		dwLoc08_199 = (char *) *esp_98 + 0x0014;
	}
	struct Eq_56 ** esp_214 = esp_196 - 0x04;
	*esp_214 = (struct Eq_56 **) (fp - 0x04);
	return *((char *) *esp_214 + 0x04);
}

// 003E1197: void fn003E1197()
void fn003E1197()
{
}

// 003E11A0: Register word32 fn003E11A0(Stack (ptr word32) dwArg04, Stack word32 dwArg08, Stack Eq_294 dwArg0C)
word32 fn003E11A0(word32 * dwArg04, word32 dwArg08, LPOVERLAPPED dwArg0C)
{
	ptr32 esp_12 = fp - 0x10;
	Eq_294 dwLoc10_14 = null;
	while (true)
	{
		LPOVERLAPPED * esp_16 = esp_12 - 0x04;
		*esp_16 = (LPOVERLAPPED *) dwLoc10_14;
		if (*esp_16 >= dwArg0C)
			break;
		*esp_16 = (LPOVERLAPPED *) null;
		*(esp_16 - 0x04) = fp - 0x08;
		*(esp_16 - 0x08) = 0x08;
		*(esp_16 - 0x0C) = dwArg08 + dwLoc10_14 * 0x04;
		*(esp_16 - 0x10) = dwArg04;
		*(esp_16 - 0x10) = *((char *) *(esp_16 - 0x10) + 0x04);
		*(esp_16 - 0x10) = *(esp_16 - 0x10);
		WriteFile(*(esp_16 - 0x10), *(esp_16 - 0x0C), *(esp_16 - 0x08), *(esp_16 - 0x04), *esp_16);
		*(esp_16 - 0x14) = 0x00;
		*(esp_16 - 0x18) = fp - 0x0C;
		*(esp_16 - 0x1C) = 0x08;
		*(esp_16 - 0x20) = dwArg08;
		*(esp_16 - 0x20) = *(esp_16 - 0x20) + dwLoc10_14 * 0x04;
		*(esp_16 - 0x24) = *dwArg04;
		ReadFile(*(esp_16 - 0x24), *(esp_16 - 0x20), *(esp_16 - 0x1C), *(esp_16 - 0x18), *(esp_16 - 0x14));
		esp_12 = esp_16 - 0x24;
		dwLoc10_14 = (Eq_294) ((char *) &dwLoc10_14->Internal + 0x02);
	}
	*esp_16 = (LPOVERLAPPED *) (fp - 0x04);
	return *((char *) *esp_16 + 0x04);
}

// 003E1300: Register Eq_375 fn003E1300(Stack (ptr Eq_4) dwArg04)
HANDLE fn003E1300(Eq_4 * dwArg04)
{
	CloseHandle(dwArg04->b0000);
	Eq_375 v9_22 = dwArg04[0x04];
	CloseHandle(v9_22);
	return v9_22;
}

// 003E1320: Register word32 fn003E1320(Register ptr32 ebp, Register out ptr32 ebpOut)
word32 fn003E1320(ptr32 ebp, ptr32 & ebpOut)
{
	struct Eq_40 * ebp_173 = fp - 0x04;
	ptr32 esp_116 = fp - 0x34;
	if ((word32) fn003E14F0()->ptr0030->b0002 == 0x00)
	{
		globals->dw4199B2 = 4824;
		globals->dw4199B2 = globals->dw4199B2 + 0x4BEC;
		globals->dw4199B6 = 8696;
		globals->dw4199B6 = globals->dw4199B6 + 11017;
		globals->dw4199BA = 21231;
		globals->dw4199BE = 0x0626;
		globals->dw4199BE = globals->dw4199BE + 0x17FA;
		esp_116 = fp - 0x44;
		if (CreatePipe(fp - 0x24, fp - 0x14, null, 0x10) != 0x00)
		{
			esp_116 = fp - 0x54;
			if (CreatePipe(fp - 0x18, fp - 0x20, null, 0x10) != 0x00)
			{
				CreateThread(null, 0x00, &globals->t3E1207, fp - 0x24, 0x00, fp - 0x0C);
				*(fp - 0x70) = fn003E11A0(fp - 0x18, 0x003E3000, globals->dw3ED40B >> 0x02) - 0x14;
				*(fp - 0x70) = fn003E1300(dwArg00) - 0x20;
				*(fp - 0x70) = *(fn003E1300(dwArg00) - 0x24);
				CloseHandle(*(fp - 0x70));
				*(fp - 116) = 0x003E3000;
				word32 eax_174 = fn003E1000(ebp, dwArg00, out ebp_173);
				*(ebp_173 - 0x0C) = eax_174;
				esp_116 = fp - 0x70;
				if (*(ebp_173 - 0x0C) != 0x00)
				{
					*(ebp_173 - 44) = *((char *) *(ebp_173 - 0x0C) + 0x0034);
					*(fp - 116) = *(ebp_173 - 0x0C);
					*(fp - 116) = *((char *) *(fp - 116) + 0x0054);
					*(fp - 116) = *(fp - 116);
					*(fp - 0x78) = *(ebp_173 - 44);
					*(fp - 0x7C) = 0x003E3000;
					fn003E1021(dwArg00, dwArg04, dwArg08);
					*(fp - 116) = *(ebp_173 - 44);
					*(fp - 116) = *(fp - 116);
					*(fp - 0x78) = 0x003E3000;
					*(fp - 0x7C) = *(ebp_173 - 0x0C);
					fn003E1500(dwArg00, dwArg04, dwArg08);
					*(fp - 116) = *(ebp_173 - 44);
					*(fp - 116) = *(fp - 116);
					word32 eax_234 = fn003E1000(ebp, dwArg00, out ebp_173);
					*(ebp_173 - 0x28) = eax_234;
					esp_116 = fp - 0x70;
					if (*(ebp_173 - 0x28) != 0x00)
					{
						*(fp - 116) = *(ebp_173 - 44);
						*(fp - 0x78) = *(ebp_173 - 0x28);
						ptr32 ebp_245 = fn003E1073(ebp_173, dwArg00, dwArg04);
						*(fp - 116) = *(ebp_245 - 44);
						*(fp - 116) = *(fp - 116);
						*(fp - 0x78) = *(ebp_245 - 0x28);
						*(fp - 0x78) = *(fp - 0x78);
						fn003E16A9(ebp_245, dwArg00);
						word32 ecx_264 = *(ebp_245 - 44);
						*((char *) *(ebp_245 - 0x18) + 0x08) = ecx_264;
						struct Eq_905 * edx_266 = *(ebp_245 - 0x0C);
						*(fp - 116) = *(ebp_245 - 44);
						word32 eax_272 = *(fp - 116) + edx_266->dw0028;
						*(ebp_245 - 0x30) = eax_272;
						byte SCZO_277;
						word32 eax_278;
						word32 ecx_279;
						word32 edx_280;
						byte SZO_281;
						byte C_282;
						byte Z_283;
						(*(ebp_245 - 0x30))();
					}
				}
				fn003E1197();
			}
		}
	}
	struct Eq_40 ** esp_54 = esp_116 - 0x04;
	*esp_54 = (struct Eq_40 **) ebp_173;
	word32 ebp_58;
	*ebpOut = *((char *) *esp_54 + 0x04);
	return 0x00;
}

// 003E14D3: Register Eq_25 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 ebp_9;
	word32 eax_10 = fn003E1320(fp - 0x04, out ebp_9);
	*(ebp_9 - 0x04) = eax_10;
	*(fp - 0x0C) = *(ebp_9 - 0x04);
	*(fp - 0x0C) = *(fp - 0x0C);
	ExitProcess(*(fp - 0x0C));
}

// 003E14F0: Register word32 fn003E14F0()
word32 fn003E14F0()
{
	return fs->dw0018;
}

// 003E1500: void fn003E1500(Stack (ptr Eq_4) dwArg04, Stack Eq_13 dwArg08, Stack Eq_14 dwArg0C)
void fn003E1500(Eq_4 * dwArg04, Eq_13 dwArg08, SIZE_T dwArg0C)
{
	word16 dx_18 = dwArg04[0x06];
	word16 wLoc14_120 = 0x00;
	while ((word32) wLoc14_120 < (word32) dx_18)
	{
		Eq_14 dwLoc2C_122;
		Eq_14 v12_58 = (dwArg04 + 0x00F8)[(word32) wLoc14_120 *s 0x28 + 0x08];
		Eq_14 eax_67 = (dwArg04 + 0x00F8)[(word32) wLoc14_120 *s 0x28 + 0x10];
		if (v12_58 < eax_67)
			dwLoc2C_122 = v12_58;
		else
			dwLoc2C_122 = eax_67;
		fn003E18F3(dwArg0C + Mem0[((word32) wLoc14_120 *s 0x28 + 0x0C) + (dwArg04 + 0xF8):word32], dwArg08 + Mem0[((word32) wLoc14_120 *s 0x28 + 0x14) + (dwArg04 + 0xF8):word32], dwLoc2C_122);
		wLoc14_120 = wLoc14_120 + 0x01;
	}
}

// 003E15D1: Register ui32 fn003E15D1(Stack ptr32 dwArg00, Stack ui32 dwArg04, Register out (ptr Eq_1048) ebpOut)
ui32 fn003E15D1(ptr32 dwArg00, ui32 dwArg04, Eq_1048 * & ebpOut)
{
	ui32 dwLoc08_13 = 0x00;
	if ((dwArg04 & 0x04000000) != 0x00)
		dwLoc08_13 = 0x0200;
	ui32 dwLoc08_101;
	if ((dwArg04 & 0x20000000) != 0x00)
	{
		if ((dwArg04 & 0x40000000) != 0x00)
		{
			if ((dwArg04 & 0x80000000) != 0x00)
				dwLoc08_101 = dwLoc08_13 | 0x40;
			else
				dwLoc08_101 = dwLoc08_13 | 0x20;
		}
		else if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_101 = dwLoc08_13 | 0x80;
		else
			dwLoc08_101 = dwLoc08_13 | 0x10;
	}
	else if ((dwArg04 & 0x40000000) != 0x00)
	{
		if ((dwArg04 & 0x80000000) != 0x00)
			dwLoc08_101 = dwLoc08_13 | 0x04;
		else
			dwLoc08_101 = dwLoc08_13 | 0x02;
	}
	else if ((dwArg04 & 0x80000000) != 0x00)
		dwLoc08_101 = dwLoc08_13 | 0x08;
	else
		dwLoc08_101 = dwLoc08_13 | 0x01;
	word32 ebp_47;
	*ebpOut = dwArg00;
	return dwLoc08_101;
}

// 003E16A9: void fn003E16A9(Register ptr32 ebp, Stack (ptr Eq_4) dwArg04)
void fn003E16A9(ptr32 ebp, Eq_4 * dwArg04)
{
	struct Eq_1103 * ebp_25 = fp - 0x04;
	ptr32 esp_12 = fp - 0x20;
	while ((word32) *(ebp_25 - 0x10) < (word32) (*(ebp_25 - 0x08)))
	{
		int32 ecx_32 = (word32) *(ebp_25 - 0x10);
		PDWORD * esp_35 = esp_12 - 0x04;
		*esp_35 = *(ebp_25 - 0x04);
		*(ebp_25 - 0x18) = (char *) *((char *) *esp_35 + ((word32) (ecx_32 *s 0x28) + 0x0C)) + ebp_25->dw000C;
		int32 ecx_42 = (word32) *(ebp_25 - 0x10);
		*esp_35 = *(ebp_25 - 0x04);
		*(ebp_25 - 0x1C) = *((char *) *esp_35 + ((word32) (ecx_42 *s 0x28) + 0x08));
		*esp_35 = (PDWORD *) (ebp_25 - 0x14);
		*(esp_35 - 0x04) = (word32) ((word32) *(ebp_25 - 0x10) *s 0x28) + 0x0024 + *(ebp_25 - 0x04);
		*(esp_35 - 0x04) = *(esp_35 - 0x04);
		*(esp_35 - 0x04) = fn003E15D1(ebp, dwArg00, out ebp_25);
		*(esp_35 - 0x08) = *(ebp_25 - 0x1C);
		*(esp_35 - 0x0C) = *(ebp_25 - 0x18);
		VirtualProtect(*(esp_35 - 0x0C), *(esp_35 - 0x08), *(esp_35 - 0x04), *esp_35);
		esp_12 = esp_35 - 0x0C;
		*(ebp_25 - 0x10) = *(ebp_25 - 0x10) + 0x01;
	}
}

// 003E18F3: void fn003E18F3(Stack Eq_13 dwArg04, Stack (ptr Eq_4) dwArg08, Stack Eq_14 dwArg0C)
void fn003E18F3(Eq_13 dwArg04, Eq_4 * dwArg08, SIZE_T dwArg0C)
{
	while (true)
	{
		dwArg0C = dwArg0C - 0x01;
		if (dwArg0C == 0x00)
			break;
		*dwArg04 = dwArg08->b0000;
		dwArg04 = (word32) dwArg04 + 0x01;
		dwArg08 = dwArg08 + 0x01;
	}
}

