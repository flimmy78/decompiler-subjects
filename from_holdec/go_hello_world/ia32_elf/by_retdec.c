//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

// ----------------- Float Types Definitions ------------------

typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct _lsb__rsb__ptr_runtime__defer {
    struct runtime__defer ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb__ptr_runtime_bmap {
    struct runtime_bmap ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb__ptr_runtime_itab {
    struct runtime_itab ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb__ptr_runtime_moduledata {
    struct runtime_moduledata ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb__ptr_runtime_mspan {
    struct runtime_mspan ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb__ptr_runtime_sudog {
    struct runtime_sudog ** e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_int32 {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_runtime_functab {
    struct runtime_functab * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_runtime_imethod {
    struct runtime_imethod * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_runtime_modulehash {
    struct runtime_modulehash * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_runtime_ptabEntry {
    struct runtime_ptabEntry * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_runtime_textsect {
    struct runtime_textsect * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_uint32 {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_uint64 {
    int64_t * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_uint8 {
    char * e0;
    int32_t e1;
    int32_t e2;
};

struct _lsb__rsb_uintptr {
    int32_t * e0;
    int32_t e1;
    int32_t e2;
};

struct bucket_lt_runtime__typePair {
    int32_t e0;
};

struct hash_lt_runtime__typePair_comma_struct___gt_ {
    int32_t e0;
    char e1;
    char e2;
    int16_t e3;
    int32_t e4;
    struct bucket_lt_runtime__typePair e5;
    int32_t * e6;
    struct bucket_lt_runtime__typePair e7;
    int32_t * e8;
    int32_t e9;
    struct runtime_mapextra * e10;
};

struct hash_lt_runtime_typeOff {
    int32_t e0;
};

struct runtime__defer {
    int32_t e0;
    bool e1;
    int32_t e2;
    int32_t e3;
    struct runtime_funcval * e4;
    struct runtime__panic * e5;
    struct runtime__defer * e6;
};

struct runtime__func {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
};

struct runtime__type {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    char e3;
    char e4;
    char e5;
    char e6;
    struct runtime_typeAlg * e7;
    char * e8;
    int32_t e9;
    int32_t e10;
};

struct runtime_bitvector {
    int32_t e0;
    char * e1;
};

struct runtime_blockRecord {
    int64_t e0;
    int64_t e1;
};

struct runtime_bmap {
    char e0[1];
};

struct runtime_bucket {
    struct runtime_bucket * e0;
    struct runtime_bucket * e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
};

struct runtime_cgoSymbolizerArg {
    int32_t e0;
    char * e1;
    int32_t e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct runtime_eface {
    struct runtime__type * e0;
    char * e1;
};

struct runtime__panic {
    char * e0;
    struct runtime_eface e1;
    struct runtime__panic * e2;
    bool e3;
    bool e4;
};

struct runtime_fixalloc {
    int32_t e0;
    void (*e1)(char *, char *);
    char * e2;
    struct runtime_mlink * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int64_t * e7;
    bool e8;
};

struct runtime_funcInfo {
    struct runtime__func * e0;
    struct runtime_moduledata * e1;
};

struct runtime_functab {
    int32_t e0;
    int32_t e1;
};

struct runtime_funcval {
    int32_t e0;
};

struct runtime_gcControllerState {
    int64_t e0;
    int64_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int64_t e5;
    int64_t e6;
    int64_t e7;
    float64_t e8;
    float64_t e9;
    float64_t e10;
    char e11[1];
    int64_t e12;
    char e13[1];
};

struct runtime_gcTrigger {
    int32_t e0;
    int64_t e1;
    int32_t e2;
};

struct runtime_gcWork {
    struct runtime_workbuf * e0;
    struct runtime_workbuf * e1;
    int64_t e2;
    int64_t e3;
};

struct runtime_gobuf {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct runtime_heapBits {
    char * e0;
    int32_t e1;
};

struct runtime_hmap {
    int32_t e0;
    char e1;
    char e2;
    int16_t e3;
    int32_t e4;
    char * e5;
    char * e6;
    int32_t e7;
    struct runtime_mapextra * e8;
};

struct runtime_iface {
    struct runtime_itab * e0;
    char * e1;
};

struct runtime_imethod {
    int32_t e0;
    int32_t e1;
};

struct runtime_itab {
    struct runtime_interfacetype * e0;
    struct runtime__type * e1;
    struct runtime_itab * e2;
    int32_t e3;
    bool e4;
    bool e5;
    char e6[1];
    int32_t e7[1];
};

struct runtime_lfnode {
    int64_t e0;
    int32_t e1;
};

struct runtime_libcall {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
};

struct runtime_mOS {
    int32_t e0;
};

struct runtime_mSpanList {
    struct runtime_mspan * e0;
    struct runtime_mspan * e1;
};

struct runtime_mTreap {
    struct runtime_treapNode * e0;
};

struct runtime_mapextra {
    struct _lsb__rsb__ptr_runtime_bmap * e0[1];
    struct runtime_bmap * e1;
};

struct runtime_maptype {
    struct runtime__type e0;
    struct runtime__type * e1;
    struct runtime__type * e2;
    struct runtime__type * e3;
    struct runtime__type * e4;
    char e5;
    bool e6;
    char e7;
    bool e8;
    int16_t e9;
    bool e10;
    bool e11;
};

struct runtime_markBits {
    char * e0;
    char e1;
    int32_t e2;
};

struct runtime_memRecordCycle {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct runtime_memRecord {
    struct runtime_memRecordCycle e0;
    struct runtime_memRecordCycle e1[1];
};

struct runtime_mlink {
    struct runtime_mlink * e0;
};

struct runtime_mutex {
    int32_t e0;
};

struct runtime_gcSweepBuf {
    struct runtime_mutex e0;
    char * e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
};

struct runtime_mcentral {
    struct runtime_mutex e0;
    char e1;
    struct runtime_mSpanList e2;
    struct runtime_mSpanList e3;
    int64_t e4;
};

struct runtime_mspan {
    struct runtime_mspan * e0;
    struct runtime_mspan * e1;
    struct runtime_mSpanList * e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int64_t e8;
    char * e9;
    char * e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    int16_t e14;
    char e15;
    bool e16;
    char e17;
    char e18;
    char e19;
    char e20;
    int32_t e21;
    int64_t e22;
    int32_t e23;
    int32_t e24;
    struct runtime_mutex e25;
    struct runtime_special * e26;
};

struct runtime_name {
    char * e0;
};

struct runtime_interfacetype {
    struct runtime__type e0;
    struct runtime_name e1;
    struct _lsb__rsb_runtime_imethod e2;
};

struct runtime_note {
    int32_t e0;
};

struct runtime_pcvalueCacheEnt {
    int32_t e0;
    int32_t e1;
    int32_t e2;
};

struct runtime_pcvalueCache {
    struct runtime_pcvalueCacheEnt e0[1];
};

struct runtime_persistentAlloc {
    char * e0;
    int32_t e1;
};

struct runtime_ptabEntry {
    int32_t e0;
    int32_t e1;
};

struct runtime_randomOrder {
    int32_t e0;
    struct _lsb__rsb_uint32 e1;
};

struct runtime_rwmutex {
    struct runtime_mutex e0;
    int32_t e1;
    int32_t e2;
    struct runtime_mutex e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
};

struct runtime_semaRoot {
    struct runtime_mutex e0;
    struct runtime_sudog * e1;
    int32_t e2;
};

struct runtime_siginfo {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct runtime_slice {
    char * e0;
    int32_t e1;
    int32_t e2;
};

struct runtime_special {
    struct runtime_special * e0;
    int16_t e1;
    char e2;
};

struct runtime_stack {
    int32_t e0;
    int32_t e1;
};

struct runtime_adjustinfo {
    struct runtime_stack e0;
    int32_t e1;
    struct runtime_pcvalueCache e2;
    int32_t e3;
};

struct runtime_stackfreelist {
    int32_t e0;
    int32_t e1;
};

struct runtime_mcache {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    struct runtime_mspan * e5[1];
    struct runtime_stackfreelist e6[1];
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10[1];
};

struct runtime_stkframe {
    struct runtime_funcInfo e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    struct runtime_bitvector * e9;
};

struct runtime_sudog {
    struct runtime_g * e0;
    int32_t * e1;
    struct runtime_sudog * e2;
    struct runtime_sudog * e3;
    char * e4;
    int64_t e5;
    int64_t e6;
    int32_t e7;
    struct runtime_sudog * e8;
    struct runtime_sudog * e9;
    struct runtime_sudog * e10;
    struct runtime_hchan * e11;
};

struct runtime_sysmontick {
    int32_t e0;
    int64_t e1;
    int32_t e2;
    int64_t e3;
};

struct runtime_p {
    struct runtime_mutex e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    struct runtime_sysmontick e6;
    int32_t e7;
    struct runtime_mcache * e8;
    int32_t e9;
    struct _lsb__rsb__ptr_runtime__defer e10[1];
    struct runtime__defer * e11[1][1];
    int64_t e12;
    int64_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16[1];
    int32_t e17;
    struct runtime_g * e18;
    int32_t e19;
    struct _lsb__rsb__ptr_runtime_sudog e20;
    struct runtime_sudog * e21[1];
    int32_t e22;
    bool e23;
    int32_t e24;
    int32_t e25;
    struct runtime_persistentAlloc e26;
    int64_t e27;
    int32_t e28;
    int32_t e29;
    struct runtime_gcWork e30;
    int32_t e31;
    char e32[1];
};

struct runtime_textsect {
    int32_t e0;
    int32_t e1;
    int32_t e2;
};

struct runtime_timer {
    int32_t e0;
    int64_t e1;
    int64_t e2;
    void (*e3)(struct runtime_eface, int32_t);
    struct runtime_eface e4;
    int32_t e5;
};

struct runtime_pollDesc {
    struct runtime_pollDesc * e0;
    struct runtime_mutex e1;
    int32_t e2;
    bool e3;
    int32_t e4;
    int32_t e5;
    struct runtime_timer e6;
    int64_t e7;
    int32_t e8;
    struct runtime_timer e9;
    int64_t e10;
    int32_t e11;
};

struct runtime_traceAlloc {
    int32_t e0;
    int32_t e1;
};

struct runtime_traceBufHeader {
    int32_t e0;
    int64_t e1;
    int32_t e2;
    int32_t e3[1];
};

struct runtime_traceBuf {
    struct runtime_traceBufHeader e0;
    char e1[1];
};

struct runtime_traceStack {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4[1];
};

struct runtime_traceStackTable {
    struct runtime_mutex e0;
    int32_t e1;
    struct runtime_traceAlloc e2;
    int32_t e3[1];
};

struct runtime_treapNode {
    struct runtime_treapNode * e0;
    struct runtime_treapNode * e1;
    struct runtime_treapNode * e2;
    int32_t e3;
    struct runtime_mspan * e4;
    int32_t e5;
};

struct runtime_typeAlg {
    void (*e0)(char *, int32_t, int32_t *);
    void (*e1)(char *, char *, bool *);
};

struct runtime_uncommontype {
    int32_t e0;
    int16_t e1;
    int16_t e2;
    int32_t e3;
    int32_t e4;
};

struct runtime_waitq {
    struct runtime_sudog * e0;
    struct runtime_sudog * e1;
};

struct runtime_hchan {
    int32_t e0;
    int32_t e1;
    char * e2;
    int16_t e3;
    int32_t e4;
    struct runtime__type * e5;
    int32_t e6;
    int32_t e7;
    struct runtime_waitq e8;
    struct runtime_waitq e9;
    struct runtime_mutex e10;
};

struct runtime_workbufhdr {
    struct runtime_lfnode e0;
    int32_t e1;
};

struct runtime_workbuf {
    struct runtime_workbufhdr e0;
    int32_t e1[1];
};

struct string {
    char * e0;
    int32_t e1;
};

struct runtime_g {
    struct runtime_stack e0;
    int32_t e1;
    int32_t e2;
    struct runtime__panic * e3;
    struct runtime__defer * e4;
    struct runtime_m * e5;
    struct runtime_gobuf e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    char * e10;
    int32_t e11;
    int32_t e12;
    int64_t e13;
    int64_t e14;
    struct string e15;
    int32_t e16;
    bool e17;
    bool e18;
    bool e19;
    bool e20;
    bool e21;
    bool e22;
    char e23;
    bool e24;
    int64_t e25;
    int64_t e26;
    int32_t e27;
    struct runtime_m * e28;
    int32_t e29;
    struct _lsb__rsb_uint8 e30;
    int32_t e31;
    int32_t e32;
    int32_t e33;
    int32_t e34;
    int32_t e35;
    int32_t e36;
    struct runtime_sudog * e37;
    struct _lsb__rsb_uintptr e38;
    char * e39;
    struct runtime_timer * e40;
    int64_t e41;
};

struct runtime_m {
    struct runtime_g * e0;
    struct runtime_gobuf e1;
    int32_t e2;
    int64_t e3;
    struct runtime_g * e4;
    int32_t e5[1];
    int32_t e6[1];
    void (*e7)();
    struct runtime_g * e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    struct string e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    bool e21;
    bool e22;
    bool e23;
    bool e24;
    char e25;
    bool e26;
    int32_t e27;
    int64_t e28;
    int32_t e29;
    int32_t e30;
    int32_t (*e31)[1];
    struct runtime_note e32;
    struct runtime_m * e33;
    int32_t e34;
    struct runtime_mcache * e35;
    struct runtime_g * e36;
    int32_t e37[1];
    int32_t e38[1];
    int32_t e39[1];
    int32_t e40;
    int32_t e41;
    int32_t e42;
    bool e43;
    char e44;
    char * e45;
    char * e46;
    char e47;
    int32_t e48;
    bool e49;
    int32_t e50;
    int32_t e51;
    struct runtime_libcall e52;
    int32_t e53;
    int32_t e54;
    int32_t e55;
    struct runtime_libcall e56;
    struct runtime_mOS e57;
};

struct runtime_moduledata {
    struct _lsb__rsb_uint8 e0;
    struct _lsb__rsb_runtime_functab e1;
    struct _lsb__rsb_uint32 e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int32_t e12;
    int32_t e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int32_t e17;
    int32_t e18;
    int32_t e19;
    int32_t e20;
    struct _lsb__rsb_runtime_textsect e21;
    struct _lsb__rsb_int32 e22;
    struct _lsb__rsb__ptr_runtime_itab e23;
    struct _lsb__rsb_runtime_ptabEntry e24;
    struct string e25;
    struct _lsb__rsb_runtime_modulehash e26;
    struct string e27;
    struct _lsb__rsb_runtime_modulehash e28;
    struct runtime_bitvector e29;
    struct runtime_bitvector e30;
    struct hash_lt_runtime_typeOff e31;
    int32_t * e32;
    struct runtime_moduledata * e33;
};

struct runtime_modulehash {
    struct string e0;
    struct string e1;
    struct string * e2;
};

struct runtime_sigTabT {
    int32_t e0;
    struct string e1;
};

struct struct_runtime_mcentralruntime_mcentral_runtime_pad_lsb_32_rsb_uint8_ {
    struct runtime_mcentral e0;
    char e1[1];
};

struct runtime_mheap {
    struct runtime_mutex e0;
    struct runtime_mSpanList e1[1];
    struct runtime_mTreap e2;
    struct runtime_mSpanList e3[1];
    struct runtime_mSpanList e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    struct _lsb__rsb__ptr_runtime_mspan e8;
    struct _lsb__rsb__ptr_runtime_mspan e9;
    struct runtime_gcSweepBuf e10[1];
    int32_t e11;
    int64_t e12;
    int64_t e13;
    int64_t e14;
    int64_t e15;
    float64_t e16;
    int64_t e17;
    int64_t e18;
    int64_t e19;
    int64_t e20;
    int64_t e21[1];
    int32_t e22;
    int32_t e23;
    int32_t e24;
    int32_t e25;
    int32_t e26;
    int32_t e27;
    bool e28;
    int32_t e29;
    struct struct_runtime_mcentralruntime_mcentral_runtime_pad_lsb_32_rsb_uint8_ e30[1];
    struct runtime_fixalloc e31;
    struct runtime_fixalloc e32;
    struct runtime_fixalloc e33;
    struct runtime_fixalloc e34;
    struct runtime_fixalloc e35;
    struct runtime_mutex e36;
};

struct struct_runtime_enabledbool_runtime_pad_3_uint8_runtime_neededbool_runtime_cgobool_runtime_alignmeuint64_ {
    bool e0;
    char e1[0];
    bool e2;
    bool e3;
    int64_t e4;
};

// ------------------- Function Prototypes --------------------

void callRet(void);
void function_808fd5c(void);
void function_808fd60(void);
void function_808fd6d(void);
void function_808fd70(void);
void function_808fd77(void);
void function_808fd85(void);
void function_808fd86(void);
void function_808fd87(void);
void function_808fd89(void);
void function_808fd8a(void);
void function_808fd8b(void);
void function_8090160(void);
void function_809025a(void);
void function_809026e(void);
void function_8090278(void);
void gosave(void);
void runtime__d2v(int64_t * y, float64_t d);
void runtime__div64by32(void);
void runtime__lb__ptr__type_rb__nameOff(struct runtime__type * t, int32_t off, struct runtime_name a3);
void runtime__lb__ptr__type_rb__string(struct runtime__type * t, struct string a2);
void runtime__lb__ptr__type_rb__textOff(struct runtime__type * t, int32_t off, char * a3);
void runtime__lb__ptr__type_rb__typeOff(struct runtime__type * t, int32_t off, struct runtime__type * a3);
void runtime__lb__ptr__type_rb__uncommon(struct runtime__type * t, struct runtime_uncommontype * a2);
void runtime__lb__ptr_bucket_rb__bp(struct runtime_bucket * b, struct runtime_blockRecord * a2);
void runtime__lb__ptr_bucket_rb__mp(struct runtime_bucket * b, struct runtime_memRecord * a2);
void runtime__lb__ptr_fixalloc_rb__alloc(struct runtime_fixalloc * f, char * a2);
void runtime__lb__ptr_gcControllerState_rb__endCycle(struct runtime_gcControllerState * c, float64_t a2);
void runtime__lb__ptr_gcControllerState_rb__enlistWorker(struct runtime_gcControllerState * c);
void runtime__lb__ptr_gcControllerState_rb__findRunnableGCWorker(struct runtime_gcControllerState * c, struct runtime_p * _p_, struct runtime_g * a3);
void runtime__lb__ptr_gcControllerState_rb__findRunnableGCWorker_func1(int64_t * ptr, bool a2);
void runtime__lb__ptr_gcControllerState_rb__revise(struct runtime_gcControllerState * c);
void runtime__lb__ptr_gcControllerState_rb__startCycle(struct runtime_gcControllerState * c);
void runtime__lb__ptr_gcSweepBuf_rb__block(struct runtime_gcSweepBuf * b, int32_t i, struct _lsb__rsb__ptr_runtime_mspan a3);
void runtime__lb__ptr_gcSweepBuf_rb__numBlocks(struct runtime_gcSweepBuf * b, int32_t a2);
void runtime__lb__ptr_gcWork_rb__balance(struct runtime_gcWork * w);
void runtime__lb__ptr_gcWork_rb__dispose(struct runtime_gcWork * w);
void runtime__lb__ptr_gcWork_rb__get(struct runtime_gcWork * w, int32_t a2);
void runtime__lb__ptr_gcWork_rb__init(struct runtime_gcWork * w);
void runtime__lb__ptr_gcWork_rb__put(struct runtime_gcWork * w, int32_t obj);
void runtime__lb__ptr_gcWork_rb__tryGet(struct runtime_gcWork * w, int32_t a2);
void runtime__lb__ptr_guintptr_rb__cas(int32_t * gp, int32_t old, int32_t new, bool a4);
void runtime__lb__ptr_hmap_rb__newoverflow(struct runtime_hmap * h, struct runtime_maptype * t, struct runtime_bmap * b, struct runtime_bmap * a4);
void runtime__lb__ptr_lfstack_rb__empty(int64_t * head, bool a2);
void runtime__lb__ptr_lfstack_rb__pop(int64_t * head, char * a2);
void runtime__lb__ptr_lfstack_rb__push(int64_t * head, struct runtime_lfnode * node);
void runtime__lb__ptr_mcache_rb__nextFree(struct runtime_mcache * c, char spc, int32_t v, struct runtime_mspan * s, bool shouldhelpgc);
void runtime__lb__ptr_mcache_rb__nextFree_func1(void);
void runtime__lb__ptr_mcache_rb__releaseAll(struct runtime_mcache * c);
void runtime__lb__ptr_mcentral_rb__uncacheSpan(struct runtime_mcentral * c, struct runtime_mspan * s);
void runtime__lb__ptr_mheap_rb__allocLarge(struct runtime_mheap * h, int32_t npage, struct runtime_mspan * a3);
void runtime__lb__ptr_mheap_rb__allocManual(struct runtime_mheap * h, int32_t npage, int64_t * stat, struct runtime_mspan * a4);
void runtime__lb__ptr_mheap_rb__allocSpanLocked(struct runtime_mheap * h, int32_t npage, int64_t * stat, struct runtime_mspan * a4);
void runtime__lb__ptr_mheap_rb__freeManual(struct runtime_mheap * h, struct runtime_mspan * s, int64_t * stat);
void runtime__lb__ptr_mheap_rb__freeSpanLocked(struct runtime_mheap * h, struct runtime_mspan * s, bool acctinuse, bool acctidle, int64_t unusedsince);
void runtime__lb__ptr_mheap_rb__grow(struct runtime_mheap * h, int32_t npage, bool a3);
void runtime__lb__ptr_mheap_rb__init(struct runtime_mheap * h, int32_t spansStart, int32_t spansBytes);
void runtime__lb__ptr_mheap_rb__mapBits(struct runtime_mheap * h, int32_t arena_used);
void runtime__lb__ptr_mheap_rb__mapSpans(struct runtime_mheap * h, int32_t arena_used);
void runtime__lb__ptr_mheap_rb__setArenaUsed(struct runtime_mheap * h, int32_t arena_used, bool racemap);
void runtime__lb__ptr_mheap_rb__sysAlloc(struct runtime_mheap * h, int32_t n, char * a3);
void runtime__lb__ptr_mspan_rb__nextFreeIndex(struct runtime_mspan * s, int32_t a2);
void runtime__lb__ptr_mspan_rb__refillAllocCache(struct runtime_mspan * s, int32_t whichByte);
void runtime__lb__ptr_mSpanList_rb__insert(struct runtime_mSpanList * list, struct runtime_mspan * span);
void runtime__lb__ptr_mSpanList_rb__remove(struct runtime_mSpanList * list, struct runtime_mspan * span);
void runtime__lb__ptr_mSpanList_rb__takeAll(struct runtime_mSpanList * list, struct runtime_mSpanList * other);
void runtime__lb__ptr_mTreap_rb__insert(struct runtime_mTreap * root, struct runtime_mspan * span);
void runtime__lb__ptr_mTreap_rb__remove(struct runtime_mTreap * root, int32_t npages, struct runtime_mspan * a3);
void runtime__lb__ptr_mTreap_rb__removeNode(struct runtime_mTreap * root, struct runtime_treapNode * t, struct runtime_mspan * a3);
void runtime__lb__ptr_mTreap_rb__removeSpan(struct runtime_mTreap * root, struct runtime_mspan * span);
void runtime__lb__ptr_mTreap_rb__rotateLeft(struct runtime_mTreap * root, struct runtime_treapNode * x);
void runtime__lb__ptr_mTreap_rb__rotateRight(struct runtime_mTreap * root, struct runtime_treapNode * y);
void runtime__lb__ptr_randomOrder_rb__reset(struct runtime_randomOrder * ord, int32_t count);
void runtime__lb__ptr_rwmutex_rb__rlock(struct runtime_rwmutex * rw);
void runtime__lb__ptr_rwmutex_rb__rlock_func1(void);
void runtime__lb__ptr_rwmutex_rb__runlock(struct runtime_rwmutex * rw);
void runtime__lb__ptr_semaRoot_rb__dequeue(struct runtime_semaRoot * root, int32_t * addr, struct runtime_sudog * found, int64_t now);
void runtime__lb__ptr_semaRoot_rb__queue(struct runtime_semaRoot * root, int32_t * addr, struct runtime_sudog * s, bool lifo);
void runtime__lb__ptr_semaRoot_rb__rotateLeft(struct runtime_semaRoot * root, struct runtime_sudog * x);
void runtime__lb__ptr_semaRoot_rb__rotateRight(struct runtime_semaRoot * root, struct runtime_sudog * y);
void runtime__lb__ptr_traceAlloc_rb__alloc(struct runtime_traceAlloc * a, int32_t n, char * a3);
void runtime__lb__ptr_traceBuf_rb__varint(struct runtime_traceBuf * buf, int64_t v);
void runtime__lb__ptr_traceStackTable_rb__find(struct runtime_traceStackTable * tab, struct _lsb__rsb_uintptr pcs, int32_t hash, int32_t a4);
void runtime__lb__ptr_traceStackTable_rb__newStack(struct runtime_traceStackTable * tab, int32_t n, struct runtime_traceStack * a3);
void runtime__lb__ptr_traceStackTable_rb__put(struct runtime_traceStackTable * tab, struct _lsb__rsb_uintptr pcs, struct runtime_traceStack * a3);
void runtime__lb__ptr_workbuf_rb__checkempty(struct runtime_workbuf * b);
void runtime__lb__ptr_workbuf_rb__checknonempty(struct runtime_workbuf * b);
void runtime__mul64by32(void);
void runtime_acquirep(struct runtime_p * _p_);
void runtime_acquirep1(struct runtime_p * _p_);
void runtime_acquireSudog(struct runtime_sudog * a1);
void runtime_activeModules(struct _lsb__rsb__ptr_runtime_moduledata a1);
void runtime_additab(struct runtime_itab * m, bool locked, bool canfail);
void runtime_addrspace_free(char * v, int32_t n, bool a3);
void runtime_adjustctxt(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo);
void runtime_adjustdefers(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo);
void runtime_adjustsudogs(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo);
void runtime_aeshash(void);
void runtime_aeshashbody(void);
void runtime_alginit(void);
void runtime_allgadd(struct runtime_g * gp);
void runtime_allocm(struct runtime_p * _p_, void (*fn)(), struct runtime_m * a3);
void runtime_allocmcache(struct runtime_mcache * a1);
void runtime_args(int32_t c, char ** v);
void runtime_asmcgocall(void);
void runtime_asminit(void);
void runtime_assertE2I2(struct runtime_interfacetype * inter, struct runtime_eface e, struct runtime_iface r, bool b);
void runtime_atoi(struct string s, int32_t a2, bool a3);
void runtime_atoi32(struct string s, int32_t a2, bool a3);
void runtime_atomicstorep(char * ptr, char * new);
void runtime_badctxt(void);
void runtime_badmcall(void (*fn)(struct runtime_g *));
void runtime_badmcall2(void (*fn)(struct runtime_g *));
void runtime_badmorestackg0(void);
void runtime_badmorestackgsignal(void);
void runtime_badreflectcall(void);
void runtime_badsystemstack(void);
void runtime_blockevent(int64_t cycles, int32_t skip);
void runtime_blocksampled(int64_t cycles, bool a2);
void runtime_bulkBarrierBitmap(int32_t dst, int32_t src, uint32_t size, uint32_t maskOffset, char * bits);
void runtime_bulkBarrierPreWrite(uint32_t dst, int32_t src, uint32_t size);
void runtime_call1024(void);
void runtime_call1048576(void);
void runtime_call1073741824(void);
void runtime_call128(void);
void runtime_call131072(void);
void runtime_call134217728(void);
void runtime_call16(void);
void runtime_call16384(void);
void runtime_call16777216(void);
void runtime_call2048(void);
void runtime_call2097152(void);
void runtime_call256(void);
void runtime_call262144(void);
void runtime_call268435456(void);
void runtime_call32(void);
void runtime_call32768(void);
void runtime_call33554432(void);
void runtime_call4096(void);
void runtime_call4194304(void);
void runtime_call512(void);
void runtime_call524288(void);
void runtime_call536870912(void);
void runtime_call64(void);
void runtime_call65536(void);
void runtime_call67108864(void);
void runtime_call8192(void);
void runtime_call8388608(void);
void runtime_callCgoSymbolizer(struct runtime_cgoSymbolizerArg * arg);
void runtime_callers(int32_t skip, struct _lsb__rsb_uintptr pcbuf, int32_t a3);
void runtime_callers_func1(void);
void runtime_cansemacquire(int32_t * addr, bool a2);
void runtime_casfrom_Gscanstatus(struct runtime_g * gp, int32_t oldval, int32_t newval);
void runtime_casgstatus(struct runtime_g * gp, int32_t oldval, int32_t newval);
void runtime_casgstatus_func1(void);
void runtime_casp(char ** ptr, char * old, char * new, bool a4);
void runtime_castogscanstatus(struct runtime_g * gp, int32_t oldval, int32_t newval, bool a4);
void runtime_cgoCheckBits(char * src, char * gcbits, uint32_t off, int32_t size);
void runtime_cgoCheckMemmove(struct runtime__type * typ, char * dst, char * src, int32_t off, int32_t size);
void runtime_cgoCheckTypedBlock(struct runtime__type * typ, char * src, uint32_t off, uint32_t size);
void runtime_cgoCheckTypedBlock_func1(void);
void runtime_cgoCheckWriteBarrier(int32_t * dst, int32_t src);
void runtime_cgoCheckWriteBarrier_func1(void);
void runtime_cgoContextPCs(int32_t ctxt, struct _lsb__rsb_uintptr buf);
void runtime_cgoIsGoPointer(char * p, bool a2);
void runtime_check(void);
void runtime_checkASM(void);
void runtime_checkdead(void);
void runtime_checkmcount(void);
void runtime_clearpools(void);
void runtime_clone(void);
void runtime_closefd(void);
void runtime_cmpbody(void);
void runtime_cmpstring(void);
void runtime_contains(struct string s, struct string t, bool a3);
void runtime_convT2Estring(struct runtime__type * t, char * elem, struct runtime_eface e);
void runtime_copystack(struct runtime_g * gp, int32_t newsize, bool sync);
void runtime_cputicks(void);
void runtime_debug_setGCPercent(int32_t in, int32_t out);
void runtime_debug_SetTraceback(struct string level);
void runtime_deferproc(int32_t siz, struct runtime_funcval * fn);
void runtime_deferreturn(int32_t arg0);
void runtime_dodiv(int64_t n, int64_t d, int64_t q, int64_t r);
void runtime_dopanic(int32_t unused);
void runtime_dopanic_func1(void);
void runtime_duffzero(void);
void runtime_dumpgstatus(struct runtime_g * gp);
void runtime_emptyfunc(void);
void runtime_entersyscallblock(int32_t dummy);
void runtime_entersyscallblock_func1(void);
void runtime_entersyscallblock_func2(void);
void runtime_epollwait(void);
void runtime_eqslice(struct _lsb__rsb_uintptr x, struct _lsb__rsb_uintptr y, bool a3);
void runtime_eqstring(void);
void runtime_evacuate(struct runtime_maptype * t, struct runtime_hmap * h, int32_t oldbucket);
void runtime_execute(struct runtime_g * gp, bool inheritTime);
void runtime_exit(void);
void runtime_exit1(void);
void runtime_exitsyscall(int32_t dummy);
void runtime_exitsyscallfast(bool a1);
void runtime_exitsyscallfast_func1(void);
void runtime_exitsyscallfast_reacquired(void);
void runtime_exitsyscallfast_reacquired_func1(void);
void runtime_extendRandom(struct _lsb__rsb_uint8 r, int32_t n);
void runtime_findfunc(int32_t pc, struct runtime_funcInfo a2);
void runtime_findmoduledatap(int32_t pc, struct runtime_moduledata * a2);
void runtime_findnull(char * s, int32_t a2);
void runtime_findrunnable(struct runtime_g * gp, bool inheritTime);
void runtime_findsghi(struct runtime_g * gp, struct runtime_stack stk, int32_t a3);
void runtime_float64toint64(float64_t d, int64_t y);
void runtime_float64touint32(void);
void runtime_float64touint64(float64_t d, int64_t y);
void runtime_flushmcache(int32_t i);
void runtime_fmtNSAsMS(struct _lsb__rsb_uint8 buf, int64_t ns, struct _lsb__rsb_uint8 a3);
void runtime_freedefer(struct runtime__defer * d);
void runtime_freedefer_func1(void);
void runtime_freedeferfn(void);
void runtime_freedeferpanic(void);
void runtime_freemcache(struct runtime_mcache * c);
void runtime_freemcache_func1(void);
void runtime_funcdata(struct runtime_funcInfo f, int32_t i, char * a3);
void runtime_funcfile(struct runtime_funcInfo f, int32_t fileno, struct string a3);
void runtime_funcline(struct runtime_funcInfo f, int32_t targetpc, struct string file, int32_t line);
void runtime_funcline1(struct runtime_funcInfo f, int32_t targetpc, bool strict, struct string file, int32_t line);
void runtime_funcname(struct runtime_funcInfo f, struct string a2);
void runtime_funcnameFromNameoff(struct runtime_funcInfo f, int32_t nameoff, struct string a3);
void runtime_funcspdelta(struct runtime_funcInfo f, int32_t targetpc, struct runtime_pcvalueCache * cache, int32_t a4);
void runtime_futex(void);
void runtime_futexsleep(int32_t * addr, int32_t val, int64_t ns);
void runtime_futexwakeup(int32_t * addr, int32_t cnt);
void runtime_futexwakeup_func1(void);
void runtime_gcallers(struct runtime_g * gp, int32_t skip, struct _lsb__rsb_uintptr pcbuf, int32_t a4);
void runtime_gcAssistAlloc(struct runtime_g * gp);
void runtime_gcBgMarkStartWorkers(void);
void runtime_gcd(int32_t a, int32_t b, int32_t a3);
void runtime_gcDrain(struct runtime_gcWork * gcw, int32_t flags);
void runtime_gcDumpObject(struct string label, int32_t obj, int32_t off);
void runtime_gcFlushBgCredit(int64_t scanWork);
void runtime_gchelper(void);
void runtime_gchelperstart(void);
void runtime_gcinit(void);
void runtime_gcMarkDone(void);
void runtime_gcmarknewobject(int32_t obj, int32_t size, int32_t scanSize);
void runtime_gcMarkRootCheck(void);
void runtime_gcMarkRootPrepare(void);
void runtime_gcMarkRootPrepare_func1(int32_t bytes, int32_t a2);
void runtime_gcMarkTermination(float64_t nextTriggerRatio);
void runtime_gcMarkTermination_func1(void);
void runtime_gcMarkTermination_func2(void);
void runtime_gcMarkTinyAllocs(void);
void runtime_gcMarkWorkAvailable(struct runtime_p * p, bool a2);
void runtime_gcParkAssist(bool a1);
void runtime_gcprocs(int32_t a1);
void runtime_gcResetMarkState(void);
void runtime_gcSetTriggerRatio(float64_t triggerRatio);
void runtime_gcStart(int32_t mode, struct runtime_gcTrigger trigger);
void runtime_gcstopm(void);
void runtime_gcTrigger_test(struct runtime_gcTrigger t, bool a2);
void runtime_gcWakeAllAssists(void);
void runtime_gentraceback(int32_t pc0, int32_t sp0, int32_t lr0, struct runtime_g * gp, int32_t skip, int32_t * pcbuf, int32_t max, void (*callback)(struct runtime_stkframe *, char *, bool *), char * v, int32_t flags, int32_t a11);
void runtime_getArgInfo(struct runtime_stkframe * frame, struct runtime_funcInfo f, bool needArgMap, struct runtime_funcval * ctxt, int32_t arglen, struct runtime_bitvector * argmap);
void runtime_getargp(int32_t x, int32_t a2);
void runtime_getcallerpc(void);
void runtime_getempty(struct runtime_workbuf * a1);
void runtime_getempty_func1(void);
void runtime_getfull(struct runtime_workbuf * a1);
void runtime_getitab(struct runtime_interfacetype * inter, struct runtime__type * typ, bool canfail, struct runtime_itab * a4);
void runtime_getproccount(int32_t a1);
void runtime_getRandomData(struct _lsb__rsb_uint8 r);
void runtime_getsig(int32_t i, int32_t a2);
void runtime_gettid(void);
void runtime_gfpurge(struct runtime_p * _p_);
void runtime_globrunqget(struct runtime_p * _p_, int32_t max, struct runtime_g * a3);
void runtime_goargs(void);
void runtime_goenvs(void);
void runtime_goenvs_unix(void);
void runtime_gogetenv(struct string key, struct string a2);
void runtime_gogo(void);
void runtime_gopanic(struct runtime_eface e);
void runtime_gopark(void (*unlockf)(struct runtime_g *, char *, bool *), char * lock, struct string reason, char traceEv, int32_t traceskip);
void runtime_goparkunlock(struct runtime_mutex * lock, struct string reason, char traceEv, int32_t traceskip);
void runtime_gopreempt_m(struct runtime_g * gp);
void runtime_goready(struct runtime_g * gp, int32_t traceskip);
void runtime_goready_func1(void);
void runtime_goroutineheader(struct runtime_g * gp);
void runtime_gosave(void);
void runtime_Gosched(void);
void runtime_goschedImpl(struct runtime_g * gp);
void runtime_gostring(char * p, struct string a2);
void runtime_gostringnocopy(char * str, struct string a2);
void runtime_gosweepone(int32_t a1);
void runtime_gosweepone_func1(void);
void runtime_gotraceback(int32_t level, bool all, bool crash);
void runtime_greyobject(int32_t obj, int32_t base, int32_t off, struct runtime_heapBits hbits, struct runtime_mspan * span, struct runtime_gcWork * gcw, int32_t objIndex);
void runtime_growslice(struct runtime__type * et, struct runtime_slice old, int32_t cap, struct runtime_slice a4);
void runtime_growWork(struct runtime_maptype * t, struct runtime_hmap * h, int32_t bucket);
void runtime_gwrite(struct _lsb__rsb_uint8 b);
void runtime_handoff(struct runtime_workbuf * b, struct runtime_workbuf * a2);
void runtime_handoffp(struct runtime_p * _p_);
void runtime_hashGrow(struct runtime_maptype * t, struct runtime_hmap * h);
void runtime_heapBits_setCheckmarked(struct runtime_heapBits h, int32_t size);
void runtime_heapBitsForObject(int32_t p, int32_t refBase, int32_t refOff, int32_t base, struct runtime_heapBits hbits, struct runtime_mspan * s, int32_t objIndex);
void runtime_heapBitsSetType(int32_t x, int32_t size, int32_t dataSize, struct runtime__type * typ);
void runtime_heapBitsSetTypeGCProg(struct runtime_heapBits h, int32_t progSize, int32_t elemSize, int32_t dataSize, int32_t allocSize, char * prog);
void runtime_incidlelocked(int32_t v);
void runtime_index(struct string s, struct string t, char * a3);
void runtime_initsig(bool preinit);
void runtime_injectglist(struct runtime_g * glist);
void runtime_int64div(int64_t n, int64_t d, int64_t a3);
void runtime_int64mod(int64_t n, int64_t d, int64_t a3);
void runtime_int64tofloat64(int64_t y, float64_t a2);
void runtime_internal_atomic_And8(void);
void runtime_internal_atomic_Cas(void);
void runtime_internal_atomic_Cas64(void);
void runtime_internal_atomic_Casp1(void);
void runtime_internal_atomic_Casuintptr(void);
void runtime_internal_atomic_Load(int32_t * ptr, int32_t a2);
void runtime_internal_atomic_Load64(void);
void runtime_internal_atomic_Loadint64(void);
void runtime_internal_atomic_Loadp(char * ptr, char * a2);
void runtime_internal_atomic_Loaduintptr(void);
void runtime_internal_atomic_Or8(void);
void runtime_internal_atomic_Store(void);
void runtime_internal_atomic_Store64(void);
void runtime_internal_atomic_StorepNoWB(void);
void runtime_internal_atomic_Storeuintptr(void);
void runtime_internal_atomic_Xadd(void);
void runtime_internal_atomic_Xadd64(int64_t * ptr, int64_t delta, int64_t a3);
void runtime_internal_atomic_Xaddint64(void);
void runtime_internal_atomic_Xadduintptr(void);
void runtime_internal_atomic_Xchg(void);
void runtime_internal_atomic_Xchg64(int64_t * ptr, int64_t new, int64_t a3);
void runtime_internal_sys_Ctz64(void);
void runtime_itabsinit(void);
void runtime_itoaDiv(struct _lsb__rsb_uint8 buf, int64_t val, int32_t dec, struct _lsb__rsb_uint8 a4);
void runtime_jmpdefer(void);
void runtime_ldt0setup(void);
void runtime_lock(struct runtime_mutex * l);
void runtime_lockextra(bool nilokay, struct runtime_m * a2);
void runtime_madvise(void);
void runtime_makeBucketArray(struct runtime_maptype * t, char b, char * buckets, struct runtime_bmap * nextOverflow);
void runtime_makemap(struct runtime_maptype * t, int64_t hint, struct runtime_hmap * h, char * bucket, struct runtime_hmap * a5);
void runtime_makeslice(struct runtime__type * et, int32_t len, int32_t cap, struct runtime_slice a4);
void runtime_malg(int32_t stacksize, struct runtime_g * a2);
void runtime_malg_func1(void);
void runtime_mallocgc(int32_t size, struct runtime__type * typ, bool needzero, char * a4);
void runtime_mallocgc_func1(void);
void runtime_mallocinit(void);
void runtime_mapaccess1_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4);
void runtime_mapaccess2_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4, bool a5);
void runtime_mapaccess2_fast64(struct runtime_maptype * t, struct runtime_hmap * h, int64_t key, char * a4, bool a5);
void runtime_mapassign_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4);
void runtime_mapassign_fast64(struct runtime_maptype * t, struct runtime_hmap * h, int64_t key, char * a4);
void runtime_markBits_setMarked(struct runtime_markBits m);
void runtime_markBitsForAddr(int32_t p, struct runtime_markBits a2);
void runtime_markroot(struct runtime_gcWork * gcw, int32_t i);
void runtime_markroot_func1(void);
void runtime_markrootBlock(int32_t b0, int32_t n0, char * ptrmask0, struct runtime_gcWork * gcw, int32_t shard);
void runtime_markrootSpans(struct runtime_gcWork * gcw, int32_t shard);
void runtime_mcall(void);
void runtime_mcommoninit(struct runtime_m * mp);
void runtime_memclrHasPointers(char * ptr, int32_t n);
void runtime_memclrNoHeapPointers(void);
void runtime_memeqbody(void);
void runtime_memhash(char * p, int32_t seed, int32_t s, int32_t a4);
void runtime_memmove(void);
void runtime_mincore(void);
void runtime_minit(void);
void runtime_minitSignalMask(void);
void runtime_minitSignals(void);
void runtime_minitSignalStack(void);
void runtime_mmap(void);
void runtime_mmap_fixed(char * v, int32_t n, int32_t prot, int32_t flags, int32_t fd, int32_t offset, char * a7);
void runtime_moduledataverify(void);
void runtime_moduledataverify1(struct runtime_moduledata * datap);
void runtime_modulesinit(void);
void runtime_morestack(void);
void runtime_morestack_noctxt(void);
void runtime_morestackc(void);
void runtime_mpreinit(struct runtime_m * mp);
void runtime_mProf_Flush(void);
void runtime_mProf_FlushLocked(void);
void runtime_mProf_Malloc(char * p, int32_t size);
void runtime_mProf_Malloc_func1(void);
void runtime_mProf_NextCycle(void);
void runtime_mput(struct runtime_m * mp);
void runtime_msigsave(struct runtime_m * mp);
void runtime_mstart(void);
void runtime_mstart1(void);
void runtime_mSysStatDec(int64_t * sysStat, uint32_t n);
void runtime_mSysStatInc(int64_t * sysStat, uint32_t n);
void runtime_munmap(void);
void runtime_name_name(struct runtime_name n, struct string s);
void runtime_name_pkgPath(struct runtime_name n, struct string a2);
void runtime_name_tag(struct runtime_name n, struct string s);
void runtime_name_tagLen(struct runtime_name n, int32_t a2);
void runtime_nanotime(void);
void runtime_netpoll(bool block, struct runtime_g * a2);
void runtime_netpollinited(bool a1);
void runtime_netpollready(int32_t * gpp, struct runtime_pollDesc * pd, int32_t mode);
void runtime_netpollunblock(struct runtime_pollDesc * pd, int32_t mode, bool ioready, struct runtime_g * a4);
void runtime_newarray(struct runtime__type * typ, int32_t n, char * a3);
void runtime_newBucket(int32_t typ, int32_t nstk, struct runtime_bucket * a3);
void runtime_newdefer(uint32_t siz, struct runtime__defer * a2);
void runtime_newdefer_func1(void);
void runtime_newdefer_func2(void);
void runtime_newextram(void);
void runtime_newm(void (*fn)(), struct runtime_p * _p_);
void runtime_newobject(struct runtime__type * typ, char * a2);
void runtime_newosproc(struct runtime_m * mp, char * stk);
void runtime_newproc(int32_t siz, struct runtime_funcval * fn);
void runtime_newproc_func1(void);
void runtime_newstack(char * ctxt);
void runtime_nextFreeFast(struct runtime_mspan * s, int32_t a2);
void runtime_nextSample(int32_t a1);
void runtime_notesleep(struct runtime_note * n);
void runtime_notetsleep_internal(struct runtime_note * n, int64_t ns, bool a3);
void runtime_notetsleepg(struct runtime_note * n, int64_t ns, bool a3);
void runtime_notewakeup(struct runtime_note * n);
void runtime_oneNewExtraM(void);
void runtime_open(void);
void runtime_osinit(void);
void runtime_osyield(void);
void runtime_panicCheckMalloc(struct runtime_iface err);
void runtime_panicdivide(void);
void runtime_panicdottypeE(struct runtime__type * have, struct runtime__type * want, struct runtime__type * iface);
void runtime_panicdottypeI(struct runtime_itab * have, struct runtime__type * want, struct runtime__type * iface);
void runtime_panicindex(void);
void runtime_panicslice(void);
void runtime_parsedebugvars(void);
void runtime_pcdatavalue(struct runtime_funcInfo f, int32_t table, int32_t targetpc, struct runtime_pcvalueCache * cache, int32_t a5);
void runtime_pcvalue(struct runtime_funcInfo f, int32_t off, int32_t targetpc, struct runtime_pcvalueCache * cache, bool strict, int32_t a6);
void runtime_persistentalloc(int32_t size, int32_t align, int64_t * sysStat, char * a4);
void runtime_persistentalloc_func1(void);
void runtime_pidleget(struct runtime_p * a1);
void runtime_pidleput(struct runtime_p * _p_);
void runtime_pollWork(bool a1);
void runtime_prefetchnta(void);
void runtime_prefetcht0(void);
void runtime_prefetcht1(void);
void runtime_prefetcht2(void);
void runtime_prepareFreeWorkbufs(void);
void runtime_preprintpanics(struct runtime__panic * p);
void runtime_printany(struct runtime_eface i);
void runtime_printbool(bool v);
void runtime_printCgoTraceback(int32_t (*callers)[1]);
void runtime_printcomplex(float80_t c);
void runtime_printcreatedby(struct runtime_g * gp);
void runtime_printeface(struct runtime_eface e);
void runtime_printfloat(float64_t v);
void runtime_printhex(int64_t v);
void runtime_printint(int64_t v);
void runtime_printlock(void);
void runtime_printnl(void);
void runtime_printOneCgoTraceback(int32_t pc, int32_t max, struct runtime_cgoSymbolizerArg * arg, int32_t a4);
void runtime_printpanics(struct runtime__panic * p);
void runtime_printpointer(char * p);
void runtime_printslice(struct _lsb__rsb_uint8 s);
void runtime_printsp(void);
void runtime_printstring(struct string s);
void runtime_printuint(int64_t v);
void runtime_printunlock(void);
void runtime_procresize(int32_t nprocs, struct runtime_p * a2);
void runtime_procyield(void);
void runtime_profilealloc(struct runtime_m * mp, char * x, int32_t size);
void runtime_progToPointerMask(char * prog, int32_t size, struct runtime_bitvector a3);
void runtime_publicationBarrier(void);
void runtime_putempty(struct runtime_workbuf * b);
void runtime_putfull(struct runtime_workbuf * b);
void runtime_rawstring(int32_t size, struct string s, struct _lsb__rsb_uint8 b);
void runtime_read(void);
void runtime_readgogc(int32_t a1);
void runtime_readgstatus(struct runtime_g * gp, int32_t a2);
void runtime_readvarint(struct _lsb__rsb_uint8 p, int32_t read, int32_t val);
void runtime_ready(struct runtime_g * gp, int32_t traceskip, bool next);
void runtime_readyWithTime(struct runtime_sudog * s, int32_t traceskip);
void runtime_recordForPanic(struct _lsb__rsb_uint8 b);
void runtime_reflectcall(void);
void runtime_reflectcallmove(struct runtime__type * typ, char * dst, char * src, int32_t size);
void runtime_reflectOffsLock(void);
void runtime_reflectOffsUnlock(void);
void runtime_releasep(struct runtime_p * a1);
void runtime_releaseSudog(struct runtime_sudog * s);
void runtime_resetspinning(void);
void runtime_resolveNameOff(char * ptrInModule, int32_t off, struct runtime_name a3);
void runtime_resolveTypeOff(char * ptrInModule, int32_t off, struct runtime__type * a3);
void runtime_return0(void);
void runtime_round2(int32_t x, int32_t a2);
void runtime_rt0_go(void);
void runtime_rt_sigaction(void);
void runtime_rtsigprocmask(void);
void runtime_runGCProg(char * prog, char * trailer, char * dst, int32_t size, int32_t a5);
void runtime_runqempty(struct runtime_p * _p_, bool a2);
void runtime_runqget(struct runtime_p * _p_, struct runtime_g * gp, bool inheritTime);
void runtime_runqgrab(struct runtime_p * _p_, int32_t (*batch)[1], int32_t batchHead, bool stealRunNextG, int32_t a5);
void runtime_runqput(struct runtime_p * _p_, struct runtime_g * gp, bool next);
void runtime_runqputslow(struct runtime_p * _p_, struct runtime_g * gp, int32_t h, int32_t t, bool a5);
void runtime_runqsteal(struct runtime_p * _p_, struct runtime_p * p2, bool stealRunNextG, struct runtime_g * a4);
void runtime_runSafePointFn(void);
void runtime_save(int32_t pc, int32_t sp);
void runtime_saveblockevent(int64_t cycles, int32_t skip, int32_t which);
void runtime_sbrk0(void);
void runtime_scanblock(int32_t b0, int32_t n0, char * ptrmask, struct runtime_gcWork * gcw);
void runtime_scanobject(int32_t b, struct runtime_gcWork * gcw);
void runtime_scanstack(struct runtime_g * gp, struct runtime_gcWork * gcw);
void runtime_scanstack_func1(struct runtime_stkframe * frame, char * unused, bool a3);
void runtime_sched_getaffinity(void);
void runtime_schedinit(void);
void runtime_schedule(void);
void runtime_semacquire(int32_t * addr);
void runtime_semacquire1(int32_t * addr, bool lifo, int32_t profile);
void runtime_semrelease(int32_t * addr);
void runtime_semrelease1(int32_t * addr, bool handoff);
void runtime_setGCPhase(int32_t x);
void runtime_setitimer(void);
void runtime_setldt(void);
void runtime_setsig(int32_t i, int32_t fn);
void runtime_setsigstack(int32_t i);
void runtime_setThreadCPUProfiler(int32_t hz);
void runtime_showframe(struct runtime_funcInfo f, struct runtime_g * gp, bool firstFrame, bool a4);
void runtime_shrinkstack(struct runtime_g * gp);
void runtime_sigaltstack(void);
void runtime_sighandler(int32_t sig, struct runtime_siginfo * info, char * ctxt, struct runtime_g * gp);
void runtime_sigInstallGoHandler(int32_t sig, bool a2);
void runtime_signalstack(struct runtime_stack * s);
void runtime_sigprocmask(int32_t how, int32_t (*new)[1], int32_t (*old)[1]);
void runtime_sigreturn(void);
void runtime_slicebytetostring(char (*buf)[1], struct _lsb__rsb_uint8 b, struct string str);
void runtime_slowdodiv(int64_t n, int64_t d, int64_t q, int64_t r);
void runtime_stackalloc(int32_t n, struct runtime_stack a2);
void runtime_stackcache_clear(struct runtime_mcache * c);
void runtime_stackcacherefill(struct runtime_mcache * c, char order);
void runtime_stackcacherelease(struct runtime_mcache * c, char order);
void runtime_stackcheck(void);
void runtime_stackfree(struct runtime_stack stk);
void runtime_stackinit(void);
void runtime_stacklog2(int32_t n, int32_t a2);
void runtime_stackpoolalloc(char order, int32_t a2);
void runtime_stackpoolfree(int32_t x, char order);
void runtime_startlockedm(struct runtime_g * gp);
void runtime_startm(struct runtime_p * _p_, bool spinning);
void runtime_startpanic(void);
void runtime_step(struct _lsb__rsb_uint8 p, int32_t * pc, int32_t * val, bool first, struct _lsb__rsb_uint8 newp, bool ok);
void runtime_stkbucket(int32_t typ, int32_t size, struct _lsb__rsb_uintptr stk, bool alloc, struct runtime_bucket * a5);
void runtime_stoplockedm(void);
void runtime_stopm(void);
void runtime_syncadjustsudogs(struct runtime_g * gp, int32_t used, struct runtime_adjustinfo * adjinfo, int32_t a4);
void runtime_sysAlloc(int32_t n, int64_t * sysStat, char * a3);
void runtime_sysargs(int32_t argc, char ** argv);
void runtime_sysauxv(struct _lsb__rsb_uintptr auxv, int32_t a2);
void runtime_sysFault(char * v, int32_t n);
void runtime_sysFree(char * v, int32_t n, int64_t * sysStat);
void runtime_sysMap(char * v, int32_t n, bool reserved, int64_t * sysStat);
void runtime_sysReserve(char * v, int32_t n, bool * reserved, char * a4);
void runtime_systemstack(void);
void runtime_sysUsed(char * v, int32_t n);
void runtime_testAtomic64(void);
void runtime_testdefersizes(void);
void runtime_throw(struct string s);
void runtime_timediv(int64_t v, uint32_t div, int32_t * rem, int32_t a4);
void runtime_timejump(struct runtime_g * a1);
void runtime_traceAcquireBuffer(struct runtime_m * mp, int32_t pid, int32_t * bufp);
void runtime_tracealloc(char * p, int32_t size, struct runtime__type * typ);
void runtime_tracealloc_func1(void);
void runtime_traceback(int32_t pc, int32_t sp, int32_t lr, struct runtime_g * gp);
void runtime_traceback1(int32_t pc, int32_t sp, int32_t lr, struct runtime_g * gp, int32_t flags);
void runtime_tracebackCgoContext(int32_t * pcbuf, bool printing, int32_t ctxt, int32_t n, int32_t max, int32_t a6);
void runtime_tracebackdefers(struct runtime_g * gp, void (*callback)(struct runtime_stkframe *, char *, bool *), char * v);
void runtime_tracebackinit(void);
void runtime_traceEvent(char ev, int32_t skip, struct _lsb__rsb_uint64 args);
void runtime_traceFlush(int32_t buf, int32_t a2);
void runtime_traceGCDone(void);
void runtime_traceGCMarkAssistDone(void);
void runtime_traceGCMarkAssistStart(void);
void runtime_traceGCScanDone(void);
void runtime_traceGCScanStart(void);
void runtime_traceGCStart(void);
void runtime_traceGomaxprocs(int32_t procs);
void runtime_traceGoPreempt(void);
void runtime_traceGoSched(void);
void runtime_traceGoStart(void);
void runtime_traceGoSysExit(int64_t ts);
void runtime_traceGoUnpark(struct runtime_g * gp, int32_t skip);
void runtime_traceNextGC(void);
void runtime_traceProcFree(struct runtime_p * pp);
void runtime_traceProcStart(void);
void runtime_traceProcStop(struct runtime_p * pp);
void runtime_traceReader(struct runtime_g * a1);
void runtime_traceReleaseBuffer(int32_t pid);
void runtime_traceStackID(struct runtime_m * mp, struct _lsb__rsb_uintptr buf, int32_t skip, int64_t a4);
void runtime_trygetfull(struct runtime_workbuf * a1);
void runtime_typedmemclr(struct runtime__type * typ, char * ptr);
void runtime_typedmemmove(struct runtime__type * typ, char * dst, char * src);
void runtime_typelinksinit(void);
void runtime_typesEqual(struct runtime__type * t, struct runtime__type * v, struct hash_lt_runtime__typePair_comma_struct___gt_ * seen, bool a4);
void runtime_typestring(struct runtime_eface x, struct string a2);
void runtime_uint32tofloat64(void);
void runtime_uint64div(int64_t n, int64_t d, int64_t a3);
void runtime_uint64mod(int64_t n, int64_t d, int64_t a3);
void runtime_uint64tofloat64(int64_t y, float64_t a2);
void runtime_unlock(struct runtime_mutex * l);
void runtime_unlockextra(struct runtime_m * mp);
void runtime_usleep(void);
void runtime_wakefing(struct runtime_g * a1);
void runtime_wakep(void);
void runtime_walltime(void);
void runtime_write(void);
void runtime_writebarrierptr(int32_t * dst, int32_t src);
void runtime_writebarrierptr_func1(void);
void runtime_writebarrierptr_prewrite(int32_t * dst, int32_t src);
void runtime_writebarrierptr_prewrite1(int32_t * dst, int32_t src);
void runtime_writebarrierptr_prewrite1_func1(void);
void runtime_writeErr(struct _lsb__rsb_uint8 b);
void setg_gcc(void);
void sync_event(int64_t cycles, int32_t skip);
void time_now(int64_t sec, int32_t nsec, int64_t mono);
int32_t unknown_80495a1(void);
int32_t unknown_808f617(void);
int32_t unknown_808fa32(void);
int32_t unknown_808fa5e(void);
int32_t unknown_808fa74(void);
int32_t unknown_808fa98(void);
int32_t unknown_808fa9d(void);
int32_t unknown_80905c3(void);
int32_t unknown_8090617(void);
int32_t unknown_809061a(void);
int32_t unknown_809068a(void);
int32_t unknown_b617fa04(void);

// --------------------- Global Variables ---------------------

bool g1 = false; // cf
int32_t g2 = 0; // eax
int32_t g3 = 0; // ebp
int32_t g4 = 0; // ebx
int32_t g5 = 0; // ecx
bool g6 = false; // edf
int32_t g7 = 0; // edi
int32_t g8 = 0; // edx
int32_t g9 = 0; // esi
int32_t g10 = 0; // esp
struct runtime_g * g11 = (struct runtime_g *)0x605d090a; // 0x80e0d9c
int64_t g12 = 0x6343203a35323e2d; // 0x80e0db7
int32_t g13 = 0x206e202c; // 0x80e0eba
char * g14 = "\x63\x74\x78\x74\x20\x21\x3d\x20\x30\x66\x75\x6e\x63\x61\x72\x67\x73\x28\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x6e\x65\x77\x6f\x73\x70\x72\x6f\x63\x70\x61\x6e\x69\x63\x77\x61\x69\x74\x72\x65\x63\x6f\x76\x65\x72\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x3d\x73\x69\x67\x6e\x61\x6c\x20\x33\x32\x73\x69\x67\x6e\x61\x6c\x20\x33\x33\x73\x69\x67\x6e\x61\x6c\x20\x33\x34\x73\x69\x67\x6e\x61\x6c\x20\x33\x35\x73\x69\x67\x6e\x61\x6c\x20\x33\x36\x73\x69\x67\x6e\x61\x6c\x20\x33\x37\x73\x69\x67\x6e\x61\x6c\x20\x33\x38\x73\x69\x67\x6e\x61\x6c\x20\x33\x39\x73\x69\x67\x6e\x61\x6c\x20\x34\x30\x73\x69\x67\x6e\x61\x6c\x20\x34\x31\x73\x69\x67\x6e\x61\x6c\x20\x34\x32\x73\x69\x67\x6e\x61\x6c\x20\x34\x33\x73\x69\x67\x6e\x61\x6c\x20\x34\x34\x73\x69\x67\x6e\x61\x6c\x20\x34\x35\x73\x69\x67\x6e\x61\x6c\x20\x34\x36\x73\x69\x67\x6e\x61\x6c\x20\x34\x37\x73\x69\x67\x6e\x61\x6c\x20\x34\x38\x73\x69\x67\x6e\x61\x6c\x20\x34\x39\x73\x69\x67\x6e\x61\x6c\x20\x35\x30\x73\x69\x67\x6e\x61\x6c\x20\x35\x31\x73\x69\x67\x6e\x61\x6c\x20\x35\x32\x73\x69\x67\x6e\x61\x6c\x20\x35\x33\x73\x69\x67\x6e\x61\x6c\x20\x35\x34\x73\x69\x67\x6e\x61\x6c\x20\x35\x35\x73\x69\x67\x6e\x61\x6c\x20\x35\x36\x73\x69\x67\x6e\x61\x6c\x20\x35\x37\x73\x69\x67\x6e\x61\x6c\x20\x35\x38\x73\x69\x67\x6e\x61\x6c\x20\x35\x39\x73\x69\x67\x6e\x61\x6c\x20\x36\x30\x73\x69\x67\x6e\x61\x6c\x20\x36\x31\x73\x69\x67\x6e\x61\x6c\x20\x36\x32\x73\x69\x67\x6e\x61\x6c\x20\x36\x33\x73\x69\x67\x6e\x61\x6c\x20\x36\x34\x20\x4d\x42\x20\x67\x6f\x61\x6c\x2c\x20\x20\x61\x63\x74\x75\x61\x6c\xce\x94\x3d\x20\x67\x66\x72\x65\x65\x63\x6e\x74\x3d\x20\x70\x61\x67\x65\x73\x20\x61\x74\x20\x20\x72\x65\x74\x75\x72\x6e\x65\x64\x20\x20\x72\x75\x6e\x71\x73\x69\x7a\x65\x3d\x20\x72\x75\x6e\x71\x75\x65\x75\x65\x3d\x20\x73\x2e\x62\x61\x73\x65\x28\x29\x3d\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x3d\x20\x73\x74\x6f\x70\x77\x61\x69\x74\x3d\x20\x73\x77\x65\x65\x70\x67\x65\x6e\x20\x20\x73\x77\x65\x65\x70\x67\x65\x6e\x3d\x20\x74\x61\x72\x67\x65\x74\x70\x63\x3d\x20\x74\x68\x72\x6f\x77\x69\x6e\x67\x3d\x20\x75\x6e\x74\x69\x6c\x20\x70\x63\x3d\x2f\x64\x65\x76\x2f\x73\x74\x64\x69\x6e\x31\x32\x32\x30\x37\x30\x33\x31\x32\x35\x36\x31\x30\x33\x35\x31\x35\x36\x32\x35\x44\x65\x70\x72\x65\x63\x61\x74\x65\x64\x44\x65\x76\x61\x6e\x61\x67\x61\x72\x69\x47\x4f\x4d\x41\x58\x50\x52\x4f\x43\x53\x47\x6c\x61\x67\x6f\x6c\x69\x74\x69\x63\x4b\x68\x61\x72\x6f\x73\x68\x74\x68\x69\x4d\x61\x6e\x69\x63\x68\x61\x65\x61\x6e\x4f\x6c\x64\x5f\x49\x74\x61\x6c\x69\x63\x4f\x6c\x64\x5f\x50\x65\x72\x6d\x69\x63\x4f\x6c\x64\x5f\x54\x75\x72\x6b\x69\x63\x4f\x74\x68\x65\x72\x5f\x4d\x61\x74\x68\x50\x68\x6f\x65\x6e\x69\x63\x69\x61\x6e\x53\x61\x75\x72\x61\x73\x68\x74\x72\x61\x5f\x4d\x53\x70\x61\x6e\x44\x65\x61\x64\x5f\x4d\x53\x70\x61\x6e\x46\x72\x65\x65\x61\x74\x6f\x6d\x69\x63\x61\x6e\x64\x38\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x63\x6f\x6d\x70\x6c\x65\x78\x31\x32\x38\x66\x6c\x6f\x61\x74\x33\x32\x6e\x61\x6e\x66\x6c\x6f\x61\x74\x36\x34\x6e\x61\x6e\x67\x63\x73\x63\x61\x6e\x64\x6f\x6e\x65\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x69\x6e\x76\x61\x6c\x69\x64\x70\x74\x72\x6f\x77\x6e\x65\x72\x20\x64\x69\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x73\x63\x68\x65\x64\x74\x72\x61\x63\x65\x73\x65\x6d\x61\x63\x71\x75\x69\x72\x65\x74\x72\x61\x63\x65\x66\x72\x65\x65\x28\x74\x72\x61\x63\x65\x67\x63\x28\x29\x0a\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x70\x63\x20\x28\x74\x61\x72\x67\x65\x74\x70\x63\x3d\x20\x67\x63\x77\x61\x69\x74\x69\x6e\x67\x3d\x20\x67\x70\x2e\x73\x74\x61\x74\x75\x73\x3d\x20\x68\x65\x61\x70\x5f\x6c\x69\x76\x65\x3d\x20\x69\x64\x6c\x65\x70\x72\x6f\x63\x73\x3d\x20\x69\x6e\x20\x73\x74\x61\x74\x75\x73\x20\x20\x6d\x2d\x3e\x6d\x63\x61\x63\x68\x65\x3d\x20\x6d\x61\x6c\x6c\x6f\x63\x69\x6e\x67\x3d\x20\x6d\x73\x20\x63\x6c\x6f\x63\x6b\x2c\x20\x20\x70\x2d\x3e\x6d\x63\x61\x63\x68\x65\x3d\x20\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x3d\x20\x73\x63\x68\x65\x64\x74\x69\x63\x6b\x3d\x20\x73\x70\x61\x6e\x2e\x6c\x69\x73\x74\x3d\x2f\x64\x65\x76\x2f\x73\x74\x64\x65\x72\x72\x2f\x64\x65\x76\x2f\x73\x74\x64\x6f\x75\x74\x33\x30\x35\x31\x37\x35\x37\x38\x31\x32\x35\x3a\x20\x66\x72\x61\x6d\x65\x2e\x73\x70\x3d\x47\x4f\x54\x52\x41\x43\x45\x42\x41\x43\x4b\x49\x64\x65\x6f\x67\x72\x61\x70\x68\x69\x63\x4e\x65\x77\x5f\x54\x61\x69\x5f\x4c\x75\x65\x4f\x6c\x64\x5f\x50\x65\x72\x73\x69\x61\x6e\x50\x61\x75\x5f\x43\x69\x6e\x5f\x48\x61\x75\x53\x69\x67\x6e\x57\x72\x69\x74\x69\x6e\x67\x53\x6f\x66\x74\x5f\x44\x6f\x74\x74\x65\x64\x57\x61\x72\x61\x6e\x67\x5f\x43\x69\x74\x69\x57\x68\x69\x74\x65\x5f\x53\x70\x61\x63\x65\x09\x73\x63\x68\x65\x64\x3d\x7b\x70\x63\x3a\x5f\x4d\x53\x70\x61\x6e\x49\x6e\x55\x73\x65\x62\x61\x64\x20\x61\x64\x64\x72\x65\x73\x73\x62\x61\x64\x20\x6d\x65\x73\x73\x61\x67\x65\x62\x61\x64\x20\x74\x69\x6d\x65\x64\x69\x76\x62\x72\x6f\x6b\x65\x6e\x20\x70\x69\x70\x65\x63\x67\x6f\x63\x61\x6c\x6c\x20\x6e\x69\x6c\x63\x72\x65\x61\x74\x65\x64\x20\x62\x79\x20\x66\x61\x69\x6c\x65\x64\x20\x77\x69\x74\x68\x66\x69\x6c\x65\x20\x65\x78\x69\x73\x74\x73\x66\x6c\x6f\x61\x74\x33\x32\x6e\x61\x6e\x32\x66\x6c\x6f\x61\x74\x36\x34\x6e\x61\x6e\x31\x66\x6c\x6f\x61\x74\x36\x34\x6e\x61\x6e\x32\x66\x6c\x6f\x61\x74\x36\x34\x6e\x61\x6e\x33\x67\x63\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x67\x63\x73\x63\x61\x6e\x76\x61\x6c\x69\x64\x68\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64\x69\x2f\x6f\x20\x74\x69\x6d\x65\x6f\x75\x74\x6c\x6f\x73\x74\x20\x6d\x63\x61\x63\x68\x65\x6d\x65\x74\x68\x6f\x64\x61\x72\x67\x73\x28\x73\x63\x68\x65\x64\x64\x65\x74\x61\x69\x6c\x73\x68\x6f\x72\x74\x20\x77\x72\x69\x74\x65\x74\x72\x61\x63\x65\x61\x6c\x6c\x6f\x63\x28\x75\x6e\x72\x65\x61\x63\x68\x61\x62\x6c\x65\x77\x6f\x72\x6b\x2e\x6e\x70\x72\x6f\x63\x3d\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x3d\x20\x5b\x72\x65\x63\x6f\x76\x65\x72\x65\x64\x5d\x20\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x20\x66\x6f\x75\x6e\x64\x20\x61\x74\x20\x2a\x28\x20\x6d\x2d\x3e\x67\x73\x69\x67\x6e\x61\x6c\x3d\x20\x6d\x69\x6e\x54\x72\x69\x67\x67\x65\x72\x3d\x20\x70\x61\x67\x65\x73\x2f\x62\x79\x74\x65\x0a\x20\x70\x72\x65\x65\x6d\x70\x74\x6f\x66\x66\x3d\x20\x73\x2e\x65\x6c\x65\x6d\x73\x69\x7a\x65\x3d\x20\x73\x2e\x73\x77\x65\x65\x70\x67\x65\x6e\x3d\x20\x73\x70\x61\x6e\x2e\x6c\x69\x6d\x69\x74\x3d\x20\x73\x70\x61\x6e\x2e\x73\x74\x61\x74\x65\x3d\x20\x73\x79\x73\x6d\x6f\x6e\x77\x61\x69\x74\x3d\x29\x20\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x3d\x2c\x20\x63\x6f\x6e\x73\x75\x6d\x65\x64\x3a\x20\x2c\x20\x72\x65\x6c\x65\x61\x73\x65\x64\x3a\x20\x2d\x62\x79\x74\x65\x20\x6c\x69\x6d\x69\x74\x0a\x31\x35\x32\x35\x38\x37\x38\x39\x30\x36\x32\x35\x37\x36\x32\x39\x33\x39\x34\x35\x33\x31\x32\x35\x42\x69\x64\x69\x5f\x43\x6f\x6e\x74\x72\x6f\x6c\x4a\x6f\x69\x6e\x5f\x43\x6f\x6e\x74\x72\x6f\x6c\x4d\x65\x65\x74\x65\x69\x5f\x4d\x61\x79\x65\x6b\x50\x61\x68\x61\x77\x68\x5f\x48\x6d\x6f\x6e\x67\x53\x6f\x72\x61\x5f\x53\x6f\x6d\x70\x65\x6e\x67\x53\x79\x6c\x6f\x74\x69\x5f\x4e\x61\x67\x72\x69\x5f\x4d\x53\x70\x61\x6e\x4d\x61\x6e\x75\x61\x6c\x61\x62\x69\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x62\x61\x64\x20\x67\x20\x73\x74\x61\x74\x75\x73\x62\x61\x64\x20\x70\x61\x67\x65\x73\x69\x7a\x65\x62\x61\x64\x20\x72\x65\x63\x6f\x76\x65\x72\x79\x62\x75\x74\x20\x70\x72\x6f\x67\x53\x69\x7a\x65\x63\x61\x6e\x27\x74\x20\x68\x61\x70\x70\x65\x6e\x63\x61\x73\x36\x34\x20\x66\x61\x69\x6c\x65\x64\x63\x68\x61\x6e\x20\x72\x65\x63\x65\x69\x76\x65\x65\x6e\x64\x20\x74\x72\x61\x63\x65\x67\x63\x0a\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x67\x63\x70\x61\x63\x65\x72\x74\x72\x61\x63\x65\x68\x6f\x73\x74\x20\x69\x73\x20\x64\x6f\x77\x6e\x69\x6c\x6c\x65\x67\x61\x6c\x20\x73\x65\x65\x6b\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x6c\x6f\x74\x6c\x66\x73\x74\x61\x63\x6b\x2e\x70\x75\x73\x68\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x6c\x65\x61\x73\x65\x70\x3a\x20\x6d\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x70\x3d\x73\x68\x6f\x72\x74\x20\x62\x75\x66\x66\x65\x72\x74\x2e\x6e\x70\x61\x67\x65\x73\x4b\x65\x79\x3d\x20\x4d\x42\x20\x72\x65\x6c\x65\x61\x73\x65\x64\x0a\x20\x63\x61\x6c\x6c\x65\x64\x20\x66\x72\x6f\x6d\x20\x20\x68\x65\x61\x70\x5f\x6d\x61\x72\x6b\x65\x64\x3d\x20\x69\x64\x6c\x65\x74\x68\x72\x65\x61\x64\x73\x3d\x20\x69\x73\x20\x6e\x69\x6c\x2c\x20\x6e\x6f\x74\x20\x20\x73\x2e\x73\x70\x61\x6e\x63\x6c\x61\x73\x73\x3d\x20\x73\x70\x61\x6e\x2e\x62\x61\x73\x65\x28\x29\x3d\x20\x73\x79\x73\x63\x61\x6c\x6c\x74\x69\x63\x6b\x3d\x20\x77\x69\x74\x68\x20\x47\x43\x20\x70\x72\x6f\x67\x2c\x20\x67\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x3d\x2c\x20\x6e\x6f\x74\x20\x70\x6f\x69\x6e\x74\x65\x72\x2d\x62\x79\x74\x65\x20\x62\x6c\x6f\x63\x6b\x20\x28\x2f\x75\x73\x72\x2f\x6c\x6f\x63\x61\x6c\x2f\x67\x6f\x33\x38\x31\x34\x36\x39\x37\x32\x36\x35\x36\x32\x35\x47\x43\x20\x73\x77\x65\x65\x70\x20\x77\x61\x69\x74\x4d\x65\x6e\x64\x65\x5f\x4b\x69\x6b\x61\x6b\x75\x69\x4f\x6c\x64\x5f\x48\x75\x6e\x67\x61\x72\x69\x61\x6e\x53\x49\x47\x4b\x49\x4c\x4c\x3a\x20\x6b\x69\x6c\x6c\x53\x49\x47\x51\x55\x49\x54\x3a\x20\x71\x75\x69\x74\x09\x6d\x6f\x72\x65\x62\x75\x66\x3d\x7b\x70\x63\x3a\x62\x61\x64\x20\x68\x6d\x61\x70\x20\x73\x69\x7a\x65\x62\x61\x64\x20\x6d\x61\x70\x20\x73\x74\x61\x74\x65\x65\x78\x63\x68\x61\x6e\x67\x65\x20\x66\x75\x6c\x6c\x66\x61\x74\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x6c\x65\x76\x65\x6c\x20\x33\x20\x72\x65\x73\x65\x74\x6c\x6f\x61\x64\x36\x34\x20\x66\x61\x69\x6c\x65\x64\x6e\x69\x6c\x20\x73\x74\x61\x63\x6b\x62\x61\x73\x65\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x3d\x73\x72\x6d\x6f\x75\x6e\x74\x20\x65\x72\x72\x6f\x72\x73\x74\x69\x6c\x6c\x20\x69\x6e\x20\x6c\x69\x73\x74\x74\x69\x6d\x65\x72\x20\x65\x78\x70\x69\x72\x65\x64\x74\x72\x69\x67\x67\x65\x72\x52\x61\x74\x69\x6f\x3d\x75\x6e\x72\x65\x61\x63\x68\x61\x62\x6c\x65\x3a\x20\x76\x61\x6c\x75\x65\x20\x6d\x65\x74\x68\x6f\x64\x20\x78\x61\x64\x64\x36\x34\x20\x66\x61\x69\x6c\x65\x64\x78\x63\x68\x67\x36\x34\x20\x66\x61\x69\x6c\x65\x64\x20\x6e\x6d\x69\x64\x6c\x65\x6c\x6f\x63\x6b\x65\x64\x3d\x20\x6f\x6e\x20\x7a\x65\x72\x6f\x20\x56\x61\x6c\x75\x65\x20\x74\x6f\x20\x66\x69\x6e\x61\x6c\x69\x7a\x65\x72\x20\x20\x75\x6e\x74\x79\x70\x65\x64\x20\x61\x72\x67\x73\x20\x2d\x74\x68\x72\x65\x61\x64\x20\x6c\x69\x6d\x69\x74\x0a\x2f\x70\x72\x6f\x63\x2f\x73\x65\x6c\x66\x2f\x65\x78\x65\x31\x39\x30\x37\x33\x34\x38\x36\x33\x32\x38\x31\x32\x35\x39\x35\x33\x36\x37\x34\x33\x31\x36\x34\x30\x36\x32\x35\x47\x43\x20\x61\x73\x73\x69\x73\x74\x20\x77\x61\x69\x74\x47\x43\x20\x77\x6f\x72\x6b\x65\x72\x20\x69\x6e\x69\x74\x4d\x42\x3b\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x4f\x74\x68\x65\x72\x5f\x49\x44\x5f\x53\x74\x61\x72\x74\x50\x61\x74\x74\x65\x72\x6e\x5f\x53\x79\x6e\x74\x61\x78\x51\x75\x6f\x74\x61\x74\x69\x6f\x6e\x5f\x4d\x61\x72\x6b\x53\x49\x47\x41\x42\x52\x54\x3a\x20\x61\x62\x6f\x72\x74\x61\x6c\x6c\x6f\x63\x66\x72\x65\x65\x74\x72\x61\x63\x65\x62\x61\x64\x20\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x62\x61\x64\x20\x73\x74\x61\x63\x6b\x20\x73\x69\x7a\x65\x66\x69\x6c\x65\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x66\x69\x6e\x61\x6c\x69\x7a\x65\x72\x20\x77\x61\x69\x74\x67\x63\x72\x65\x73\x63\x61\x6e\x73\x74\x61\x63\x6b\x73\x67\x63\x73\x74\x6f\x70\x74\x68\x65\x77\x6f\x72\x6c\x64\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x79\x6e\x74\x61\x78\x69\x73\x20\x61\x20\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x6b\x65\x79\x20\x73\x69\x7a\x65\x20\x77\x72\x6f\x6e\x67\x6c\x65\x76\x65\x6c\x20\x32\x20\x68\x61\x6c\x74\x65\x64\x6c\x65\x76\x65\x6c\x20\x33\x20\x68\x61\x6c\x74\x65\x64\x6d\x65\x6d\x70\x72\x6f\x66\x69\x6c\x65\x72\x61\x74\x65\x6e\x69\x6c\x20\x65\x6c\x65\x6d\x20\x74\x79\x70\x65\x21\x6e\x6f\x20\x6d\x6f\x64\x75\x6c\x65\x20\x64\x61\x74\x61\x6e\x6f\x20\x73\x75\x63\x68\x20\x64\x65\x76\x69\x63\x65\x6e\x6f\x74\x20\x69\x6e\x20\x72\x61\x6e\x67\x65\x73\x3a\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x65\x72\x72\x6f\x72\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x73\x65\x20\x73\x65\x6d\x61\x52\x6f\x6f\x74\x20\x71\x75\x65\x75\x65\x73\x74\x61\x63\x6b\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x73\x74\x6f\x70\x6d\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x73\x74\x6f\x72\x65\x36\x34\x20\x66\x61\x69\x6c\x65\x64\x74\x65\x78\x74\x20\x66\x69\x6c\x65\x20\x62\x75\x73\x79\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6c\x69\x6e\x6b\x73\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x75\x73\x65\x72\x73\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x45\x4f\x46\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x6d\x65\x74\x68\x6f\x64\x75\x6e\x73\x61\x66\x65\x2e\x50\x6f\x69\x6e\x74\x65\x72\x77\x6f\x72\x6b\x2e\x66\x75\x6c\x6c\x20\x21\x3d\x20\x30\x20\x6e\x6f\x74\x20\x69\x6e\x20\x72\x61\x6e\x67\x65\x20\x5b\x2c\x20\x74\x2e\x68\x6d\x61\x70\x2e\x73\x69\x7a\x65\x20\x3d\x34\x37\x36\x38\x33\x37\x31\x35\x38\x32\x30\x33\x31\x32\x35\x3c\x69\x6e\x76\x61\x6c\x69\x64\x20\x56\x61\x6c\x75\x65\x3e\x41\x53\x43\x49\x49\x5f\x48\x65\x78\x5f\x44\x69\x67\x69\x74\x4f\x74\x68\x65\x72\x5f\x4c\x6f\x77\x65\x72\x63\x61\x73\x65\x4f\x74\x68\x65\x72\x5f\x55\x70\x70\x65\x72\x63\x61\x73\x65\x50\x73\x61\x6c\x74\x65\x72\x5f\x50\x61\x68\x6c\x61\x76\x69\x61\x63\x71\x75\x69\x72\x65\x70\x3a\x20\x70\x2d\x3e\x6d\x3d\x61\x64\x76\x65\x72\x74\x69\x73\x65\x20\x65\x72\x72\x6f\x72\x66\x6f\x72\x63\x65\x20\x67\x63\x20\x28\x69\x64\x6c\x65\x29\x6b\x65\x79\x20\x68\x61\x73\x20\x65\x78\x70\x69\x72\x65\x64\x6d\x61\x6c\x6c\x6f\x63\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x6d\x69\x73\x73\x69\x6e\x67\x20\x6d\x63\x61\x63\x68\x65\x3f\x6d\x73\x3a\x20\x67\x6f\x6d\x61\x78\x70\x72\x6f\x63\x73\x3d\x6e\x65\x74\x77\x6f\x72\x6b\x20\x69\x73\x20\x64\x6f\x77\x6e\x6e\x6f\x20\x6d\x65\x64\x69\x75\x6d\x20\x66\x6f\x75\x6e\x64\x6e\x6f\x20\x73\x75\x63\x68\x20\x70\x72\x6f\x63\x65\x73\x73\x6e\x6f\x6e\x2d\x47\x6f\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x6e\x6f\x74\x20\x61\x20\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x72\x65\x63\x6f\x76\x65\x72\x79\x20\x66\x61\x69\x6c\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x20\x65\x72\x72\x6f\x72\x3a\x20\x72\x75\x6e\x74\x69\x6d\x65\x2e\x67\x6f\x70\x61\x6e\x69\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x72\x61\x6d\x65\x20\x73\x63\x61\x6e\x20\x6d\x69\x73\x73\x65\x64\x20\x61\x20\x67\x73\x74\x61\x72\x74\x6d\x3a\x20\x6d\x20\x68\x61\x73\x20\x70\x73\x74\x6f\x70\x6d\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x70\x20\x61\x6c\x72\x65\x61\x64\x79\x3b\x20\x65\x72\x72\x6e\x6f\x3d\x20\x62\x75\x74\x20\x6d\x65\x6d\x6f\x72\x79\x20\x73\x69\x7a\x65\x20\x6d\x68\x65\x61\x70\x2e\x73\x77\x65\x65\x70\x67\x65\x6e\x3d\x20\x75\x6e\x74\x79\x70\x65\x64\x20\x6c\x6f\x63\x61\x6c\x73\x20\x2c\x20\x6e\x6f\x74\x20\x61\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65\x66\x32\x33\x38\x34\x31\x38\x35\x37\x39\x31\x30\x31\x35\x36\x32\x35\x3a\x20\x76\x61\x6c\x75\x65\x20\x6f\x66\x20\x74\x79\x70\x65\x20\x47\x43\x20\x77\x6f\x72\x6b\x65\x72\x20\x28\x69\x64\x6c\x65\x29\x49\x6d\x70\x65\x72\x69\x61\x6c\x5f\x41\x72\x61\x6d\x61\x69\x63\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x52\x65\x6d\x6f\x76\x65\x4d\x65\x72\x6f\x69\x74\x69\x63\x5f\x43\x75\x72\x73\x69\x76\x65\x4f\x74\x68\x65\x72\x5f\x41\x6c\x70\x68\x61\x62\x65\x74\x69\x63\x53\x49\x47\x4e\x4f\x4e\x45\x3a\x20\x6e\x6f\x20\x74\x72\x61\x70\x0a\x72\x75\x6e\x74\x69\x6d\x65\x20\x73\x74\x61\x63\x6b\x3a\x0a\x62\x61\x64\x20\x73\x70\x65\x63\x69\x61\x6c\x20\x6b\x69\x6e\x64\x62\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x63\x61\x73\x74\x6f\x67\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x67\x63\x3a\x20\x75\x6e\x73\x77\x65\x70\x74\x20\x73\x70\x61\x6e\x67\x63\x73\x68\x72\x69\x6e\x6b\x73\x74\x61\x63\x6b\x6f\x66\x66\x69\x6e\x74\x65\x67\x65\x72\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x69\x6e\x76\x61\x6c\x69\x64\x20\x65\x78\x63\x68\x61\x6e\x67\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x70\x64\x65\x6c\x74\x61\x20\x6d\x65\x73\x73\x61\x67\x65\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x6d\x61\x70\x6e\x6f\x20\x72\x6f\x75\x74\x65\x20\x74\x6f\x20\x68\x6f\x73\x74\x6f\x62\x6a\x65\x63\x74\x20\x69\x73\x20\x72\x65\x6d\x6f\x74\x65\x70\x61\x63\x65\x72\x3a\x20\x48\x5f\x6d\x5f\x70\x72\x65\x76\x3d\x72\x65\x66\x6c\x65\x63\x74\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x72\x65\x6d\x6f\x74\x65\x20\x49\x2f\x4f\x20\x65\x72\x72\x6f\x72\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x20\x67\x3a\x20\x20\x67\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x70\x3a\x20\x67\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x61\x6d\x65\x4f\x66\x66\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x6c\x65\x6d\x73\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x65\x78\x74\x4f\x66\x66\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x4f\x66\x66\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x5b\x30\x2d\x39\x5d\x2a\x74\x6f\x20\x6e\x6f\x6e\x2d\x47\x6f\x20\x6d\x65\x6d\x6f\x72\x79\x76\x61\x6c\x75\x65\x20\x73\x69\x7a\x65\x20\x77\x72\x6f\x6e\x67\x77\x6f\x72\x6b\x62\x75\x66\x20\x69\x73\x20\x65\x6d\x70\x74\x79\x20\x69\x6e\x69\x74\x69\x61\x6c\x48\x65\x61\x70\x4c\x69\x76\x65\x3d\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x74\x68\x72\x65\x61\x64\x73\x3d\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46\x58\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65\x66\x78\x31\x31\x39\x32\x30\x39\x32\x38\x39\x35\x35\x30\x37\x38\x31\x32\x35\x35\x39\x36\x30\x34\x36\x34\x34\x37\x37\x35\x33\x39\x30\x36\x32\x35\x3a\x20\x6d\x69\x73\x73\x69\x6e\x67\x20\x6d\x65\x74\x68\x6f\x64\x20\x47\x43\x20\x61\x73\x73\x69\x73\x74\x20\x6d\x61\x72\x6b\x69\x6e\x67\x4f\x6c\x64\x5f\x4e\x6f\x72\x74\x68\x5f\x41\x72\x61\x62\x69\x61\x6e\x4f\x6c\x64\x5f\x53\x6f\x75\x74\x68\x5f\x41\x72\x61\x62\x69\x61\x6e\x4f\x74\x68\x65\x72\x5f\x49\x44\x5f\x43\x6f\x6e\x74\x69\x6e\x75\x65\x53\x49\x47\x42\x55\x53\x3a\x20\x62\x75\x73\x20\x65\x72\x72\x6f\x72\x53\x49\x47\x43\x4f\x4e\x54\x3a\x20\x63\x6f\x6e\x74\x69\x6e\x75\x65\x53\x49\x47\x49\x4e\x54\x3a\x20\x69\x6e\x74\x65\x72\x72\x75\x70\x74\x53\x65\x6e\x74\x65\x6e\x63\x65\x5f\x54\x65\x72\x6d\x69\x6e\x61\x6c\x55\x6e\x69\x66\x69\x65\x64\x5f\x49\x64\x65\x6f\x67\x72\x61\x70\x68\x62\x61\x64\x20\x54\x69\x6e\x79\x53\x69\x7a\x65\x43\x6c\x61\x73\x73\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x62\x6c\x6f\x63\x6b\x65\x78\x65\x63\x20\x66\x6f\x72\x6d\x61\x74\x20\x65\x72\x72\x6f\x72\x66\x75\x74\x65\x78\x77\x61\x6b\x65\x75\x70\x20\x61\x64\x64\x72\x3d\x6b\x65\x79\x20\x61\x6c\x69\x67\x6e\x20\x74\x6f\x6f\x20\x62\x69\x67\x6d\x61\x72\x6b\x20\x2d\x20\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x6d\x61\x72\x6b\x42\x69\x74\x73\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x6e\x6f\x20\x64\x61\x74\x61\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x6f\x74\x65\x74\x73\x6c\x65\x65\x70\x67\x20\x6f\x6e\x20\x67\x30\x70\x65\x72\x6d\x69\x73\x73\x69\x6f\x6e\x20\x64\x65\x6e\x69\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x6e\x74\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x4c\x65\x6e\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x65\x77\x28\x6e\x69\x6c\x29\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x63\x61\x6c\x6c\x20\x6f\x66\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x78\x74\x5f\x67\x63\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x73\x63\x61\x6e\x6f\x62\x6a\x65\x63\x74\x20\x6e\x20\x3d\x3d\x20\x30\x74\x2e\x73\x70\x61\x6e\x4b\x65\x79\x2e\x6e\x70\x61\x67\x65\x73\x3d\x74\x68\x72\x65\x61\x64\x20\x65\x78\x68\x61\x75\x73\x74\x69\x6f\x6e\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x63\x61\x6c\x6c\x65\x72\x20\x70\x63\x77\x72\x6f\x6e\x67\x20\x6d\x65\x64\x69\x75\x6d\x20\x74\x79\x70\x65\x20\x62\x65\x63\x61\x75\x73\x65\x20\x64\x6f\x74\x64\x6f\x74\x64\x6f\x74\x2c\x20\x6c\x6f\x63\x6b\x65\x64\x20\x74\x6f\x20\x74\x68\x72\x65\x61\x64\x32\x39\x38\x30\x32\x33\x32\x32\x33\x38\x37\x36\x39\x35\x33\x31\x32\x35\x43\x61\x75\x63\x61\x73\x69\x61\x6e\x5f\x41\x6c\x62\x61\x6e\x69\x61\x6e\x52\x46\x53\x20\x73\x70\x65\x63\x69\x66\x69\x63\x20\x65\x72\x72\x6f\x72\x56\x61\x72\x69\x61\x74\x69\x6f\x6e\x5f\x53\x65\x6c\x65\x63\x74\x6f\x72\x62\x61\x64\x20\x6d\x61\x6e\x75\x61\x6c\x46\x72\x65\x65\x4c\x69\x73\x74\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x72\x65\x66\x75\x73\x65\x64\x66\x69\x6c\x65\x20\x6e\x61\x6d\x65\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x66\x6f\x72\x45\x61\x63\x68\x50\x3a\x20\x6e\x6f\x74\x20\x64\x6f\x6e\x65\x67\x61\x72\x62\x61\x67\x65\x20\x63\x6f\x6c\x6c\x65\x63\x74\x69\x6f\x6e\x67\x63\x42\x6c\x61\x63\x6b\x65\x6e\x50\x72\x6f\x6d\x70\x74\x6c\x79\x3d\x69\x64\x65\x6e\x74\x69\x66\x69\x65\x72\x20\x72\x65\x6d\x6f\x76\x65\x64\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x69\x6e\x70\x75\x74\x2f\x6f\x75\x74\x70\x75\x74\x20\x65\x72\x72\x6f\x72\x6d\x75\x6c\x74\x69\x68\x6f\x70\x20\x61\x74\x74\x65\x6d\x70\x74\x65\x64\x6e\x6f\x20\x63\x68\x69\x6c\x64\x20\x70\x72\x6f\x63\x65\x73\x73\x65\x73\x6e\x6f\x20\x6c\x6f\x63\x6b\x73\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x63\x61\x6e\x63\x65\x6c\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x45\x6c\x65\x6d\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x54\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x55\x69\x6e\x74\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x5a\x65\x72\x6f\x28\x6e\x69\x6c\x29\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x73\x65\x72\x74\x20\x74\x3d\x73\x74\x72\x65\x61\x6d\x73\x20\x70\x69\x70\x65\x20\x65\x72\x72\x6f\x72\x73\x79\x73\x74\x65\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x20\x28\x75\x73\x65\x20\x6f\x66\x20\x63\x6c\x6f\x73\x65\x64\x20\x66\x69\x6c\x65\x76\x61\x6c\x75\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x20\x63\x61\x6c\x6c\x65\x64\x20\x75\x73\x69\x6e\x67\x20\x6e\x69\x6c\x20\x2a\x2c\x20\x20\x67\x2d\x3e\x61\x74\x6f\x6d\x69\x63\x73\x74\x61\x74\x75\x73\x3d\x2c\x20\x67\x70\x2d\x3e\x61\x74\x6f\x6d\x69\x63\x73\x74\x61\x74\x75\x73\x3d\x2f\x75\x73\x72\x2f\x6c\x69\x62\x2f\x6c\x6f\x63\x61\x6c\x65\x2f\x54\x5a\x2f\x31\x34\x39\x30\x31\x31\x36\x31\x31\x39\x33\x38\x34\x37\x36\x35\x36\x32\x35\x37\x34\x35\x30\x35\x38\x30\x35\x39\x36\x39\x32\x33\x38\x32\x38\x31\x32\x35\x43\x61\x6e\x61\x64\x69\x61\x6e\x5f\x41\x62\x6f\x72\x69\x67\x69\x6e\x61\x6c\x49\x44\x53\x5f\x42\x69\x6e\x61\x72\x79\x5f\x4f\x70\x65\x72\x61\x74\x6f\x72\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x73\x74\x61\x74\x65\x3d\x50\x61\x74\x74\x65\x72\x6e\x5f\x57\x68\x69\x74\x65\x5f\x53\x70\x61\x63\x65\x53\x49\x47\x54\x52\x41\x50\x3a\x20\x74\x72\x61\x63\x65\x20\x74\x72\x61\x70\x5f\x63\x67\x6f\x5f\x73\x65\x74\x65\x6e\x76\x20\x6d\x69\x73\x73\x69\x6e\x67\x62\x61\x64\x20\x66\x69\x6c\x65\x20\x64\x65\x73\x63\x72\x69\x70\x74\x6f\x72\x62\x61\x64\x20\x6b\x69\x6e\x64\x20\x69\x6e\x20\x72\x75\x6e\x66\x69\x6e\x71\x62\x61\x64\x20\x6e\x6f\x74\x69\x66\x79\x4c\x69\x73\x74\x20\x73\x69\x7a\x65\x62\x61\x64\x20\x72\x75\x6e\x74\x69\x6d\x65\xc2\xb7\x6d\x73\x74\x61\x72\x74\x62\x61\x64\x20\x76\x61\x6c\x75\x65\x20\x66\x6f\x72\x20\x66\x69\x65\x6c\x64\x63\x67\x6f\x63\x61\x6c\x6c\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x64\x65\x76\x69\x63\x65\x20\x6e\x6f\x74\x20\x61\x20\x73\x74\x72\x65\x61\x6d\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x20\x6e\x6f\x74\x20\x65\x6d\x70\x74\x79\x64\x69\x73\x6b\x20\x71\x75\x6f\x74\x61\x20\x65\x78\x63\x65\x65\x64\x65\x64\x66\x69\x6c\x65\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x63\x6c\x6f\x73\x65\x64\x66\x69\x6c\x65\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x65\x78\x69\x73\x74\x73\x66\x69\x6c\x65\x20\x64\x6f\x65\x73\x20\x6e\x6f\x74\x20\x65\x78\x69\x73\x74\x6d\x61\x72\x6b\x69\x6e\x67\x20\x66\x72\x65\x65\x20\x6f\x62\x6a\x65\x63\x74\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x3a\x20\x62\x61\x64\x20\x69\x6e\x64\x65\x78\x6e\x6f\x74\x65\x73\x6c\x65\x65\x70\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x67\x30\x6e\x77\x61\x69\x74\x20\x3e\x20\x77\x6f\x72\x6b\x2e\x6e\x70\x72\x6f\x63\x73\x6f\x76\x65\x72\x66\x6c\x6f\x77\x20\x69\x73\x20\x6e\x6f\x74\x20\x6e\x69\x6c\x70\x61\x6e\x69\x63\x20\x64\x75\x72\x69\x6e\x67\x20\x6d\x61\x6c\x6c\x6f\x63\x70\x61\x6e\x69\x63\x20\x64\x75\x72\x69\x6e\x67\x20\x70\x61\x6e\x69\x63\x0a\x70\x61\x6e\x69\x63\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x6c\x6f\x63\x6b\x73\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x6e\x6f\x20\x28\x20\x69\x6e\x20\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x6e\x6f\x20\x29\x20\x69\x6e\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x46\x69\x65\x6c\x64\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x46\x6c\x6f\x61\x74\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x6e\x64\x65\x78\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x73\x4e\x69\x6c\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x63\x64\x61\x74\x61\x20\x69\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x72\x65\x65\x6d\x70\x74\x20\x67\x30\x73\x65\x6d\x61\x52\x6f\x6f\x74\x20\x72\x6f\x74\x61\x74\x65\x4c\x65\x66\x74\x73\x74\x6f\x70\x6d\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x6c\x6f\x63\x6b\x73\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65\x73\x75\x6e\x61\x6c\x69\x67\x6e\x65\x64\x20\x73\x79\x73\x55\x6e\x75\x73\x65\x64\x76\x61\x6c\x75\x65\x20\x61\x6c\x69\x67\x6e\x20\x74\x6f\x6f\x20\x62\x69\x67\x77\x72\x69\x74\x65\x20\x6f\x66\x20\x47\x6f\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x20\x6a\x6f\x62\x73\x20\x64\x6f\x6e\x65\x0a\x20\x74\x6f\x20\x75\x6e\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x73\x70\x61\x6e\x2f\x75\x73\x72\x2f\x73\x68\x61\x72\x65\x2f\x7a\x6f\x6e\x65\x69\x6e\x66\x6f\x2f\x33\x37\x32\x35\x32\x39\x30\x32\x39\x38\x34\x36\x31\x39\x31\x34\x30\x36\x32\x35\x3a\x20\x6c\x65\x66\x74\x6f\x76\x65\x72\x20\x64\x65\x66\x65\x72\x20\x73\x70\x3d\x45\x67\x79\x70\x74\x69\x61\x6e\x5f\x48\x69\x65\x72\x6f\x67\x6c\x79\x70\x68\x73\x49\x44\x53\x5f\x54\x72\x69\x6e\x61\x72\x79\x5f\x4f\x70\x65\x72\x61\x74\x6f\x72\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x42\x61\x63\x6b\x4d\x65\x72\x6f\x69\x74\x69\x63\x5f\x48\x69\x65\x72\x6f\x67\x6c\x79\x70\x68\x73\x53\x49\x47\x41\x4c\x52\x4d\x3a\x20\x61\x6c\x61\x72\x6d\x20\x63\x6c\x6f\x63\x6b\x53\x49\x47\x54\x45\x52\x4d\x3a\x20\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x53\x65\x65\x6b\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x66\x66\x73\x65\x74\x53\x65\x65\x6b\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x77\x68\x65\x6e\x63\x65\x54\x65\x72\x6d\x69\x6e\x61\x6c\x5f\x50\x75\x6e\x63\x74\x75\x61\x74\x69\x6f\x6e\x62\x61\x64\x20\x64\x65\x66\x65\x72\x20\x73\x69\x7a\x65\x20\x63\x6c\x61\x73\x73\x62\x61\x64\x20\x66\x6f\x6e\x74\x20\x66\x69\x6c\x65\x20\x66\x6f\x72\x6d\x61\x74\x62\x61\x64\x20\x73\x79\x73\x74\x65\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x62\x61\x64\x20\x75\x73\x65\x20\x6f\x66\x20\x62\x75\x63\x6b\x65\x74\x2e\x62\x70\x62\x61\x64\x20\x75\x73\x65\x20\x6f\x66\x20\x62\x75\x63\x6b\x65\x74\x2e\x6d\x70\x63\x68\x61\x6e\x20\x73\x65\x6e\x64\x20\x28\x6e\x69\x6c\x20\x63\x68\x61\x6e\x29\x63\x6c\x6f\x73\x65\x20\x6f\x66\x20\x6e\x69\x6c\x20\x63\x68\x61\x6e\x6e\x65\x6c\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x74\x69\x6d\x65\x64\x20\x6f\x75\x74\x66\x6c\x6f\x61\x74\x69\x6e\x67\x20\x70\x6f\x69\x6e\x74\x20\x65\x72\x72\x6f\x72\x66\x6f\x72\x63\x65\x67\x63\x3a\x20\x70\x68\x61\x73\x65\x20\x65\x72\x72\x6f\x72\x67\x63\x5f\x74\x72\x69\x67\x67\x65\x72\x20\x75\x6e\x64\x65\x72\x66\x6c\x6f\x77\x67\x6f\x20\x6f\x66\x20\x6e\x69\x6c\x20\x66\x75\x6e\x63\x20\x76\x61\x6c\x75\x65\x67\x6f\x70\x61\x72\x6b\x3a\x20\x62\x61\x64\x20\x67\x20\x73\x74\x61\x74\x75\x73\x69\x6e\x76\x61\x6c\x69\x64\x20\x69\x74\x61\x62\x20\x6c\x6f\x63\x6b\x69\x6e\x67\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x2d\x3e\x6c\x6f\x63\x6b\x65\x64\x20\x3d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x65\x71\x75\x65\x73\x74\x20\x63\x6f\x64\x65\x69\x73\x20\x61\x20\x6e\x61\x6d\x65\x64\x20\x74\x79\x70\x65\x20\x66\x69\x6c\x65\x6b\x65\x79\x20\x68\x61\x73\x20\x62\x65\x65\x6e\x20\x72\x65\x76\x6f\x6b\x65\x64\x6d\x61\x6c\x6c\x6f\x63\x20\x64\x75\x72\x69\x6e\x67\x20\x73\x69\x67\x6e\x61\x6c\x6e\x6f\x6e\x2d\x65\x6d\x70\x74\x79\x20\x73\x77\x65\x70\x74\x20\x6c\x69\x73\x74\x6e\x6f\x74\x65\x74\x73\x6c\x65\x65\x70\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x67\x30\x70\x61\x63\x65\x72\x3a\x20\x61\x73\x73\x69\x73\x74\x20\x72\x61\x74\x69\x6f\x3d\x70\x72\x65\x65\x6d\x70\x74\x20\x6f\x66\x66\x20\x72\x65\x61\x73\x6f\x6e\x3a\x20\x72\x65\x63\x65\x69\x76\x65\x64\x20\x64\x75\x72\x69\x6e\x67\x20\x66\x6f\x72\x6b\x72\x65\x66\x6c\x65\x63\x74\x2e\x6d\x61\x6b\x65\x46\x75\x6e\x63\x53\x74\x75\x62\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x64\x6f\x75\x62\x6c\x65\x20\x77\x61\x69\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x70\x63\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x3d\x73\x65\x6d\x61\x52\x6f\x6f\x74\x20\x72\x6f\x74\x61\x74\x65\x52\x69\x67\x68\x74\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6e\x75\x6d\x62\x65\x72\x74\x72\x61\x63\x65\x3a\x20\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x77\x6f\x72\x6b\x62\x75\x66\x20\x69\x73\x20\x6e\x6f\x74\x20\x65\x6d\x70\x74\x79\x20\x67\x70\x2e\x67\x63\x73\x63\x61\x6e\x76\x61\x6c\x69\x64\x3d\x74\x72\x75\x65\x0a\x20\x6f\x66\x20\x75\x6e\x65\x78\x70\x6f\x72\x74\x65\x64\x20\x6d\x65\x74\x68\x6f\x64\x20\x70\x72\x65\x76\x69\x6f\x75\x73\x20\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x3d\x31\x38\x36\x32\x36\x34\x35\x31\x34\x39\x32\x33\x30\x39\x35\x37\x30\x33\x31\x32\x35\x39\x33\x31\x33\x32\x32\x35\x37\x34\x36\x31\x35\x34\x37\x38\x35\x31\x35\x36\x32\x35\x41\x6e\x61\x74\x6f\x6c\x69\x61\x6e\x5f\x48\x69\x65\x72\x6f\x67\x6c\x79\x70\x68\x73\x49\x6e\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x61\x6c\x5f\x50\x61\x68\x6c\x61\x76\x69\x4f\x74\x68\x65\x72\x5f\x47\x72\x61\x70\x68\x65\x6d\x65\x5f\x45\x78\x74\x65\x6e\x64\x5f\x63\x67\x6f\x5f\x75\x6e\x73\x65\x74\x65\x6e\x76\x20\x6d\x69\x73\x73\x69\x6e\x67\x62\x6c\x6f\x63\x6b\x20\x64\x65\x76\x69\x63\x65\x20\x72\x65\x71\x75\x69\x72\x65\x64\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x67\x63\x6f\x6e\x63\x75\x72\x72\x65\x6e\x74\x20\x6d\x61\x70\x20\x77\x72\x69\x74\x65\x73\x64\x65\x66\x65\x72\x20\x6f\x6e\x20\x73\x79\x73\x74\x65\x6d\x20\x73\x74\x61\x63\x6b\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x77\x72\x6f\x6e\x67\x20\x70\x67\x63\x70\x72\x6f\x63\x73\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x63\x79\x6c\x69\x6e\x6b\x20\x68\x61\x73\x20\x62\x65\x65\x6e\x20\x73\x65\x76\x65\x72\x65\x64\x70\x61\x63\x6b\x61\x67\x65\x20\x6e\x6f\x74\x20\x69\x6e\x73\x74\x61\x6c\x6c\x65\x64\x70\x61\x6e\x69\x63\x20\x6f\x6e\x20\x73\x79\x73\x74\x65\x6d\x20\x73\x74\x61\x63\x6b\x72\x65\x61\x64\x2d\x6f\x6e\x6c\x79\x20\x66\x69\x6c\x65\x20\x73\x79\x73\x74\x65\x6d\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x43\x6f\x6d\x70\x6c\x65\x78\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x50\x6f\x69\x6e\x74\x65\x72\x72\x65\x6c\x65\x61\x73\x65\x70\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x6f\x6e\x66\x75\x73\x65\x64\x20\x62\x79\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x20\x73\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x20\x3d\x73\x74\x61\x6c\x65\x20\x4e\x46\x53\x20\x66\x69\x6c\x65\x20\x68\x61\x6e\x64\x6c\x65\x73\x74\x61\x72\x74\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x6d\x20\x68\x61\x73\x20\x70\x73\x74\x61\x72\x74\x6d\x3a\x20\x6d\x20\x69\x73\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x73\x74\x61\x74\x65\x20\x6e\x6f\x74\x20\x72\x65\x63\x6f\x76\x65\x72\x61\x62\x6c\x65\x73\x74\x6f\x70\x67\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x74\x61\x74\x75\x73\x2f\x6c\x69\x62\x2f\x74\x69\x6d\x65\x2f\x7a\x6f\x6e\x65\x69\x6e\x66\x6f\x2e\x7a\x69\x70\x34\x36\x35\x36\x36\x31\x32\x38\x37\x33\x30\x37\x37\x33\x39\x32\x35\x37\x38\x31\x32\x35\x49\x6e\x73\x63\x72\x69\x70\x74\x69\x6f\x6e\x61\x6c\x5f\x50\x61\x72\x74\x68\x69\x61\x6e\x53\x49\x47\x53\x54\x4b\x46\x4c\x54\x3a\x20\x73\x74\x61\x63\x6b\x20\x66\x61\x75\x6c\x74\x53\x49\x47\x54\x53\x54\x50\x3a\x20\x6b\x65\x79\x62\x6f\x61\x72\x64\x20\x73\x74\x6f\x70\x61\x64\x64\x72\x65\x73\x73\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x75\x73\x65\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x6c\x69\x73\x74\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x61\x73\x73\x65\x6d\x62\x6c\x79\x20\x63\x68\x65\x63\x6b\x73\x20\x66\x61\x69\x6c\x65\x64\x62\x61\x64\x20\x67\x2d\x3e\x73\x74\x61\x74\x75\x73\x20\x69\x6e\x20\x72\x65\x61\x64\x79\x63\x61\x6e\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x6d\x65\x6d\x6f\x72\x79\x66\x72\x65\x65\x49\x6e\x64\x65\x78\x20\x69\x73\x20\x6e\x6f\x74\x20\x76\x61\x6c\x69\x64\x67\x65\x74\x65\x6e\x76\x20\x62\x65\x66\x6f\x72\x65\x20\x65\x6e\x76\x20\x69\x6e\x69\x74\x69\x6e\x74\x65\x67\x65\x72\x20\x64\x69\x76\x69\x64\x65\x20\x62\x79\x20\x7a\x65\x72\x6f\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x63\x6f\x6e\x76\x65\x72\x73\x69\x6f\x6e\x3a\x20\x6d\x69\x6e\x70\x63\x20\x6f\x72\x20\x6d\x61\x78\x70\x63\x20\x69\x6e\x76\x61\x6c\x69\x64\x6e\x65\x74\x77\x6f\x72\x6b\x20\x69\x73\x20\x75\x6e\x72\x65\x61\x63\x68\x61\x62\x6c\x65\x6e\x6f\x6e\x2d\x47\x6f\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x74\x20\x70\x63\x3d\x70\x61\x6e\x69\x63\x20\x64\x75\x72\x69\x6e\x67\x20\x73\x6f\x66\x74\x66\x6c\x6f\x61\x74\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x6e\x6f\x74\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x4d\x61\x70\x49\x6e\x64\x65\x78\x72\x65\x6d\x6f\x74\x65\x20\x61\x64\x64\x72\x65\x73\x73\x20\x63\x68\x61\x6e\x67\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x2e\x6d\x61\x69\x6e\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x6d\x30\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x79\x70\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x73\x63\x61\x6e\x73\x74\x61\x63\x6b\x3a\x20\x67\x70\x3d\x73\x2e\x66\x72\x65\x65\x69\x6e\x64\x65\x78\x20\x3e\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x73\x63\x61\x6e\x73\x74\x61\x63\x6b\x20\x2d\x20\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x73\x65\x6e\x64\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x65\x64\x20\x63\x68\x61\x6e\x6e\x65\x6c\x73\x70\x61\x6e\x20\x68\x61\x73\x20\x6e\x6f\x20\x66\x72\x65\x65\x20\x73\x70\x61\x63\x65\x73\x74\x61\x63\x6b\x20\x6e\x6f\x74\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x74\x69\x6d\x65\x72\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x28\x69\x64\x6c\x65\x29\x74\x72\x61\x63\x65\x3a\x20\x61\x6c\x6c\x6f\x63\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x20\x74\x68\x65\x20\x47\x6f\x20\x68\x65\x61\x70\x0a\x29\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x0a\x29\x20\x6e\x6f\x74\x20\x69\x6e\x20\x75\x73\x61\x62\x6c\x65\x20\x72\x61\x6e\x67\x65\x20\x5b\x32\x33\x32\x38\x33\x30\x36\x34\x33\x36\x35\x33\x38\x36\x39\x36\x32\x38\x39\x30\x36\x32\x35\x3c\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x3e\x4c\x6f\x67\x69\x63\x61\x6c\x5f\x4f\x72\x64\x65\x72\x5f\x45\x78\x63\x65\x70\x74\x69\x6f\x6e\x4d\x42\x20\x64\x75\x72\x69\x6e\x67\x20\x73\x77\x65\x65\x70\x3b\x20\x73\x77\x65\x70\x74\x20\x4e\x6f\x6e\x63\x68\x61\x72\x61\x63\x74\x65\x72\x5f\x43\x6f\x64\x65\x5f\x50\x6f\x69\x6e\x74\x53\x49\x47\x49\x4f\x3a\x20\x69\x2f\x6f\x20\x6e\x6f\x77\x20\x70\x6f\x73\x73\x69\x62\x6c\x65\x53\x49\x47\x53\x59\x53\x3a\x20\x62\x61\x64\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x61\x63\x71\x75\x69\x72\x65\x70\x3a\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x67\x6f\x63\x68\x61\x6e\x20\x72\x65\x63\x65\x69\x76\x65\x20\x28\x6e\x69\x6c\x20\x63\x68\x61\x6e\x29\x63\x6c\x6f\x73\x65\x20\x6f\x66\x20\x63\x6c\x6f\x73\x65\x64\x20\x63\x68\x61\x6e\x6e\x65\x6c\x64\x65\x76\x69\x63\x65\x20\x6f\x72\x20\x72\x65\x73\x6f\x75\x72\x63\x65\x20\x62\x75\x73\x79\x66\x61\x74\x61\x6c\x3a\x20\x6d\x6f\x72\x65\x73\x74\x61\x63\x6b\x20\x6f\x6e\x20\x67\x30\x0a\x67\x61\x72\x62\x61\x67\x65\x20\x63\x6f\x6c\x6c\x65\x63\x74\x69\x6f\x6e\x20\x73\x63\x61\x6e\x67\x63\x44\x72\x61\x69\x6e\x20\x70\x68\x61\x73\x65\x20\x69\x6e\x63\x6f\x72\x72\x65\x63\x74\x69\x6e\x74\x65\x72\x72\x75\x70\x74\x65\x64\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x6c\x65\x66\x74\x20\x6f\x76\x65\x72\x20\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x20\x6a\x6f\x62\x73\x6d\x61\x6b\x65\x63\x68\x61\x6e\x3a\x20\x62\x61\x64\x20\x61\x6c\x69\x67\x6e\x6d\x65\x6e\x74\x6d\x69\x73\x73\x69\x6e\x67\x20\x74\x79\x70\x65\x20\x69\x6e\x20\x72\x75\x6e\x66\x69\x6e\x71\x6d\x69\x73\x75\x73\x65\x20\x6f\x66\x20\x70\x72\x6f\x66\x42\x75\x66\x2e\x77\x72\x69\x74\x65\x6e\x61\x6e\x6f\x74\x69\x6d\x65\x20\x72\x65\x74\x75\x72\x6e\x69\x6e\x67\x20\x7a\x65\x72\x6f\x6e\x6f\x20\x73\x70\x61\x63\x65\x20\x6c\x65\x66\x74\x20\x6f\x6e\x20\x64\x65\x76\x69\x63\x65\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x20\x70\x65\x72\x6d\x69\x74\x74\x65\x64\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x70\x61\x6e\x69\x63\x20\x64\x75\x72\x69\x6e\x67\x20\x70\x72\x65\x65\x6d\x70\x74\x6f\x66\x66\x70\x72\x6f\x63\x72\x65\x73\x69\x7a\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x6e\x74\x65\x72\x66\x61\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x4e\x75\x6d\x4d\x65\x74\x68\x6f\x64\x72\x65\x66\x6c\x65\x63\x74\x2e\x6d\x65\x74\x68\x6f\x64\x56\x61\x6c\x75\x65\x43\x61\x6c\x6c\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x20\x66\x61\x69\x6c\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x69\x7a\x65\x6f\x66\x28\x68\x6d\x61\x70\x29\x20\x3d\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x3e\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x73\x63\x68\x65\x64\x75\x6c\x65\x3a\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x6c\x6f\x63\x6b\x73\x73\x70\x61\x6e\x20\x68\x61\x73\x20\x6e\x6f\x20\x66\x72\x65\x65\x20\x73\x74\x61\x63\x6b\x73\x73\x74\x61\x63\x6b\x20\x67\x72\x6f\x77\x74\x68\x20\x61\x66\x74\x65\x72\x20\x66\x6f\x72\x6b\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x76\x61\x6c\x75\x65\x75\x6e\x6c\x6f\x63\x6b\x20\x6f\x66\x20\x75\x6e\x6c\x6f\x63\x6b\x65\x64\x20\x6c\x6f\x63\x6b\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x20\x3e\x20\x77\x6f\x72\x6b\x2e\x6e\x70\x72\x6f\x63\x2f\x75\x73\x72\x2f\x73\x68\x61\x72\x65\x2f\x6c\x69\x62\x2f\x7a\x6f\x6e\x65\x69\x6e\x66\x6f\x2f\x31\x31\x36\x34\x31\x35\x33\x32\x31\x38\x32\x36\x39\x33\x34\x38\x31\x34\x34\x35\x33\x31\x32\x35\x35\x38\x32\x30\x37\x36\x36\x30\x39\x31\x33\x34\x36\x37\x34\x30\x37\x32\x32\x36\x35\x36\x32\x35\x62\x61\x64\x20\x64\x65\x66\x65\x72\x20\x65\x6e\x74\x72\x79\x20\x69\x6e\x20\x70\x61\x6e\x69\x63\x62\x61\x64\x20\x64\x65\x66\x65\x72\x20\x73\x69\x7a\x65\x20\x63\x6c\x61\x73\x73\x3a\x20\x69\x3d\x62\x6c\x6f\x63\x6b\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x63\x61\x6e\x27\x74\x20\x73\x63\x61\x6e\x20\x6f\x75\x72\x20\x6f\x77\x6e\x20\x73\x74\x61\x63\x6b\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x72\x65\x73\x65\x74\x20\x62\x79\x20\x70\x65\x65\x72\x64\x6f\x75\x62\x6c\x65\x20\x74\x72\x61\x63\x65\x47\x43\x53\x77\x65\x65\x70\x53\x74\x61\x72\x74\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x20\x69\x6d\x70\x6c\x65\x6d\x65\x6e\x74\x65\x64\x67\x63\x44\x72\x61\x69\x6e\x4e\x20\x70\x68\x61\x73\x65\x20\x69\x6e\x63\x6f\x72\x72\x65\x63\x74\x68\x61\x73\x68\x20\x6f\x66\x20\x75\x6e\x68\x61\x73\x68\x61\x62\x6c\x65\x20\x74\x79\x70\x65\x20\x6c\x65\x76\x65\x6c\x20\x32\x20\x6e\x6f\x74\x20\x73\x79\x6e\x63\x68\x72\x6f\x6e\x69\x7a\x65\x64\x6c\x69\x6e\x6b\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6f\x75\x74\x20\x6f\x66\x20\x73\x74\x72\x65\x61\x6d\x73\x20\x72\x65\x73\x6f\x75\x72\x63\x65\x73\x71\x75\x65\x75\x65\x66\x69\x6e\x61\x6c\x69\x7a\x65\x72\x20\x64\x75\x72\x69\x6e\x67\x20\x47\x43\x72\x75\x6e\x71\x73\x74\x65\x61\x6c\x3a\x20\x72\x75\x6e\x71\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x20\x20\x20\x20\x20\x74\x2e\x73\x70\x61\x6e\x4b\x65\x79\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x65\x70\x6f\x6c\x6c\x77\x61\x69\x74\x20\x6f\x6e\x20\x66\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x6f\x75\x6e\x64\x20\x6f\x62\x6a\x20\x61\x74\x20\x2a\x28\x73\x70\x61\x6e\x20\x68\x61\x73\x20\x6e\x6f\x20\x66\x72\x65\x65\x20\x6f\x62\x6a\x65\x63\x74\x73\x73\x74\x61\x63\x6b\x20\x74\x72\x61\x63\x65\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x0a\x73\x74\x72\x75\x63\x74\x75\x72\x65\x20\x6e\x65\x65\x64\x73\x20\x63\x6c\x65\x61\x6e\x69\x6e\x67\x20\x74\x6f\x20\x75\x6e\x75\x73\x65\x64\x20\x72\x65\x67\x69\x6f\x6e\x20\x6f\x66\x20\x73\x70\x61\x6e\x32\x39\x31\x30\x33\x38\x33\x30\x34\x35\x36\x37\x33\x33\x37\x30\x33\x36\x31\x33\x32\x38\x31\x32\x35\x5f\x63\x67\x6f\x5f\x74\x68\x72\x65\x61\x64\x5f\x73\x74\x61\x72\x74\x20\x6d\x69\x73\x73\x69\x6e\x67\x61\x63\x71\x75\x69\x72\x65\x70\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x20\x73\x74\x61\x74\x65\x61\x6c\x6c\x67\x61\x64\x64\x3a\x20\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x20\x47\x69\x64\x6c\x65\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x20\x69\x6e\x20\x73\x68\x72\x69\x6e\x6b\x73\x74\x61\x63\x6b\x63\x61\x6e\x27\x74\x20\x73\x63\x61\x6e\x20\x67\x63\x68\x65\x6c\x70\x65\x72\x20\x73\x74\x61\x63\x6b\x63\x68\x61\x6e\x73\x65\x6e\x64\x3a\x20\x73\x70\x75\x72\x69\x6f\x75\x73\x20\x77\x61\x6b\x65\x75\x70\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x6e\x6f\x20\x6d\x20\x66\x6f\x72\x20\x74\x69\x6d\x65\x72\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x6e\x6f\x20\x70\x20\x66\x6f\x72\x20\x74\x69\x6d\x65\x72\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x70\x6f\x6c\x6c\x2e\x66\x64\x4d\x75\x74\x65\x78\x69\x6e\x76\x61\x6c\x69\x64\x20\x63\x72\x6f\x73\x73\x2d\x64\x65\x76\x69\x63\x65\x20\x6c\x69\x6e\x6b\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x20\x69\x6e\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x6d\x69\x73\x73\x69\x6e\x67\x20\x74\x72\x61\x63\x65\x47\x43\x53\x77\x65\x65\x70\x53\x74\x61\x72\x74\x6e\x6f\x20\x62\x75\x66\x66\x65\x72\x20\x73\x70\x61\x63\x65\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x6f\x20\x73\x75\x63\x68\x20\x64\x65\x76\x69\x63\x65\x20\x6f\x72\x20\x61\x64\x64\x72\x65\x73\x73\x6e\x6f\x20\x73\x75\x63\x68\x20\x66\x69\x6c\x65\x20\x6f\x72\x20\x64\x69\x72\x65\x63\x74\x6f\x72\x79\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x77\x20\x69\x6e\x20\x70\x72\x6f\x67\x72\x65\x73\x73\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x43\x61\x6c\x6c\x65\x72\x73\x20\x66\x61\x69\x6c\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x42\x69\x74\x73\x20\x6f\x66\x20\x6e\x69\x6c\x20\x54\x79\x70\x65\x72\x65\x6c\x65\x61\x73\x65\x70\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x20\x73\x74\x61\x74\x65\x72\x65\x73\x6f\x75\x72\x63\x65\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x20\x61\x76\x6f\x69\x64\x65\x64\x72\x74\x5f\x73\x69\x67\x61\x63\x74\x69\x6f\x6e\x20\x72\x65\x61\x64\x20\x66\x61\x69\x6c\x75\x72\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x72\x6f\x67\x72\x61\x6d\x20\x65\x78\x63\x65\x65\x64\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\xc2\xb7\x6c\x6f\x63\x6b\x3a\x20\x6c\x6f\x63\x6b\x20\x63\x6f\x75\x6e\x74\x73\x6c\x69\x63\x65\x20\x62\x6f\x75\x6e\x64\x73\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x6f\x63\x6b\x65\x74\x20\x74\x79\x70\x65\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x73\x74\x61\x72\x74\x6d\x3a\x20\x70\x20\x68\x61\x73\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x67\x73\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x6e\x6f\x74\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x66\x61\x75\x6c\x74\x20\x61\x64\x64\x72\x65\x73\x73\x20\x20\x75\x73\x69\x6e\x67\x20\x75\x6e\x61\x64\x64\x72\x65\x73\x73\x61\x62\x6c\x65\x20\x76\x61\x6c\x75\x65\x31\x34\x35\x35\x31\x39\x31\x35\x32\x32\x38\x33\x36\x36\x38\x35\x31\x38\x30\x36\x36\x34\x30\x36\x32\x35\x37\x32\x37\x35\x39\x35\x37\x36\x31\x34\x31\x38\x33\x34\x32\x35\x39\x30\x33\x33\x32\x30\x33\x31\x32\x35\x53\x49\x47\x53\x54\x4f\x50\x3a\x20\x73\x74\x6f\x70\x2c\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x61\x62\x6c\x65\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x73\x65\x6d\x61\x70\x68\x6f\x72\x65\x20\x74\x69\x63\x6b\x65\x74\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x66\x6f\x72\x45\x61\x63\x68\x50\x3a\x20\x50\x20\x64\x69\x64\x20\x6e\x6f\x74\x20\x72\x75\x6e\x20\x66\x6e\x66\x72\x65\x65\x53\x70\x61\x6e\x20\x67\x69\x76\x65\x6e\x20\x63\x61\x63\x68\x65\x64\x20\x73\x70\x61\x6e\x66\x72\x65\x65\x64\x65\x66\x65\x72\x20\x77\x69\x74\x68\x20\x64\x2e\x66\x6e\x20\x21\x3d\x20\x6e\x69\x6c\x69\x6e\x69\x74\x53\x70\x61\x6e\x3a\x20\x75\x6e\x61\x6c\x69\x67\x6e\x65\x64\x20\x6c\x65\x6e\x67\x74\x68\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x65\x71\x75\x65\x73\x74\x20\x64\x65\x73\x63\x72\x69\x70\x74\x6f\x72\x6e\x61\x6d\x65\x20\x6e\x6f\x74\x20\x75\x6e\x69\x71\x75\x65\x20\x6f\x6e\x20\x6e\x65\x74\x77\x6f\x72\x6b\x6e\x6f\x20\x43\x53\x49\x20\x73\x74\x72\x75\x63\x74\x75\x72\x65\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x6f\x20\x6d\x65\x73\x73\x61\x67\x65\x20\x6f\x66\x20\x64\x65\x73\x69\x72\x65\x64\x20\x74\x79\x70\x65\x6e\x6f\x74\x65\x77\x61\x6b\x65\x75\x70\x20\x2d\x20\x64\x6f\x75\x62\x6c\x65\x20\x77\x61\x6b\x65\x75\x70\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x20\x28\x73\x74\x61\x63\x6b\x61\x6c\x6c\x6f\x63\x29\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x73\x69\x7a\x65\x20\x3d\x3d\x20\x30\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x43\x61\x6e\x49\x6e\x74\x65\x72\x66\x61\x63\x65\x72\x65\x71\x75\x69\x72\x65\x64\x20\x6b\x65\x79\x20\x6e\x6f\x74\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x2e\x73\x74\x61\x74\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x72\x69\x74\x65\x62\x61\x72\x72\x69\x65\x72\x70\x74\x72\x20\x2a\x73\x74\x61\x72\x74\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x6c\x6f\x63\x6b\x65\x64\x20\x74\x6f\x20\x6d\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x61\x73\x73\x69\x67\x6e\x61\x62\x6c\x65\x20\x74\x6f\x20\x74\x79\x70\x65\x20\x33\x36\x33\x37\x39\x37\x38\x38\x30\x37\x30\x39\x31\x37\x31\x32\x39\x35\x31\x36\x36\x30\x31\x35\x36\x32\x35\x47\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x6c\x69\x73\x74\x20\x69\x73\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x53\x49\x47\x49\x4c\x4c\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x69\x6e\x73\x74\x72\x75\x63\x74\x69\x6f\x6e\x53\x49\x47\x58\x43\x50\x55\x3a\x20\x63\x70\x75\x20\x6c\x69\x6d\x69\x74\x20\x65\x78\x63\x65\x65\x64\x65\x64\x63\x68\x61\x6e\x6e\x65\x6c\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x63\x6f\x6d\x6d\x75\x6e\x69\x63\x61\x74\x69\x6f\x6e\x20\x65\x72\x72\x6f\x72\x20\x6f\x6e\x20\x73\x65\x6e\x64\x67\x63\x73\x74\x6f\x70\x6d\x3a\x20\x6e\x6f\x74\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x67\x63\x67\x72\x6f\x77\x73\x6c\x69\x63\x65\x3a\x20\x63\x61\x70\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x20\x65\x72\x72\x6f\x72\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x72\x6f\x66\x69\x6c\x65\x20\x62\x75\x63\x6b\x65\x74\x20\x74\x79\x70\x65\x6b\x65\x79\x20\x77\x61\x73\x20\x72\x65\x6a\x65\x63\x74\x65\x64\x20\x62\x79\x20\x73\x65\x72\x76\x69\x63\x65\x6c\x61\x72\x67\x65\x20\x73\x70\x61\x6e\x20\x74\x72\x65\x61\x70\x20\x72\x6f\x74\x61\x74\x65\x4c\x65\x66\x74\x6d\x61\x6b\x65\x63\x68\x61\x6e\x3a\x20\x73\x69\x7a\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6d\x61\x6b\x65\x73\x6c\x69\x63\x65\x3a\x20\x63\x61\x70\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6d\x61\x6b\x65\x73\x6c\x69\x63\x65\x3a\x20\x6c\x65\x6e\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6e\x6f\x74\x20\x61\x20\x58\x45\x4e\x49\x58\x20\x6e\x61\x6d\x65\x64\x20\x74\x79\x70\x65\x20\x66\x69\x6c\x65\x70\x72\x6f\x67\x54\x6f\x50\x6f\x69\x6e\x74\x65\x72\x4d\x61\x73\x6b\x3a\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x72\x65\x73\x74\x61\x72\x74\x67\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x61\x74\x75\x73\x72\x75\x6e\x6c\x6f\x63\x6b\x20\x6f\x66\x20\x75\x6e\x6c\x6f\x63\x6b\x65\x64\x20\x72\x77\x6d\x75\x74\x65\x78\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x66\x69\x6e\x64\x20\x67\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x6e\x6d\x69\x64\x6c\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x69\x6e\x69\x74\x20\x66\x61\x69\x6c\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\xc2\xb7\x75\x6e\x6c\x6f\x63\x6b\x3a\x20\x6c\x6f\x63\x6b\x20\x63\x6f\x75\x6e\x74\x73\x63\x61\x6e\x66\x72\x61\x6d\x65\x3a\x20\x62\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x73\x69\x67\x6e\x61\x6c\x20\x72\x65\x63\x65\x69\x76\x65\x64\x20\x64\x75\x72\x69\x6e\x67\x20\x66\x6f\x72\x6b\x73\x69\x67\x73\x65\x6e\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x73\x74\x61\x74\x65\x73\x74\x61\x63\x6b\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x73\x74\x61\x72\x74\x6d\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x6c\x6f\x63\x6b\x73\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6e\x61\x6d\x65\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x20\x77\x61\x73\x20\x3e\x20\x77\x6f\x72\x6b\x2e\x6e\x70\x72\x6f\x63\x20\x61\x72\x67\x73\x20\x73\x74\x61\x63\x6b\x20\x6d\x61\x70\x20\x65\x6e\x74\x72\x69\x65\x73\x20\x66\x6f\x72\x20\x31\x38\x31\x38\x39\x38\x39\x34\x30\x33\x35\x34\x35\x38\x35\x36\x34\x37\x35\x38\x33\x30\x30\x37\x38\x31\x32\x35\x39\x30\x39\x34\x39\x34\x37\x30\x31\x37\x37\x32\x39\x32\x38\x32\x33\x37\x39\x31\x35\x30\x33\x39\x30\x36\x32\x35\x46\x69\x78\x65\x64\x53\x74\x61\x63\x6b\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x6f\x77\x65\x72\x2d\x6f\x66\x2d\x32\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x73\x70\x61\x6e\x20\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x6d\x20\x69\x73\x20\x6e\x6f\x74\x20\x6c\x6f\x63\x6b\x65\x64\x50\x72\x65\x70\x65\x6e\x64\x65\x64\x5f\x43\x6f\x6e\x63\x61\x74\x65\x6e\x61\x74\x69\x6f\x6e\x5f\x4d\x61\x72\x6b\x53\x49\x47\x48\x55\x50\x3a\x20\x74\x65\x72\x6d\x69\x6e\x61\x6c\x20\x6c\x69\x6e\x65\x20\x68\x61\x6e\x67\x75\x70\x53\x49\x47\x57\x49\x4e\x43\x48\x3a\x20\x77\x69\x6e\x64\x6f\x77\x20\x73\x69\x7a\x65\x20\x63\x68\x61\x6e\x67\x65\x5f\x6d\x68\x65\x61\x70\x5f\x61\x6c\x6c\x6f\x63\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x67\x30\x20\x73\x74\x61\x63\x6b\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x77\x72\x69\x74\x65\x20\x62\x61\x72\x72\x69\x65\x72\x63\x61\x6e\x27\x74\x20\x70\x72\x65\x73\x65\x72\x76\x65\x20\x75\x6e\x6c\x69\x6e\x6b\x65\x64\x20\x73\x70\x61\x6e\x63\x6f\x6d\x70\x61\x72\x69\x6e\x67\x20\x75\x6e\x63\x6f\x6d\x70\x61\x72\x61\x62\x6c\x65\x20\x74\x79\x70\x65\x20\x64\x65\x73\x74\x69\x6e\x61\x74\x69\x6f\x6e\x20\x61\x64\x64\x72\x65\x73\x73\x20\x72\x65\x71\x75\x69\x72\x65\x64\x66\x61\x74\x61\x6c\x3a\x20\x6d\x6f\x72\x65\x73\x74\x61\x63\x6b\x20\x6f\x6e\x20\x67\x73\x69\x67\x6e\x61\x6c\x0a\x66\x69\x6c\x65\x20\x64\x65\x73\x63\x72\x69\x70\x74\x6f\x72\x20\x69\x6e\x20\x62\x61\x64\x20\x73\x74\x61\x74\x65\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x20\x77\x69\x74\x68\x20\x70\x67\x63\x68\x65\x6c\x70\x65\x72\x73\x74\x61\x72\x74\x3a\x20\x62\x61\x64\x20\x6d\x2d\x3e\x68\x65\x6c\x70\x67\x63\x67\x63\x73\x74\x6f\x70\x6d\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x75\x6e\x74\x69\x6d\x65\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x6c\x61\x72\x67\x65\x20\x73\x70\x61\x6e\x20\x74\x72\x65\x61\x70\x20\x72\x6f\x74\x61\x74\x65\x52\x69\x67\x68\x74\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x20\x69\x6e\x20\x73\x68\x72\x69\x6e\x6b\x73\x74\x61\x63\x6b\x6e\x65\x65\x64\x20\x70\x61\x64\x64\x69\x6e\x67\x20\x69\x6e\x20\x62\x75\x63\x6b\x65\x74\x20\x28\x6b\x65\x79\x29\x6e\x65\x77\x70\x72\x6f\x63\x31\x3a\x20\x6e\x65\x77\x20\x67\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x64\x65\x61\x64\x6e\x65\x77\x70\x72\x6f\x63\x31\x3a\x20\x6e\x65\x77\x67\x20\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x6e\x6f\x74\x65\x77\x61\x6b\x65\x75\x70\x20\x2d\x20\x64\x6f\x75\x62\x6c\x65\x20\x77\x61\x6b\x65\x75\x70\x20\x28\x6f\x73\x3a\x20\x70\x72\x6f\x63\x65\x73\x73\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x66\x69\x6e\x69\x73\x68\x65\x64\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x64\x72\x69\x76\x65\x72\x20\x6e\x6f\x74\x20\x61\x74\x74\x61\x63\x68\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x49\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4b\x65\x79\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x6d\x61\x70\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x6f\x6c\x64\x76\x61\x6c\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x6f\x20\x6d\x6f\x64\x75\x6c\x65\x20\x64\x61\x74\x61\x20\x66\x6f\x72\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x2e\x67\x63\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x4d\x6f\x64\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x74\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x3a\x20\x76\x61\x6c\x20\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\xce\xb5\x20\x3e\x20\x28\x64\x65\x6e\x3c\x3c\x73\x68\x69\x66\x74\x29\x2f\x32\x34\x35\x34\x37\x34\x37\x33\x35\x30\x38\x38\x36\x34\x36\x34\x31\x31\x38\x39\x35\x37\x35\x31\x39\x35\x33\x31\x32\x35\x53\x49\x47\x50\x49\x50\x45\x3a\x20\x77\x72\x69\x74\x65\x20\x74\x6f\x20\x62\x72\x6f\x6b\x65\x6e\x20\x70\x69\x70\x65\x53\x49\x47\x50\x57\x52\x3a\x20\x70\x6f\x77\x65\x72\x20\x66\x61\x69\x6c\x75\x72\x65\x20\x72\x65\x73\x74\x61\x72\x74\x61\x62\x69\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x20\x64\x65\x74\x65\x63\x74\x65\x64\x20\x62\x65\x74\x77\x65\x65\x6e\x61\x64\x64\x73\x70\x65\x63\x69\x61\x6c\x20\x6f\x6e\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x67\x63\x20\x64\x6f\x6e\x65\x20\x62\x75\x74\x20\x67\x63\x70\x68\x61\x73\x65\x20\x21\x3d\x20\x5f\x47\x43\x6f\x66\x66\x67\x66\x70\x75\x74\x3a\x20\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x20\x28\x6e\x6f\x74\x20\x47\x64\x65\x61\x64\x29\x69\x6e\x76\x61\x6c\x69\x64\x20\x6c\x65\x6e\x67\x74\x68\x20\x6f\x66\x20\x74\x72\x61\x63\x65\x20\x65\x76\x65\x6e\x74\x69\x6f\x3a\x20\x72\x65\x61\x64\x2f\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x65\x64\x20\x70\x69\x70\x65\x6d\x61\x63\x68\x69\x6e\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x74\x68\x65\x20\x6e\x65\x74\x77\x6f\x72\x6b\x6e\x6f\x20\x58\x45\x4e\x49\x58\x20\x73\x65\x6d\x61\x70\x68\x6f\x72\x65\x73\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x75\x6d\x65\x72\x69\x63\x61\x6c\x20\x72\x65\x73\x75\x6c\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x70\x72\x6f\x67\x72\x65\x73\x73\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x66\x61\x6d\x69\x6c\x79\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x45\x6c\x65\x6d\x20\x6f\x66\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x67\x20\x69\x6e\x20\x63\x67\x6f\x63\x61\x6c\x6c\x62\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6d\x70\x6f\x73\x73\x69\x62\x6c\x65\x20\x74\x79\x70\x65\x20\x6b\x69\x6e\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x61\x72\x6b\x69\x6e\x67\x20\x66\x72\x65\x65\x20\x6f\x62\x6a\x65\x63\x74\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x6d\x61\x70\x3a\x20\x61\x63\x63\x65\x73\x73\x20\x64\x65\x6e\x69\x65\x64\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x70\x6c\x69\x74\x20\x73\x74\x61\x63\x6b\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x74\x20\x75\x6e\x64\x65\x72\x66\x6c\x6f\x77\x3a\x20\x76\x61\x6c\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x70\x63\x20\x69\x6e\x20\x64\x65\x66\x65\x72\x20\x73\x65\x6d\x61\x63\x71\x75\x69\x72\x65\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x74\x68\x65\x20\x47\x20\x73\x74\x61\x63\x6b\x73\x74\x72\x69\x6e\x67\x20\x63\x6f\x6e\x63\x61\x74\x65\x6e\x61\x74\x69\x6f\x6e\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x73\x79\x6e\x74\x61\x78\x20\x65\x72\x72\x6f\x72\x20\x73\x63\x61\x6e\x6e\x69\x6e\x67\x20\x62\x6f\x6f\x6c\x65\x61\x6e\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65\x73\x20\x69\x6e\x20\x73\x79\x73\x74\x65\x6d\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x68\x61\x73\x20\x6c\x65\x66\x74\x6f\x76\x65\x72\x20\x64\x65\x66\x65\x72\x73\x20\x6c\x6f\x63\x61\x6c\x73\x20\x73\x74\x61\x63\x6b\x20\x6d\x61\x70\x20\x65\x6e\x74\x72\x69\x65\x73\x20\x66\x6f\x72\x20\x32\x32\x37\x33\x37\x33\x36\x37\x35\x34\x34\x33\x32\x33\x32\x30\x35\x39\x34\x37\x38\x37\x35\x39\x37\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x41\x6c\x6c\x6f\x63\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x62\x61\x64\x20\x6e\x70\x61\x67\x65\x73\x53\x49\x47\x50\x52\x4f\x46\x3a\x20\x70\x72\x6f\x66\x69\x6c\x69\x6e\x67\x20\x61\x6c\x61\x72\x6d\x20\x63\x6c\x6f\x63\x6b\x53\x49\x47\x55\x53\x52\x31\x3a\x20\x75\x73\x65\x72\x2d\x64\x65\x66\x69\x6e\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x31\x53\x49\x47\x55\x53\x52\x32\x3a\x20\x75\x73\x65\x72\x2d\x64\x65\x66\x69\x6e\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x32\x53\x49\x47\x56\x54\x41\x4c\x52\x4d\x3a\x20\x76\x69\x72\x74\x75\x61\x6c\x20\x61\x6c\x61\x72\x6d\x20\x63\x6c\x6f\x63\x6b\x61\x73\x73\x69\x67\x6e\x6d\x65\x6e\x74\x20\x74\x6f\x20\x65\x6e\x74\x72\x79\x20\x69\x6e\x20\x6e\x69\x6c\x20\x6d\x61\x70\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x63\x6f\x75\x6e\x74\x73\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x67\x65\x74\x20\x73\x79\x73\x74\x65\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x66\x72\x65\x65\x64\x65\x66\x65\x72\x20\x77\x69\x74\x68\x20\x64\x2e\x5f\x70\x61\x6e\x69\x63\x20\x21\x3d\x20\x6e\x69\x6c\x69\x6e\x61\x70\x70\x72\x6f\x70\x72\x69\x61\x74\x65\x20\x69\x6f\x63\x74\x6c\x20\x66\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x0a\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x66\x6f\x75\x6e\x64\x20\x6f\x6e\x20\x73\x74\x61\x63\x6b\x6e\x65\x65\x64\x20\x70\x61\x64\x64\x69\x6e\x67\x20\x69\x6e\x20\x62\x75\x63\x6b\x65\x74\x20\x28\x76\x61\x6c\x75\x65\x29\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x77\x72\x6f\x6e\x67\x20\x74\x79\x70\x65\x20\x66\x6f\x72\x20\x73\x6f\x63\x6b\x65\x74\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4c\x65\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x61\x72\x72\x61\x79\x20\x74\x79\x70\x65\x72\x75\x6e\x71\x70\x75\x74\x73\x6c\x6f\x77\x3a\x20\x71\x75\x65\x75\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x66\x75\x6c\x6c\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x66\x72\x61\x6d\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x6f\x75\x6e\x64\x20\x69\x6e\x20\x6f\x62\x6a\x65\x63\x74\x20\x61\x74\x20\x2a\x28\x73\x6f\x63\x6b\x65\x74\x20\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x6e\x6f\x6e\x2d\x73\x6f\x63\x6b\x65\x74\x73\x79\x6e\x63\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6d\x75\x74\x65\x78\x20\x73\x74\x61\x74\x65\x73\x79\x6e\x63\x3a\x20\x75\x6e\x6c\x6f\x63\x6b\x20\x6f\x66\x20\x75\x6e\x6c\x6f\x63\x6b\x65\x64\x20\x6d\x75\x74\x65\x78\x2e\x2e\x2e\x61\x64\x64\x69\x74\x69\x6f\x6e\x61\x6c\x20\x66\x72\x61\x6d\x65\x73\x20\x65\x6c\x69\x64\x65\x64\x2e\x2e\x2e\x0a\x2e\x6c\x69\x62\x20\x73\x65\x63\x74\x69\x6f\x6e\x20\x69\x6e\x20\x61\x2e\x6f\x75\x74\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x31\x31\x33\x36\x38\x36\x38\x33\x37\x37\x32\x31\x36\x31\x36\x30\x32\x39\x37\x33\x39\x33\x37\x39\x38\x38\x32\x38\x31\x32\x35\x35\x36\x38\x34\x33\x34\x31\x38\x38\x36\x30\x38\x30\x38\x30\x31\x34\x38\x36\x39\x36\x38\x39\x39\x34\x31\x34\x30\x36\x32\x35\x53\x49\x47\x53\x45\x47\x56\x3a\x20\x73\x65\x67\x6d\x65\x6e\x74\x61\x74\x69\x6f\x6e\x20\x76\x69\x6f\x6c\x61\x74\x69\x6f\x6e\x63\x61\x6e\x6e\x6f\x74\x20\x61\x73\x73\x69\x67\x6e\x20\x72\x65\x71\x75\x65\x73\x74\x65\x64\x20\x61\x64\x64\x72\x65\x73\x73\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x62\x61\x64\x20\x69\x6e\x63\x6f\x6d\x69\x6e\x67\x20\x76\x61\x6c\x75\x65\x73\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x20\x66\x6f\x75\x6e\x64\x20\x75\x6e\x6d\x61\x72\x6b\x65\x64\x20\x6f\x62\x6a\x65\x63\x74\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x62\x6c\x6f\x63\x6b\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x66\x6d\x74\x3a\x20\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x62\x61\x73\x65\x3b\x20\x63\x61\x6e\x27\x74\x20\x68\x61\x70\x70\x65\x6e\x69\x6e\x73\x65\x72\x74\x69\x6e\x67\x20\x73\x70\x61\x6e\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x74\x72\x65\x61\x70\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x20\x2d\x20\x6d\x69\x73\x75\x73\x65\x20\x6f\x66\x20\x69\x74\x61\x62\x6d\x61\x6c\x66\x6f\x72\x6d\x65\x64\x20\x74\x69\x6d\x65\x20\x7a\x6f\x6e\x65\x20\x69\x6e\x66\x6f\x72\x6d\x61\x74\x69\x6f\x6e\x6e\x6f\x6e\x20\x69\x6e\x2d\x75\x73\x65\x20\x73\x70\x61\x6e\x20\x69\x6e\x20\x75\x6e\x73\x77\x65\x70\x74\x20\x6c\x69\x73\x74\x70\x61\x63\x65\x72\x3a\x20\x73\x77\x65\x65\x70\x20\x64\x6f\x6e\x65\x20\x61\x74\x20\x68\x65\x61\x70\x20\x73\x69\x7a\x65\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x49\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x73\x65\x74\x73\x70\x69\x6e\x6e\x69\x6e\x67\x3a\x20\x6e\x6f\x74\x20\x61\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x20\x6d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x20\x63\x6f\x6e\x66\x6c\x69\x63\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x6d\x65\x6d\x6f\x72\x79\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x70\x6c\x69\x74\x20\x73\x74\x61\x63\x6b\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x3a\x20\x32\x38\x34\x32\x31\x37\x30\x39\x34\x33\x30\x34\x30\x34\x30\x30\x37\x34\x33\x34\x38\x34\x34\x39\x37\x30\x37\x30\x33\x31\x32\x35\x53\x49\x47\x46\x50\x45\x3a\x20\x66\x6c\x6f\x61\x74\x69\x6e\x67\x2d\x70\x6f\x69\x6e\x74\x20\x65\x78\x63\x65\x70\x74\x69\x6f\x6e\x53\x49\x47\x54\x54\x4f\x55\x3a\x20\x62\x61\x63\x6b\x67\x72\x6f\x75\x6e\x64\x20\x77\x72\x69\x74\x65\x20\x74\x6f\x20\x74\x74\x79\x67\x63\x68\x65\x6c\x70\x65\x72\x20\x6e\x6f\x74\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x6f\x6e\x20\x67\x30\x20\x73\x74\x61\x63\x6b\x6e\x6f\x6e\x2d\x47\x6f\x20\x63\x6f\x64\x65\x20\x64\x69\x73\x61\x62\x6c\x65\x64\x20\x73\x69\x67\x61\x6c\x74\x73\x74\x61\x63\x6b\x6e\x75\x6d\x65\x72\x69\x63\x61\x6c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x64\x6f\x6d\x61\x69\x6e\x70\x61\x6e\x69\x63\x20\x77\x68\x69\x6c\x65\x20\x70\x72\x69\x6e\x74\x69\x6e\x67\x20\x70\x61\x6e\x69\x63\x20\x76\x61\x6c\x75\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x6e\x61\x6d\x65\x46\x72\x6f\x6d\x3a\x20\x74\x61\x67\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x4f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x6d\x6f\x76\x65\x73\x70\x65\x63\x69\x61\x6c\x20\x6f\x6e\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x72\x65\x73\x6f\x75\x72\x63\x65\x20\x74\x65\x6d\x70\x6f\x72\x61\x72\x69\x6c\x79\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x65\x70\x6f\x6c\x6c\x63\x72\x65\x61\x74\x65\x20\x66\x61\x69\x6c\x65\x64\x20\x77\x69\x74\x68\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x63\x61\x6c\x6c\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x72\x65\x74\x75\x72\x6e\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x20\x63\x61\x6c\x6c\x65\x64\x20\x66\x72\x6f\x6d\x20\x67\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x63\x6b\x20\x73\x70\x6c\x69\x74\x20\x61\x74\x20\x62\x61\x64\x20\x74\x69\x6d\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x65\x6c\x65\x6d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x6e\x65\x78\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x70\x72\x65\x76\x73\x63\x61\x6e\x73\x74\x61\x63\x6b\x3a\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x73\x6f\x66\x74\x77\x61\x72\x65\x20\x63\x61\x75\x73\x65\x64\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x61\x62\x6f\x72\x74\x73\x74\x61\x63\x6b\x6d\x61\x70\x64\x61\x74\x61\x3a\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x77\x65\x65\x70\x20\x69\x6e\x63\x72\x65\x61\x73\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x63\x6f\x75\x6e\x74\x75\x73\x65\x20\x6f\x66\x20\x63\x6c\x6f\x73\x65\x64\x20\x6e\x65\x74\x77\x6f\x72\x6b\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x6f\x66\x20\x6d\x65\x74\x68\x6f\x64\x20\x6f\x6e\x20\x6e\x69\x6c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x76\x61\x6c\x75\x65\x31\x34\x32\x31\x30\x38\x35\x34\x37\x31\x35\x32\x30\x32\x30\x30\x33\x37\x31\x37\x34\x32\x32\x34\x38\x35\x33\x35\x31\x35\x36\x32\x35\x37\x31\x30\x35\x34\x32\x37\x33\x35\x37\x36\x30\x31\x30\x30\x31\x38\x35\x38\x37\x31\x31\x32\x34\x32\x36\x37\x35\x37\x38\x31\x32\x35\x53\x49\x47\x43\x48\x4c\x44\x3a\x20\x63\x68\x69\x6c\x64\x20\x73\x74\x61\x74\x75\x73\x20\x68\x61\x73\x20\x63\x68\x61\x6e\x67\x65\x64\x53\x49\x47\x54\x54\x49\x4e\x3a\x20\x62\x61\x63\x6b\x67\x72\x6f\x75\x6e\x64\x20\x72\x65\x61\x64\x20\x66\x72\x6f\x6d\x20\x74\x74\x79\x53\x49\x47\x58\x46\x53\x5a\x3a\x20\x66\x69\x6c\x65\x20\x73\x69\x7a\x65\x20\x6c\x69\x6d\x69\x74\x20\x65\x78\x63\x65\x65\x64\x65\x64\x63\x6f\x6e\x63\x75\x72\x72\x65\x6e\x74\x20\x6d\x61\x70\x20\x72\x65\x61\x64\x20\x61\x6e\x64\x20\x6d\x61\x70\x20\x77\x72\x69\x74\x65\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x66\x72\x65\x65\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x20\x6e\x6f\x74\x20\x69\x6e\x20\x61\x20\x73\x74\x61\x63\x6b\x20\x73\x70\x61\x6e\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x68\x69\x66\x74\x72\x65\x66\x6c\x65\x63\x74\x2e\x6e\x61\x6d\x65\x46\x72\x6f\x6d\x3a\x20\x6e\x61\x6d\x65\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x43\x68\x61\x6e\x44\x69\x72\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x63\x68\x61\x6e\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x61\x72\x72\x61\x79\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x74\x6f\x67\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x6f\x6c\x64\x76\x61\x6c\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x73\x74\x61\x63\x6b\x20\x65\x78\x63\x65\x65\x64\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x65\x6d\x6f\x72\x79\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x79\x20\x4f\x53\x20\x28\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x61\x6d\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x65\x78\x74\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x74\x61\x63\x6b\x61\x6c\x6c\x6f\x63\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x73\x63\x68\x65\x64\x75\x6c\x65\x72\x20\x73\x74\x61\x63\x6b\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6c\x6f\x63\x6b\x69\x6e\x67\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6c\x65\x76\x65\x6c\x73\x20\x6f\x66\x20\x73\x79\x6d\x62\x6f\x6c\x69\x63\x20\x6c\x69\x6e\x6b\x73\x74\x72\x65\x61\x70\x20\x69\x6e\x73\x65\x72\x74\x20\x66\x69\x6e\x64\x73\x20\x61\x20\x62\x72\x6f\x6b\x65\x6e\x20\x74\x72\x65\x61\x70\x74\x72\x65\x61\x70\x20\x6e\x6f\x64\x65\x20\x77\x69\x74\x68\x20\x6e\x69\x6c\x20\x73\x70\x61\x6e\x4b\x65\x79\x20\x66\x6f\x75\x6e\x64\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x75\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x6c\x65\x20\x74\x79\x70\x65\x33\x35\x35\x32\x37\x31\x33\x36\x37\x38\x38\x30\x30\x35\x30\x30\x39\x32\x39\x33\x35\x35\x36\x32\x31\x33\x33\x37\x38\x39\x30\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x41\x6c\x6c\x6f\x63\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x4d\x53\x70\x61\x6e\x20\x6e\x6f\x74\x20\x66\x72\x65\x65\x4d\x53\x70\x61\x6e\x5f\x45\x6e\x73\x75\x72\x65\x53\x77\x65\x70\x74\x3a\x20\x6d\x20\x69\x73\x20\x6e\x6f\x74\x20\x6c\x6f\x63\x6b\x65\x64\x4f\x74\x68\x65\x72\x5f\x44\x65\x66\x61\x75\x6c\x74\x5f\x49\x67\x6e\x6f\x72\x61\x62\x6c\x65\x5f\x43\x6f\x64\x65\x5f\x50\x6f\x69\x6e\x74\x53\x49\x47\x55\x52\x47\x3a\x20\x75\x72\x67\x65\x6e\x74\x20\x63\x6f\x6e\x64\x69\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x73\x6f\x63\x6b\x65\x74\x66\x6f\x72\x45\x61\x63\x68\x50\x3a\x20\x73\x63\x68\x65\x64\x2e\x73\x61\x66\x65\x50\x6f\x69\x6e\x74\x57\x61\x69\x74\x20\x21\x3d\x20\x30\x68\x65\x61\x70\x42\x69\x74\x73\x46\x6f\x72\x53\x70\x61\x6e\x3a\x20\x62\x61\x73\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x3a\x20\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4d\x65\x74\x68\x6f\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x70\x61\x73\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x20\x69\x73\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x62\x75\x74\x20\x70\x20\x69\x73\x20\x6e\x6f\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x72\x65\x74\x75\x72\x6e\x20\x70\x63\x20\x66\x6f\x72\x20\x73\x63\x68\x65\x64\x75\x6c\x65\x3a\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x20\x77\x69\x74\x68\x20\x6c\x6f\x63\x61\x6c\x20\x77\x6f\x72\x6b\x73\x70\x61\x6e\x20\x61\x6e\x64\x20\x74\x72\x65\x61\x70\x20\x73\x69\x7a\x65\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x6d\x61\x74\x63\x68\x3f\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x73\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x73\x70\x6c\x69\x63\x65\x31\x37\x37\x36\x33\x35\x36\x38\x33\x39\x34\x30\x30\x32\x35\x30\x34\x36\x34\x36\x37\x37\x38\x31\x30\x36\x36\x38\x39\x34\x35\x33\x31\x32\x35\x38\x38\x38\x31\x37\x38\x34\x31\x39\x37\x30\x30\x31\x32\x35\x32\x33\x32\x33\x33\x38\x39\x30\x35\x33\x33\x34\x34\x37\x32\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x66\x72\x65\x65\x66\x69\x6e\x64\x66\x75\x6e\x63\x3a\x20\x62\x61\x64\x20\x66\x69\x6e\x64\x66\x75\x6e\x63\x74\x61\x62\x20\x65\x6e\x74\x72\x79\x20\x69\x64\x78\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x20\x77\x69\x74\x68\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x67\x72\x65\x79\x6f\x62\x6a\x65\x63\x74\x3a\x20\x6f\x62\x6a\x20\x6e\x6f\x74\x20\x70\x6f\x69\x6e\x74\x65\x72\x2d\x61\x6c\x69\x67\x6e\x65\x64\x6d\x69\x73\x72\x6f\x75\x6e\x64\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x69\x6e\x20\x6d\x61\x6c\x6c\x6f\x63\x69\x6e\x69\x74\x6e\x65\x74\x77\x6f\x72\x6b\x20\x64\x72\x6f\x70\x70\x65\x64\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x72\x65\x73\x65\x74\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x61\x6c\x69\x67\x6e\x20\x69\x73\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x70\x69\x64\x6c\x65\x70\x75\x74\x3a\x20\x50\x20\x68\x61\x73\x20\x6e\x6f\x6e\x2d\x65\x6d\x70\x74\x79\x20\x72\x75\x6e\x20\x71\x75\x65\x75\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x6c\x6f\x73\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x20\x77\x2f\x6f\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x64\x69\x64\x20\x6e\x6f\x74\x20\x75\x6e\x77\x69\x6e\x64\x20\x63\x6f\x6d\x70\x6c\x65\x74\x65\x6c\x79\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x69\x73\x20\x6e\x6f\x74\x20\x63\x6f\x6e\x6e\x65\x63\x74\x65\x64\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x34\x34\x34\x30\x38\x39\x32\x30\x39\x38\x35\x30\x30\x36\x32\x36\x31\x36\x31\x36\x39\x34\x35\x32\x36\x36\x37\x32\x33\x36\x33\x32\x38\x31\x32\x35\x47\x6f\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x73\x74\x6f\x72\x65\x64\x20\x69\x6e\x74\x6f\x20\x6e\x6f\x6e\x2d\x47\x6f\x20\x6d\x65\x6d\x6f\x72\x79\x4d\x53\x74\x61\x74\x73\x20\x76\x73\x20\x4d\x65\x6d\x53\x74\x61\x74\x73\x54\x79\x70\x65\x20\x73\x69\x7a\x65\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x61\x63\x63\x65\x73\x73\x69\x6e\x67\x20\x61\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x6b\x65\x79\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f\x66\x20\x6b\x65\x79\x20\x61\x6c\x69\x67\x6e\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x53\x70\x61\x6e\x73\x20\x64\x75\x72\x69\x6e\x67\x20\x73\x65\x63\x6f\x6e\x64\x20\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x49\x73\x56\x61\x72\x69\x61\x64\x69\x63\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x46\x69\x65\x6c\x64\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x66\x75\x6e\x63\x4c\x61\x79\x6f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x6e\x6f\x74\x69\x66\x79\x4c\x69\x73\x74\x20\x73\x69\x7a\x65\x20\x2d\x20\x73\x79\x6e\x63\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x42\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x63\x2d\x65\x6e\x63\x6f\x64\x65\x64\x20\x74\x61\x62\x6c\x65\x20\x66\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x63\x61\x6c\x6c\x20\x63\x61\x6c\x6c\x65\x64\x20\x6f\x6e\x20\x6d\x2d\x3e\x67\x30\x20\x73\x74\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x77\x61\x69\x74\x6c\x69\x6e\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x72\x6f\x6e\x67\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x69\x6e\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x73\x69\x67\x6e\x61\x6c\x20\x61\x72\x72\x69\x76\x65\x64\x20\x64\x75\x72\x69\x6e\x67\x20\x63\x67\x6f\x20\x65\x78\x65\x63\x75\x74\x69\x6f\x6e\x0a\x73\x79\x6e\x74\x61\x78\x20\x65\x72\x72\x6f\x72\x20\x73\x63\x61\x6e\x6e\x69\x6e\x67\x20\x63\x6f\x6d\x70\x6c\x65\x78\x20\x6e\x75\x6d\x62\x65\x72\x75\x6e\x63\x61\x63\x68\x69\x6e\x67\x20\x73\x70\x61\x6e\x20\x62\x75\x74\x20\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x3d\x3d\x20\x30\x29\x20\x69\x73\x20\x73\x6d\x61\x6c\x6c\x65\x72\x20\x74\x68\x61\x6e\x20\x6d\x69\x6e\x69\x6d\x75\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x20\x28\x32\x32\x32\x30\x34\x34\x36\x30\x34\x39\x32\x35\x30\x33\x31\x33\x30\x38\x30\x38\x34\x37\x32\x36\x33\x33\x33\x36\x31\x38\x31\x36\x34\x30\x36\x32\x35\x5f\x63\x67\x6f\x5f\x6e\x6f\x74\x69\x66\x79\x5f\x72\x75\x6e\x74\x69\x6d\x65\x5f\x69\x6e\x69\x74\x5f\x64\x6f\x6e\x65\x20\x6d\x69\x73\x73\x69\x6e\x67\x61\x6c\x6c\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x73\x20\x61\x72\x65\x20\x61\x73\x6c\x65\x65\x70\x20\x2d\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x21\x63\x61\x6e\x6e\x6f\x74\x20\x65\x78\x65\x63\x20\x61\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x20\x64\x69\x72\x65\x63\x74\x6c\x79\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x20\x70\x6f\x73\x73\x69\x62\x6c\x65\x20\x64\x75\x65\x20\x74\x6f\x20\x52\x46\x2d\x6b\x69\x6c\x6c\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x62\x79\x74\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x72\x75\x6e\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x42\x69\x74\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x61\x72\x69\x74\x68\x6d\x65\x74\x69\x63\x20\x54\x79\x70\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x20\x63\x6f\x6e\x66\x6c\x69\x63\x74\x3a\x20\x6d\x61\x70\x28\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x73\x69\x7a\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x65\x74\x70\x72\x6f\x66\x69\x6c\x65\x62\x75\x63\x6b\x65\x74\x3a\x20\x70\x72\x6f\x66\x69\x6c\x65\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x73\x65\x74\x73\x74\x61\x72\x74\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6d\x70\x2d\x3e\x6e\x65\x78\x74\x70\x76\x61\x6c\x75\x65\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x20\x66\x6f\x72\x20\x64\x65\x66\x69\x6e\x65\x64\x20\x64\x61\x74\x61\x20\x74\x79\x70\x65\x31\x31\x31\x30\x32\x32\x33\x30\x32\x34\x36\x32\x35\x31\x35\x36\x35\x34\x30\x34\x32\x33\x36\x33\x31\x36\x36\x38\x30\x39\x30\x38\x32\x30\x33\x31\x32\x35\x35\x35\x35\x31\x31\x31\x35\x31\x32\x33\x31\x32\x35\x37\x38\x32\x37\x30\x32\x31\x31\x38\x31\x35\x38\x33\x34\x30\x34\x35\x34\x31\x30\x31\x35\x36\x32\x35\x61\x72\x67\x20\x73\x69\x7a\x65\x20\x74\x6f\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x63\x61\x6c\x6c\x20\x6d\x6f\x72\x65\x20\x74\x68\x61\x6e\x20\x31\x47\x42\x63\x61\x6e\x20\x6e\x6f\x74\x20\x61\x63\x63\x65\x73\x73\x20\x61\x20\x6e\x65\x65\x64\x65\x64\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x63\x6f\x6e\x63\x75\x72\x72\x65\x6e\x74\x20\x6d\x61\x70\x20\x69\x74\x65\x72\x61\x74\x69\x6f\x6e\x20\x61\x6e\x64\x20\x6d\x61\x70\x20\x77\x72\x69\x74\x65\x67\x63\x42\x67\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x3a\x20\x62\x6c\x61\x63\x6b\x65\x6e\x69\x6e\x67\x20\x6e\x6f\x74\x20\x65\x6e\x61\x62\x6c\x65\x64\x6d\x61\x6b\x65\x63\x68\x61\x6e\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x63\x68\x61\x6e\x6e\x65\x6c\x20\x65\x6c\x65\x6d\x65\x6e\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x72\x65\x61\x64\x20\x6f\x6e\x20\x66\x72\x65\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x20\x68\x65\x61\x64\x65\x72\x3a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x73\x65\x6c\x65\x63\x74\x64\x6f\x6e\x65\x32\x37\x37\x35\x35\x35\x37\x35\x36\x31\x35\x36\x32\x38\x39\x31\x33\x35\x31\x30\x35\x39\x30\x37\x39\x31\x37\x30\x32\x32\x37\x30\x35\x30\x37\x38\x31\x32\x35\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x20\x61\x66\x74\x65\x72\x20\x73\x77\x65\x65\x70\x6d\x69\x73\x72\x6f\x75\x6e\x64\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x69\x6e\x20\x4d\x48\x65\x61\x70\x5f\x53\x79\x73\x41\x6c\x6c\x6f\x63\x72\x65\x63\x65\x69\x76\x65\x64\x20\x6f\x6e\x20\x74\x68\x72\x65\x61\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x20\x73\x69\x67\x6e\x61\x6c\x20\x73\x74\x61\x63\x6b\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x4e\x61\x6d\x65\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x66\x72\x65\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x66\x61\x69\x6c\x65\x64\x20\x67\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x20\x77\x69\x74\x68\x20\x74\x79\x70\x65\x20\x73\x70\x61\x6e\x20\x61\x6e\x64\x20\x74\x72\x65\x61\x70\x20\x6e\x6f\x64\x65\x20\x6e\x70\x61\x67\x65\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x6d\x61\x74\x63\x68\x73\x74\x61\x63\x6b\x20\x67\x72\x6f\x77\x74\x68\x20\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x77\x65\x64\x20\x69\x6e\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x69\x73\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x63\x6f\x6e\x6e\x65\x63\x74\x65\x64\x31\x33\x38\x37\x37\x37\x38\x37\x38\x30\x37\x38\x31\x34\x34\x35\x36\x37\x35\x35\x32\x39\x35\x33\x39\x35\x38\x35\x31\x31\x33\x35\x32\x35\x33\x39\x30\x36\x32\x35\x36\x39\x33\x38\x38\x39\x33\x39\x30\x33\x39\x30\x37\x32\x32\x38\x33\x37\x37\x36\x34\x37\x36\x39\x37\x39\x32\x35\x35\x36\x37\x36\x32\x36\x39\x35\x33\x31\x32\x35\x61\x64\x64\x72\x65\x73\x73\x20\x66\x61\x6d\x69\x6c\x79\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x62\x79\x20\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x62\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x50\x72\x65\x57\x72\x69\x74\x65\x3a\x20\x75\x6e\x61\x6c\x69\x67\x6e\x65\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x63\x61\x6e\x6e\x6f\x74\x20\x66\x72\x65\x65\x20\x77\x6f\x72\x6b\x62\x75\x66\x73\x20\x77\x68\x65\x6e\x20\x77\x6f\x72\x6b\x2e\x66\x75\x6c\x6c\x20\x21\x3d\x20\x30\x64\x65\x66\x65\x72\x70\x72\x6f\x63\x3a\x20\x64\x2e\x70\x61\x6e\x69\x63\x20\x21\x3d\x20\x6e\x69\x6c\x20\x61\x66\x74\x65\x72\x20\x6e\x65\x77\x64\x65\x66\x65\x72\x72\x65\x63\x65\x69\x76\x65\x64\x20\x62\x75\x74\x20\x68\x61\x6e\x64\x6c\x65\x72\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x73\x69\x67\x6e\x61\x6c\x20\x73\x74\x61\x63\x6b\x72\x65\x66\x69\x6c\x6c\x20\x6f\x66\x20\x73\x70\x61\x6e\x20\x77\x69\x74\x68\x20\x66\x72\x65\x65\x20\x73\x70\x61\x63\x65\x20\x72\x65\x6d\x61\x69\x6e\x69\x6e\x67\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x65\x74\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x62\x79\x74\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x73\x65\x74\x52\x75\x6e\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x72\x75\x6e\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x49\x6e\x64\x65\x78\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x72\x73\x74\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x76\x61\x6c\x75\x65\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f\x66\x20\x76\x61\x6c\x75\x65\x20\x61\x6c\x69\x67\x6e\x33\x34\x36\x39\x34\x34\x36\x39\x35\x31\x39\x35\x33\x36\x31\x34\x31\x38\x38\x38\x32\x33\x38\x34\x38\x39\x36\x32\x37\x38\x33\x38\x31\x33\x34\x37\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x74\x61\x63\x6b\x20\x66\x72\x65\x65\x63\x61\x6e\x27\x74\x20\x63\x61\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x6e\x20\x61\x20\x6e\x6f\x6e\x2d\x70\x6f\x69\x6e\x74\x65\x72\x20\x56\x61\x6c\x75\x65\x67\x63\x53\x77\x65\x65\x70\x20\x62\x65\x69\x6e\x67\x20\x64\x6f\x6e\x65\x20\x62\x75\x74\x20\x70\x68\x61\x73\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x43\x6f\x66\x66\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x73\x65\x63\x6f\x6e\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x2e\x6d\x61\x6b\x65\x6d\x61\x70\x3a\x20\x75\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x6d\x61\x70\x20\x6b\x65\x79\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x72\x65\x61\x64\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x20\x77\x69\x74\x68\x6f\x75\x74\x20\x74\x79\x70\x65\x73\x65\x74\x43\x68\x65\x63\x6b\x6d\x61\x72\x6b\x65\x64\x20\x61\x6e\x64\x20\x69\x73\x43\x68\x65\x63\x6b\x6d\x61\x72\x6b\x65\x64\x20\x64\x69\x73\x61\x67\x72\x65\x65\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x20\x28\x73\x74\x6f\x70\x77\x61\x69\x74\x20\x21\x3d\x20\x30\x29\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x41\x70\x70\x65\x6e\x64\x49\x6e\x74\x2f\x46\x6f\x72\x6d\x61\x74\x49\x6e\x74\x20\x62\x61\x73\x65\x31\x37\x33\x34\x37\x32\x33\x34\x37\x35\x39\x37\x36\x38\x30\x37\x30\x39\x34\x34\x31\x31\x39\x32\x34\x34\x38\x31\x33\x39\x31\x39\x30\x36\x37\x33\x38\x32\x38\x31\x32\x35\x38\x36\x37\x33\x36\x31\x37\x33\x37\x39\x38\x38\x34\x30\x33\x35\x34\x37\x32\x30\x35\x39\x36\x32\x32\x34\x30\x36\x39\x35\x39\x35\x33\x33\x36\x39\x31\x34\x30\x36\x32\x35\x61\x63\x71\x75\x69\x72\x65\x53\x75\x64\x6f\x67\x3a\x20\x66\x6f\x75\x6e\x64\x20\x73\x2e\x65\x6c\x65\x6d\x20\x21\x3d\x20\x6e\x69\x6c\x20\x69\x6e\x20\x63\x61\x63\x68\x65\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x61\x6c\x69\x67\x6e\x20\x69\x73\x20\x6e\x6f\x74\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x47\x43\x50\x72\x6f\x67\x3a\x20\x74\x6f\x74\x61\x6c\x20\x62\x69\x74\x73\x73\x79\x6e\x63\x2f\x61\x74\x6f\x6d\x69\x63\x3a\x20\x73\x74\x6f\x72\x65\x20\x6f\x66\x20\x6e\x69\x6c\x20\x76\x61\x6c\x75\x65\x20\x69\x6e\x74\x6f\x20\x56\x61\x6c\x75\x65\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x64\x75\x72\x69\x6e\x67\x20\x72\x75\x6e\x74\x69\x6d\x65\x20\x65\x78\x65\x63\x75\x74\x69\x6f\x6e\x67\x63\x42\x67\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x67\x63\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x4d\x6f\x64\x65\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x62\x65\x66\x6f\x72\x65\x20\x67\x6f\x65\x78\x69\x74\x50\x43\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x61\x74\x69\x6f\x6e\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x47\x43\x50\x72\x6f\x67\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x62\x69\x74\x20\x63\x6f\x75\x6e\x74\x69\x6e\x74\x65\x72\x72\x75\x70\x74\x65\x64\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x20\x73\x68\x6f\x75\x6c\x64\x20\x62\x65\x20\x72\x65\x73\x74\x61\x72\x74\x65\x64\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x52\x65\x61\x64\x20\x63\x61\x6c\x6c\x73\x20\x72\x65\x74\x75\x72\x6e\x20\x6e\x6f\x20\x64\x61\x74\x61\x20\x6f\x72\x20\x65\x72\x72\x6f\x72\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x4e\x61\x6d\x65\x46\x75\x6e\x63\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x49\x6d\x70\x6c\x65\x6d\x65\x6e\x74\x73\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x6e\x61\x6c\x69\x7a\x65\x72\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x73\x65\x74\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x72\x73\x74\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x6e\x69\x6c\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x62\x61\x64\x20\x6f\x6c\x64\x76\x61\x6c\x20\x67\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x72\x65\x6c\x65\x61\x73\x65\x53\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x67\x70\x2e\x70\x61\x72\x61\x6d\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x64\x75\x72\x69\x6e\x67\x20\x62\x6f\x6f\x74\x73\x74\x72\x61\x70\x20\x75\x73\x69\x6e\x67\x20\x76\x61\x6c\x75\x65\x20\x6f\x62\x74\x61\x69\x6e\x65\x64\x20\x75\x73\x69\x6e\x67\x20\x75\x6e\x65\x78\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x65\x6c\x64\x67\x63\x6d\x61\x72\x6b\x6e\x65\x77\x6f\x62\x6a\x65\x63\x74\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x68\x69\x6c\x65\x20\x64\x6f\x69\x6e\x67\x20\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x66\x75\x6e\x63\x4c\x61\x79\x6f\x75\x74\x20\x77\x69\x74\x68\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x72\x65\x63\x65\x69\x76\x65\x72\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6c\x66\x73\x74\x61\x63\x6b\x2e\x70\x75\x73\x68\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x61\x63\x6b\x69\x6e\x67\x3a\x20\x6e\x6f\x64\x65\x3d\x73\x79\x73\x74\x65\x6d\x73\x74\x61\x63\x6b\x20\x63\x61\x6c\x6c\x65\x64\x20\x66\x72\x6f\x6d\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x6e\x64\x20\x61\x66\x74\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x73\x68\x75\x74\x64\x6f\x77\x6e\x65\x78\x69\x74\x73\x79\x73\x63\x61\x6c\x6c\x3a\x20\x73\x79\x73\x63\x61\x6c\x6c\x20\x66\x72\x61\x6d\x65\x20\x69\x73\x20\x6e\x6f\x20\x6c\x6f\x6e\x67\x65\x72\x20\x76\x61\x6c\x69\x64\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x3a\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x70\x6f\x69\x6e\x74\x65\x72\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x65\x74\x68\x6f\x64\x20\x69\x6e\x64\x65\x78\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x41\x73\x73\x69\x67\x6e\x61\x62\x6c\x65\x54\x6f\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x52\x65\x6d\x6f\x76\x65\x20\x73\x70\x61\x6e\x2e\x6e\x70\x61\x67\x65\x73\x3d\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x61\x66\x74\x65\x72\x20\x74\x79\x70\x65\x20\x6e\x61\x6d\x65\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x43\x6f\x6e\x76\x65\x72\x74\x69\x62\x6c\x65\x54\x6f\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x63\x72\x65\x61\x74\x65\x20\x6e\x65\x77\x20\x4f\x53\x20\x74\x68\x72\x65\x61\x64\x20\x28\x68\x61\x76\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x61\x6d\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x61\x6e\x69\x63\x20\x62\x65\x66\x6f\x72\x65\x20\x6d\x61\x6c\x6c\x6f\x63\x20\x68\x65\x61\x70\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x65\x78\x74\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x20\x28\x73\x74\x61\x74\x75\x73\x20\x21\x3d\x20\x5f\x50\x67\x63\x73\x74\x6f\x70\x29\x50\x20\x68\x61\x73\x20\x63\x61\x63\x68\x65\x64\x20\x47\x43\x20\x77\x6f\x72\x6b\x20\x61\x74\x20\x65\x6e\x64\x20\x6f\x66\x20\x6d\x61\x72\x6b\x20\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x61\x74\x74\x65\x6d\x70\x74\x69\x6e\x67\x20\x74\x6f\x20\x6c\x69\x6e\x6b\x20\x69\x6e\x20\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x69\x65\x73\x50\x20\x68\x61\x73\x20\x75\x6e\x66\x6c\x75\x73\x68\x65\x64\x20\x73\x74\x61\x74\x73\x20\x61\x74\x20\x65\x6e\x64\x20\x6f\x66\x20\x6d\x61\x72\x6b\x20\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x6d\x61\x70\x20\x70\x61\x67\x65\x73\x20\x69\x6e\x20\x61\x72\x65\x6e\x61\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x41\x70\x70\x65\x6e\x64\x46\x6c\x6f\x61\x74\x2f\x46\x6f\x72\x6d\x61\x74\x46\x6c\x6f\x61\x74\x20\x62\x69\x74\x53\x69\x7a\x65\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x47\x77\x61\x69\x74\x69\x6e\x67\x20\x62\x75\x74\x20\x69\x73\x20\x47\x72\x75\x6e\x6e\x61\x62\x6c\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x65\x6d\x6f\x72\x79\x20\x61\x64\x64\x72\x65\x73\x73\x20\x6f\x72\x20\x6e\x69\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x72\x20\x69\x6e\x63\x6f\x6d\x70\x6c\x65\x74\x65\x20\x6d\x75\x6c\x74\x69\x62\x79\x74\x65\x20\x6f\x72\x20\x77\x69\x64\x65\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x61\x66\x74\x65\x72\x20\x70\x61\x63\x6b\x61\x67\x65\x20\x6e\x61\x6d\x65\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x6c\x69\x63\x65\x20\x6f\x66\x20\x75\x6e\x61\x64\x64\x72\x65\x73\x73\x61\x62\x6c\x65\x20\x61\x72\x72\x61\x79\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x21\x3d\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x20\x26\x26\x20\x66\x72\x65\x65\x49\x6e\x64\x65\x78\x20\x3d\x3d\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x2c\x20\x72\x65\x73\x74\x20\x21\x3d\x20\x30\x20\x62\x75\x74\x20\x6e\x65\x65\x64\x65\x64\x20\x3e\x20\x30\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x6e\x75\x6d\x20\x3e\x20\x64\x65\x6e\x3c\x3c\x73\x68\x69\x66\x74\x20\x69\x6e\x20\x61\x64\x6a\x75\x73\x74\x4c\x61\x73\x74\x44\x69\x67\x69\x74\x46\x69\x78\x65\x64\x77\x72\x69\x74\x65\x62\x61\x72\x72\x69\x65\x72\x70\x74\x72\x5f\x70\x72\x65\x77\x72\x69\x74\x65\x31\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6d\x70\x2e\x70\x20\x3d\x3d\x20\x6e\x69\x6c\x61\x74\x74\x65\x6d\x70\x74\x20\x74\x6f\x20\x65\x78\x65\x63\x75\x74\x65\x20\x73\x79\x73\x74\x65\x6d\x20\x73\x74\x61\x63\x6b\x20\x63\x6f\x64\x65\x20\x6f\x6e\x20\x75\x73\x65\x72\x20\x73\x74\x61\x63\x6b\x6d\x61\x6c\x6c\x6f\x63\x67\x63\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x67\x63\x70\x68\x61\x73\x65\x20\x3d\x3d\x20\x5f\x47\x43\x6d\x61\x72\x6b\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x72\x65\x63\x75\x72\x73\x69\x76\x65\x20\x63\x61\x6c\x6c\x20\x64\x75\x72\x69\x6e\x67\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x61\x74\x69\x6f\x6e\x20\x2d\x20\x6c\x69\x6e\x6b\x65\x72\x20\x73\x6b\x65\x77\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x73\x65\x72\x76\x65\x20\x61\x72\x65\x6e\x61\x20\x76\x69\x72\x74\x75\x61\x6c\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x3a\x20\x67\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x20\x73\x63\x61\x6e\x20\x73\x74\x61\x74\x65\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x20\x6e\x6f\x74\x20\x73\x6f\x72\x74\x65\x64\x20\x62\x79\x20\x70\x72\x6f\x67\x72\x61\x6d\x20\x63\x6f\x75\x6e\x74\x65\x72\x3a\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6e\x6f\x74\x20\x69\x6e\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x6c\x6f\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x73\x65\x20\x6f\x66\x20\x46\x69\x78\x41\x6c\x6c\x6f\x63\x5f\x41\x6c\x6c\x6f\x63\x20\x62\x65\x66\x6f\x72\x65\x20\x46\x69\x78\x41\x6c\x6c\x6f\x63\x5f\x49\x6e\x69\x74\x0a\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x74\x72\x69\x6e\x67\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x6f\x6e\x2d\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x49\x6d\x70\x6c\x65\x6d\x65\x6e\x74\x73\x09\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x6f\x6e\x20\x6f\x74\x68\x65\x72\x20\x74\x68\x72\x65\x61\x64\x3b\x20\x73\x74\x61\x63\x6b\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x0a\x67\x63\x43\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x53\x74\x61\x74\x65\x2e\x66\x69\x6e\x64\x52\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x62\x6c\x61\x63\x6b\x65\x6e\x69\x6e\x67\x20\x6e\x6f\x74\x20\x65\x6e\x61\x62\x6c\x65\x64\x6e\x6f\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x73\x20\x28\x6d\x61\x69\x6e\x20\x63\x61\x6c\x6c\x65\x64\x20\x72\x75\x6e\x74\x69\x6d\x65\x2e\x47\x6f\x65\x78\x69\x74\x29\x20\x2d\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x21\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x20\x64\x6f\x65\x73\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x20\x6d\x6f\x72\x65\x20\x74\x68\x61\x6e\x20\x35\x30\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x3a\x74\x6f\x70\x20\x67\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x20\x73\x63\x61\x6e\x20\x73\x74\x61\x74\x65\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x63\x61\x6e\x6e\x6f\x74\x20\x62\x65\x20\x75\x73\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x7a\x65\x72\x6f\x20\x73\x6b\x69\x70\x6e\x65\x77\x70\x72\x6f\x63\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x20\x66\x6f\x72\x20\x6e\x65\x77\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x3a\x20\x6c\x61\x73\x74\x20\x61\x72\x67\x20\x6f\x66\x20\x76\x61\x72\x69\x61\x64\x69\x63\x20\x66\x75\x6e\x63\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x75\x73\x65\x20\x6f\x66\x20\x6d\x61\x6b\x65\x4d\x65\x74\x68\x6f\x64\x56\x61\x6c\x75\x65\x69\x6e\x20\x67\x63\x4d\x61\x72\x6b\x20\x65\x78\x70\x65\x63\x74\x69\x6e\x67\x20\x74\x6f\x20\x73\x65\x65\x20\x67\x63\x70\x68\x61\x73\x65\x20\x61\x73\x20\x5f\x47\x43\x6d\x61\x72\x6b\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x63\x61\x6e\x6e\x6f\x74\x20\x74\x72\x61\x63\x65\x20\x75\x73\x65\x72\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x6f\x6e\x20\x69\x74\x73\x20\x6f\x77\x6e\x20\x73\x74\x61\x63\x6b\x6e\x6f\x6e\x2d\x47\x6f\x20\x63\x6f\x64\x65\x20\x73\x65\x74\x20\x75\x70\x20\x73\x69\x67\x6e\x61\x6c\x20\x68\x61\x6e\x64\x6c\x65\x72\x20\x77\x69\x74\x68\x6f\x75\x74\x20\x53\x41\x5f\x4f\x4e\x53\x54\x41\x43\x4b\x20\x66\x6c\x61\x67\x72\x75\x6e\x74\x69\x6d\x65\x3a\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x67\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x6f\x72\x20\x47\x73\x63\x61\x6e\x72\x75\x6e\x6e\x61\x62\x6c\x65\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x6d\x61\x70\x3a\x20\x74\x6f\x6f\x20\x6d\x75\x63\x68\x20\x6c\x6f\x63\x6b\x65\x64\x20\x6d\x65\x6d\x6f\x72\x79\x20\x28\x63\x68\x65\x63\x6b\x20\x27\x75\x6c\x69\x6d\x69\x74\x20\x2d\x6c\x27\x29\x2e\x0a\x73\x79\x6e\x63\x2f\x61\x74\x6f\x6d\x69\x63\x3a\x20\x73\x74\x6f\x72\x65\x20\x6f\x66\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x6c\x79\x20\x74\x79\x70\x65\x64\x20\x76\x61\x6c\x75\x65\x20\x69\x6e\x74\x6f\x20\x56\x61\x6c\x75\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x61\x79\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x69\x6e\x63\x72\x65\x61\x73\x65\x20\x6d\x61\x78\x20\x75\x73\x65\x72\x20\x70\x72\x6f\x63\x65\x73\x73\x65\x73\x20\x28\x75\x6c\x69\x6d\x69\x74\x20\x2d\x75\x29\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x63\x72\x65\x61\x74\x69\x6e\x67\x20\x61\x20\x6e\x61\x6d\x65\x20\x77\x69\x74\x68\x20\x61\x20\x70\x61\x63\x6b\x61\x67\x65\x20\x70\x61\x74\x68\x20\x69\x73\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x66\x6f\x75\x6e\x64\x20\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x47\x6f\x20\x68\x65\x61\x70\x20\x28\x69\x6e\x63\x6f\x72\x72\x65\x63\x74\x20\x75\x73\x65\x20\x6f\x66\x20\x75\x6e\x73\x61\x66\x65\x20\x6f\x72\x20\x63\x67\x6f\x3f\x29\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x6d\x69\x73\x75\x73\x65\x20\x6f\x66\x20\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x2f\x75\x6e\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6e\x6f\x74\x20\x61\x74\x20\x62\x65\x67\x69\x6e\x6e\x69\x6e\x67\x20\x6f\x66\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x6c\x6f\x63\x6b\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x65\x78\x74\x46\x6c\x6f\x61\x74\x2e\x46\x69\x78\x65\x64\x44\x65\x63\x69\x6d\x61\x6c\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x20\x3d\x3d\x20\x30\x72\x75\x6e\x74\x69\x6d\x65\x3a\x67\x72\x65\x79\x6f\x62\x6a\x65\x63\x74\x3a\x20\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x73\x20\x66\x69\x6e\x64\x73\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x75\x6e\x6d\x61\x72\x6b\x65\x64\x20\x6f\x62\x6a\x65\x63\x74\x20\x6f\x62\x6a\x3d\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x6e\x74\x65\x72\x66\x61\x63\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x74\x75\x72\x6e\x20\x76\x61\x6c\x75\x65\x20\x6f\x62\x74\x61\x69\x6e\x65\x64\x20\x66\x72\x6f\x6d\x20\x75\x6e\x65\x78\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x65\x6c\x64\x20\x6f\x72\x20\x6d\x65\x74\x68\x6f\x64\x30\x30\x30\x31\x30\x32\x30\x33\x30\x34\x30\x35\x30\x36\x30\x37\x30\x38\x30\x39\x31\x30\x31\x31\x31\x32\x31\x33\x31\x34\x31\x35\x31\x36\x31\x37\x31\x38\x31\x39\x32\x30\x32\x31\x32\x32\x32\x33\x32\x34\x32\x35\x32\x36\x32\x37\x32\x38\x32\x39\x33\x30\x33\x31\x33\x32\x33\x33\x33\x34\x33\x35\x33\x36\x33\x37\x33\x38\x33\x39\x34\x30\x34\x31\x34\x32\x34\x33\x34\x34\x34\x35\x34\x36\x34\x37\x34\x38\x34\x39\x35\x30\x35\x31\x35\x32\x35\x33\x35\x34\x35\x35\x35\x36\x35\x37\x35\x38\x35\x39\x36\x30\x36\x31\x36\x32\x36\x33\x36\x34\x36\x35\x36\x36\x36\x37\x36\x38\x36\x39\x37\x30\x37\x31\x37\x32\x37\x33\x37\x34\x37\x35\x37\x36\x37\x37\x37\x38\x37\x39\x38\x30\x38\x31\x38\x32\x38\x33\x38\x34\x38\x35\x38\x36\x38\x37\x38\x38\x38\x39\x39\x30\x39\x31\x39\x32\x39\x33\x39\x34\x39\x35\x39\x36\x39\x37\x39\x38\x39\x39"; // 0x80e1680
int32_t g15 = 0x67736163; // 0x80e193b
int32_t g16 = 0x2e706720; // 0x80e19dd
int32_t g17 = 0x61746166; // 0x80e1f4a
int32_t g18 = 0x746e7572; // 0x80e31af
int32_t g19 = 0x2e706720; // 0x80e324f
char * g20 = "\x72\x74\x5f\x73\x69\x67\x61\x63\x74\x69\x6f\x6e\x20\x72\x65\x61\x64\x20\x66\x61\x69\x6c\x75\x72\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x72\x6f\x67\x72\x61\x6d\x20\x65\x78\x63\x65\x65\x64\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\xc2\xb7\x6c\x6f\x63\x6b\x3a\x20\x6c\x6f\x63\x6b\x20\x63\x6f\x75\x6e\x74\x73\x6c\x69\x63\x65\x20\x62\x6f\x75\x6e\x64\x73\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x6f\x63\x6b\x65\x74\x20\x74\x79\x70\x65\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x73\x74\x61\x72\x74\x6d\x3a\x20\x70\x20\x68\x61\x73\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x67\x73\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x6e\x6f\x74\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x66\x61\x75\x6c\x74\x20\x61\x64\x64\x72\x65\x73\x73\x20\x20\x75\x73\x69\x6e\x67\x20\x75\x6e\x61\x64\x64\x72\x65\x73\x73\x61\x62\x6c\x65\x20\x76\x61\x6c\x75\x65\x31\x34\x35\x35\x31\x39\x31\x35\x32\x32\x38\x33\x36\x36\x38\x35\x31\x38\x30\x36\x36\x34\x30\x36\x32\x35\x37\x32\x37\x35\x39\x35\x37\x36\x31\x34\x31\x38\x33\x34\x32\x35\x39\x30\x33\x33\x32\x30\x33\x31\x32\x35\x53\x49\x47\x53\x54\x4f\x50\x3a\x20\x73\x74\x6f\x70\x2c\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x61\x62\x6c\x65\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x73\x65\x6d\x61\x70\x68\x6f\x72\x65\x20\x74\x69\x63\x6b\x65\x74\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x66\x6f\x72\x45\x61\x63\x68\x50\x3a\x20\x50\x20\x64\x69\x64\x20\x6e\x6f\x74\x20\x72\x75\x6e\x20\x66\x6e\x66\x72\x65\x65\x53\x70\x61\x6e\x20\x67\x69\x76\x65\x6e\x20\x63\x61\x63\x68\x65\x64\x20\x73\x70\x61\x6e\x66\x72\x65\x65\x64\x65\x66\x65\x72\x20\x77\x69\x74\x68\x20\x64\x2e\x66\x6e\x20\x21\x3d\x20\x6e\x69\x6c\x69\x6e\x69\x74\x53\x70\x61\x6e\x3a\x20\x75\x6e\x61\x6c\x69\x67\x6e\x65\x64\x20\x6c\x65\x6e\x67\x74\x68\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x65\x71\x75\x65\x73\x74\x20\x64\x65\x73\x63\x72\x69\x70\x74\x6f\x72\x6e\x61\x6d\x65\x20\x6e\x6f\x74\x20\x75\x6e\x69\x71\x75\x65\x20\x6f\x6e\x20\x6e\x65\x74\x77\x6f\x72\x6b\x6e\x6f\x20\x43\x53\x49\x20\x73\x74\x72\x75\x63\x74\x75\x72\x65\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x6f\x20\x6d\x65\x73\x73\x61\x67\x65\x20\x6f\x66\x20\x64\x65\x73\x69\x72\x65\x64\x20\x74\x79\x70\x65\x6e\x6f\x74\x65\x77\x61\x6b\x65\x75\x70\x20\x2d\x20\x64\x6f\x75\x62\x6c\x65\x20\x77\x61\x6b\x65\x75\x70\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x20\x28\x73\x74\x61\x63\x6b\x61\x6c\x6c\x6f\x63\x29\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x73\x69\x7a\x65\x20\x3d\x3d\x20\x30\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x43\x61\x6e\x49\x6e\x74\x65\x72\x66\x61\x63\x65\x72\x65\x71\x75\x69\x72\x65\x64\x20\x6b\x65\x79\x20\x6e\x6f\x74\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x2e\x73\x74\x61\x74\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x72\x69\x74\x65\x62\x61\x72\x72\x69\x65\x72\x70\x74\x72\x20\x2a\x73\x74\x61\x72\x74\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x6c\x6f\x63\x6b\x65\x64\x20\x74\x6f\x20\x6d\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x61\x73\x73\x69\x67\x6e\x61\x62\x6c\x65\x20\x74\x6f\x20\x74\x79\x70\x65\x20\x33\x36\x33\x37\x39\x37\x38\x38\x30\x37\x30\x39\x31\x37\x31\x32\x39\x35\x31\x36\x36\x30\x31\x35\x36\x32\x35\x47\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x6c\x69\x73\x74\x20\x69\x73\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x53\x49\x47\x49\x4c\x4c\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x69\x6e\x73\x74\x72\x75\x63\x74\x69\x6f\x6e\x53\x49\x47\x58\x43\x50\x55\x3a\x20\x63\x70\x75\x20\x6c\x69\x6d\x69\x74\x20\x65\x78\x63\x65\x65\x64\x65\x64\x63\x68\x61\x6e\x6e\x65\x6c\x20\x6e\x75\x6d\x62\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x63\x6f\x6d\x6d\x75\x6e\x69\x63\x61\x74\x69\x6f\x6e\x20\x65\x72\x72\x6f\x72\x20\x6f\x6e\x20\x73\x65\x6e\x64\x67\x63\x73\x74\x6f\x70\x6d\x3a\x20\x6e\x6f\x74\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x67\x63\x67\x72\x6f\x77\x73\x6c\x69\x63\x65\x3a\x20\x63\x61\x70\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x20\x65\x72\x72\x6f\x72\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x72\x6f\x66\x69\x6c\x65\x20\x62\x75\x63\x6b\x65\x74\x20\x74\x79\x70\x65\x6b\x65\x79\x20\x77\x61\x73\x20\x72\x65\x6a\x65\x63\x74\x65\x64\x20\x62\x79\x20\x73\x65\x72\x76\x69\x63\x65\x6c\x61\x72\x67\x65\x20\x73\x70\x61\x6e\x20\x74\x72\x65\x61\x70\x20\x72\x6f\x74\x61\x74\x65\x4c\x65\x66\x74\x6d\x61\x6b\x65\x63\x68\x61\x6e\x3a\x20\x73\x69\x7a\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6d\x61\x6b\x65\x73\x6c\x69\x63\x65\x3a\x20\x63\x61\x70\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6d\x61\x6b\x65\x73\x6c\x69\x63\x65\x3a\x20\x6c\x65\x6e\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6e\x6f\x74\x20\x61\x20\x58\x45\x4e\x49\x58\x20\x6e\x61\x6d\x65\x64\x20\x74\x79\x70\x65\x20\x66\x69\x6c\x65\x70\x72\x6f\x67\x54\x6f\x50\x6f\x69\x6e\x74\x65\x72\x4d\x61\x73\x6b\x3a\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x72\x65\x73\x74\x61\x72\x74\x67\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x61\x74\x75\x73\x72\x75\x6e\x6c\x6f\x63\x6b\x20\x6f\x66\x20\x75\x6e\x6c\x6f\x63\x6b\x65\x64\x20\x72\x77\x6d\x75\x74\x65\x78\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x66\x69\x6e\x64\x20\x67\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x6e\x6d\x69\x64\x6c\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x69\x6e\x69\x74\x20\x66\x61\x69\x6c\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\xc2\xb7\x75\x6e\x6c\x6f\x63\x6b\x3a\x20\x6c\x6f\x63\x6b\x20\x63\x6f\x75\x6e\x74\x73\x63\x61\x6e\x66\x72\x61\x6d\x65\x3a\x20\x62\x61\x64\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x73\x69\x67\x6e\x61\x6c\x20\x72\x65\x63\x65\x69\x76\x65\x64\x20\x64\x75\x72\x69\x6e\x67\x20\x66\x6f\x72\x6b\x73\x69\x67\x73\x65\x6e\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x73\x74\x61\x74\x65\x73\x74\x61\x63\x6b\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x73\x74\x61\x72\x74\x6d\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x68\x6f\x6c\x64\x69\x6e\x67\x20\x6c\x6f\x63\x6b\x73\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6e\x61\x6d\x65\x77\x6f\x72\x6b\x2e\x6e\x77\x61\x69\x74\x20\x77\x61\x73\x20\x3e\x20\x77\x6f\x72\x6b\x2e\x6e\x70\x72\x6f\x63\x20\x61\x72\x67\x73\x20\x73\x74\x61\x63\x6b\x20\x6d\x61\x70\x20\x65\x6e\x74\x72\x69\x65\x73\x20\x66\x6f\x72\x20\x31\x38\x31\x38\x39\x38\x39\x34\x30\x33\x35\x34\x35\x38\x35\x36\x34\x37\x35\x38\x33\x30\x30\x37\x38\x31\x32\x35\x39\x30\x39\x34\x39\x34\x37\x30\x31\x37\x37\x32\x39\x32\x38\x32\x33\x37\x39\x31\x35\x30\x33\x39\x30\x36\x32\x35\x46\x69\x78\x65\x64\x53\x74\x61\x63\x6b\x20\x69\x73\x20\x6e\x6f\x74\x20\x70\x6f\x77\x65\x72\x2d\x6f\x66\x2d\x32\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x73\x70\x61\x6e\x20\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x6d\x20\x69\x73\x20\x6e\x6f\x74\x20\x6c\x6f\x63\x6b\x65\x64\x50\x72\x65\x70\x65\x6e\x64\x65\x64\x5f\x43\x6f\x6e\x63\x61\x74\x65\x6e\x61\x74\x69\x6f\x6e\x5f\x4d\x61\x72\x6b\x53\x49\x47\x48\x55\x50\x3a\x20\x74\x65\x72\x6d\x69\x6e\x61\x6c\x20\x6c\x69\x6e\x65\x20\x68\x61\x6e\x67\x75\x70\x53\x49\x47\x57\x49\x4e\x43\x48\x3a\x20\x77\x69\x6e\x64\x6f\x77\x20\x73\x69\x7a\x65\x20\x63\x68\x61\x6e\x67\x65\x5f\x6d\x68\x65\x61\x70\x5f\x61\x6c\x6c\x6f\x63\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x67\x30\x20\x73\x74\x61\x63\x6b\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x77\x72\x69\x74\x65\x20\x62\x61\x72\x72\x69\x65\x72\x63\x61\x6e\x27\x74\x20\x70\x72\x65\x73\x65\x72\x76\x65\x20\x75\x6e\x6c\x69\x6e\x6b\x65\x64\x20\x73\x70\x61\x6e\x63\x6f\x6d\x70\x61\x72\x69\x6e\x67\x20\x75\x6e\x63\x6f\x6d\x70\x61\x72\x61\x62\x6c\x65\x20\x74\x79\x70\x65\x20\x64\x65\x73\x74\x69\x6e\x61\x74\x69\x6f\x6e\x20\x61\x64\x64\x72\x65\x73\x73\x20\x72\x65\x71\x75\x69\x72\x65\x64\x66\x61\x74\x61\x6c\x3a\x20\x6d\x6f\x72\x65\x73\x74\x61\x63\x6b\x20\x6f\x6e\x20\x67\x73\x69\x67\x6e\x61\x6c\x0a\x66\x69\x6c\x65\x20\x64\x65\x73\x63\x72\x69\x70\x74\x6f\x72\x20\x69\x6e\x20\x62\x61\x64\x20\x73\x74\x61\x74\x65\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x20\x77\x69\x74\x68\x20\x70\x67\x63\x68\x65\x6c\x70\x65\x72\x73\x74\x61\x72\x74\x3a\x20\x62\x61\x64\x20\x6d\x2d\x3e\x68\x65\x6c\x70\x67\x63\x67\x63\x73\x74\x6f\x70\x6d\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x69\x6e\x76\x61\x6c\x69\x64\x20\x72\x75\x6e\x74\x69\x6d\x65\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x6c\x61\x72\x67\x65\x20\x73\x70\x61\x6e\x20\x74\x72\x65\x61\x70\x20\x72\x6f\x74\x61\x74\x65\x52\x69\x67\x68\x74\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x20\x69\x6e\x20\x73\x68\x72\x69\x6e\x6b\x73\x74\x61\x63\x6b\x6e\x65\x65\x64\x20\x70\x61\x64\x64\x69\x6e\x67\x20\x69\x6e\x20\x62\x75\x63\x6b\x65\x74\x20\x28\x6b\x65\x79\x29\x6e\x65\x77\x70\x72\x6f\x63\x31\x3a\x20\x6e\x65\x77\x20\x67\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x64\x65\x61\x64\x6e\x65\x77\x70\x72\x6f\x63\x31\x3a\x20\x6e\x65\x77\x67\x20\x6d\x69\x73\x73\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x6e\x6f\x74\x65\x77\x61\x6b\x65\x75\x70\x20\x2d\x20\x64\x6f\x75\x62\x6c\x65\x20\x77\x61\x6b\x65\x75\x70\x20\x28\x6f\x73\x3a\x20\x70\x72\x6f\x63\x65\x73\x73\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x66\x69\x6e\x69\x73\x68\x65\x64\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x64\x72\x69\x76\x65\x72\x20\x6e\x6f\x74\x20\x61\x74\x74\x61\x63\x68\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x49\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4b\x65\x79\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x6d\x61\x70\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x6f\x6c\x64\x76\x61\x6c\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x6f\x20\x6d\x6f\x64\x75\x6c\x65\x20\x64\x61\x74\x61\x20\x66\x6f\x72\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x2e\x67\x63\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x4d\x6f\x64\x65\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x74\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x3a\x20\x76\x61\x6c\x20\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\xce\xb5\x20\x3e\x20\x28\x64\x65\x6e\x3c\x3c\x73\x68\x69\x66\x74\x29\x2f\x32\x34\x35\x34\x37\x34\x37\x33\x35\x30\x38\x38\x36\x34\x36\x34\x31\x31\x38\x39\x35\x37\x35\x31\x39\x35\x33\x31\x32\x35\x53\x49\x47\x50\x49\x50\x45\x3a\x20\x77\x72\x69\x74\x65\x20\x74\x6f\x20\x62\x72\x6f\x6b\x65\x6e\x20\x70\x69\x70\x65\x53\x49\x47\x50\x57\x52\x3a\x20\x70\x6f\x77\x65\x72\x20\x66\x61\x69\x6c\x75\x72\x65\x20\x72\x65\x73\x74\x61\x72\x74\x61\x62\x69\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x20\x64\x65\x74\x65\x63\x74\x65\x64\x20\x62\x65\x74\x77\x65\x65\x6e\x61\x64\x64\x73\x70\x65\x63\x69\x61\x6c\x20\x6f\x6e\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x67\x63\x20\x64\x6f\x6e\x65\x20\x62\x75\x74\x20\x67\x63\x70\x68\x61\x73\x65\x20\x21\x3d\x20\x5f\x47\x43\x6f\x66\x66\x67\x66\x70\x75\x74\x3a\x20\x62\x61\x64\x20\x73\x74\x61\x74\x75\x73\x20\x28\x6e\x6f\x74\x20\x47\x64\x65\x61\x64\x29\x69\x6e\x76\x61\x6c\x69\x64\x20\x6c\x65\x6e\x67\x74\x68\x20\x6f\x66\x20\x74\x72\x61\x63\x65\x20\x65\x76\x65\x6e\x74\x69\x6f\x3a\x20\x72\x65\x61\x64\x2f\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x65\x64\x20\x70\x69\x70\x65\x6d\x61\x63\x68\x69\x6e\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x74\x68\x65\x20\x6e\x65\x74\x77\x6f\x72\x6b\x6e\x6f\x20\x58\x45\x4e\x49\x58\x20\x73\x65\x6d\x61\x70\x68\x6f\x72\x65\x73\x20\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x6e\x75\x6d\x65\x72\x69\x63\x61\x6c\x20\x72\x65\x73\x75\x6c\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x70\x72\x6f\x67\x72\x65\x73\x73\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x66\x61\x6d\x69\x6c\x79\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x45\x6c\x65\x6d\x20\x6f\x66\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x67\x20\x69\x6e\x20\x63\x67\x6f\x63\x61\x6c\x6c\x62\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6d\x70\x6f\x73\x73\x69\x62\x6c\x65\x20\x74\x79\x70\x65\x20\x6b\x69\x6e\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x61\x72\x6b\x69\x6e\x67\x20\x66\x72\x65\x65\x20\x6f\x62\x6a\x65\x63\x74\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x6d\x61\x70\x3a\x20\x61\x63\x63\x65\x73\x73\x20\x64\x65\x6e\x69\x65\x64\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x70\x6c\x69\x74\x20\x73\x74\x61\x63\x6b\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x74\x20\x75\x6e\x64\x65\x72\x66\x6c\x6f\x77\x3a\x20\x76\x61\x6c\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x70\x63\x20\x69\x6e\x20\x64\x65\x66\x65\x72\x20\x73\x65\x6d\x61\x63\x71\x75\x69\x72\x65\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x74\x68\x65\x20\x47\x20\x73\x74\x61\x63\x6b\x73\x74\x72\x69\x6e\x67\x20\x63\x6f\x6e\x63\x61\x74\x65\x6e\x61\x74\x69\x6f\x6e\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x73\x79\x6e\x74\x61\x78\x20\x65\x72\x72\x6f\x72\x20\x73\x63\x61\x6e\x6e\x69\x6e\x67\x20\x62\x6f\x6f\x6c\x65\x61\x6e\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6f\x70\x65\x6e\x20\x66\x69\x6c\x65\x73\x20\x69\x6e\x20\x73\x79\x73\x74\x65\x6d\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x68\x61\x73\x20\x6c\x65\x66\x74\x6f\x76\x65\x72\x20\x64\x65\x66\x65\x72\x73\x20\x6c\x6f\x63\x61\x6c\x73\x20\x73\x74\x61\x63\x6b\x20\x6d\x61\x70\x20\x65\x6e\x74\x72\x69\x65\x73\x20\x66\x6f\x72\x20\x32\x32\x37\x33\x37\x33\x36\x37\x35\x34\x34\x33\x32\x33\x32\x30\x35\x39\x34\x37\x38\x37\x35\x39\x37\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x41\x6c\x6c\x6f\x63\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x62\x61\x64\x20\x6e\x70\x61\x67\x65\x73\x53\x49\x47\x50\x52\x4f\x46\x3a\x20\x70\x72\x6f\x66\x69\x6c\x69\x6e\x67\x20\x61\x6c\x61\x72\x6d\x20\x63\x6c\x6f\x63\x6b\x53\x49\x47\x55\x53\x52\x31\x3a\x20\x75\x73\x65\x72\x2d\x64\x65\x66\x69\x6e\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x31\x53\x49\x47\x55\x53\x52\x32\x3a\x20\x75\x73\x65\x72\x2d\x64\x65\x66\x69\x6e\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x32\x53\x49\x47\x56\x54\x41\x4c\x52\x4d\x3a\x20\x76\x69\x72\x74\x75\x61\x6c\x20\x61\x6c\x61\x72\x6d\x20\x63\x6c\x6f\x63\x6b\x61\x73\x73\x69\x67\x6e\x6d\x65\x6e\x74\x20\x74\x6f\x20\x65\x6e\x74\x72\x79\x20\x69\x6e\x20\x6e\x69\x6c\x20\x6d\x61\x70\x63\x68\x65\x63\x6b\x64\x65\x61\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x63\x6f\x75\x6e\x74\x73\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x67\x65\x74\x20\x73\x79\x73\x74\x65\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x66\x72\x65\x65\x64\x65\x66\x65\x72\x20\x77\x69\x74\x68\x20\x64\x2e\x5f\x70\x61\x6e\x69\x63\x20\x21\x3d\x20\x6e\x69\x6c\x69\x6e\x61\x70\x70\x72\x6f\x70\x72\x69\x61\x74\x65\x20\x69\x6f\x63\x74\x6c\x20\x66\x6f\x72\x20\x64\x65\x76\x69\x63\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x0a\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x66\x6f\x75\x6e\x64\x20\x6f\x6e\x20\x73\x74\x61\x63\x6b\x6e\x65\x65\x64\x20\x70\x61\x64\x64\x69\x6e\x67\x20\x69\x6e\x20\x62\x75\x63\x6b\x65\x74\x20\x28\x76\x61\x6c\x75\x65\x29\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x20\x77\x72\x6f\x6e\x67\x20\x74\x79\x70\x65\x20\x66\x6f\x72\x20\x73\x6f\x63\x6b\x65\x74\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4c\x65\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x61\x72\x72\x61\x79\x20\x74\x79\x70\x65\x72\x75\x6e\x71\x70\x75\x74\x73\x6c\x6f\x77\x3a\x20\x71\x75\x65\x75\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x66\x75\x6c\x6c\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x66\x72\x61\x6d\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x6f\x75\x6e\x64\x20\x69\x6e\x20\x6f\x62\x6a\x65\x63\x74\x20\x61\x74\x20\x2a\x28\x73\x6f\x63\x6b\x65\x74\x20\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x6e\x6f\x6e\x2d\x73\x6f\x63\x6b\x65\x74\x73\x79\x6e\x63\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6d\x75\x74\x65\x78\x20\x73\x74\x61\x74\x65\x73\x79\x6e\x63\x3a\x20\x75\x6e\x6c\x6f\x63\x6b\x20\x6f\x66\x20\x75\x6e\x6c\x6f\x63\x6b\x65\x64\x20\x6d\x75\x74\x65\x78\x2e\x2e\x2e\x61\x64\x64\x69\x74\x69\x6f\x6e\x61\x6c\x20\x66\x72\x61\x6d\x65\x73\x20\x65\x6c\x69\x64\x65\x64\x2e\x2e\x2e\x0a\x2e\x6c\x69\x62\x20\x73\x65\x63\x74\x69\x6f\x6e\x20\x69\x6e\x20\x61\x2e\x6f\x75\x74\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x31\x31\x33\x36\x38\x36\x38\x33\x37\x37\x32\x31\x36\x31\x36\x30\x32\x39\x37\x33\x39\x33\x37\x39\x38\x38\x32\x38\x31\x32\x35\x35\x36\x38\x34\x33\x34\x31\x38\x38\x36\x30\x38\x30\x38\x30\x31\x34\x38\x36\x39\x36\x38\x39\x39\x34\x31\x34\x30\x36\x32\x35\x53\x49\x47\x53\x45\x47\x56\x3a\x20\x73\x65\x67\x6d\x65\x6e\x74\x61\x74\x69\x6f\x6e\x20\x76\x69\x6f\x6c\x61\x74\x69\x6f\x6e\x63\x61\x6e\x6e\x6f\x74\x20\x61\x73\x73\x69\x67\x6e\x20\x72\x65\x71\x75\x65\x73\x74\x65\x64\x20\x61\x64\x64\x72\x65\x73\x73\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x62\x61\x64\x20\x69\x6e\x63\x6f\x6d\x69\x6e\x67\x20\x76\x61\x6c\x75\x65\x73\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x20\x66\x6f\x75\x6e\x64\x20\x75\x6e\x6d\x61\x72\x6b\x65\x64\x20\x6f\x62\x6a\x65\x63\x74\x65\x6e\x74\x65\x72\x73\x79\x73\x63\x61\x6c\x6c\x62\x6c\x6f\x63\x6b\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x66\x6d\x74\x3a\x20\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x62\x61\x73\x65\x3b\x20\x63\x61\x6e\x27\x74\x20\x68\x61\x70\x70\x65\x6e\x69\x6e\x73\x65\x72\x74\x69\x6e\x67\x20\x73\x70\x61\x6e\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x69\x6e\x20\x74\x72\x65\x61\x70\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x20\x2d\x20\x6d\x69\x73\x75\x73\x65\x20\x6f\x66\x20\x69\x74\x61\x62\x6d\x61\x6c\x66\x6f\x72\x6d\x65\x64\x20\x74\x69\x6d\x65\x20\x7a\x6f\x6e\x65\x20\x69\x6e\x66\x6f\x72\x6d\x61\x74\x69\x6f\x6e\x6e\x6f\x6e\x20\x69\x6e\x2d\x75\x73\x65\x20\x73\x70\x61\x6e\x20\x69\x6e\x20\x75\x6e\x73\x77\x65\x70\x74\x20\x6c\x69\x73\x74\x70\x61\x63\x65\x72\x3a\x20\x73\x77\x65\x65\x70\x20\x64\x6f\x6e\x65\x20\x61\x74\x20\x68\x65\x61\x70\x20\x73\x69\x7a\x65\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x49\x6e\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x73\x65\x74\x73\x70\x69\x6e\x6e\x69\x6e\x67\x3a\x20\x6e\x6f\x74\x20\x61\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x20\x6d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x20\x63\x6f\x6e\x66\x6c\x69\x63\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x6d\x65\x6d\x6f\x72\x79\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x70\x6c\x69\x74\x20\x73\x74\x61\x63\x6b\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x3a\x20\x32\x38\x34\x32\x31\x37\x30\x39\x34\x33\x30\x34\x30\x34\x30\x30\x37\x34\x33\x34\x38\x34\x34\x39\x37\x30\x37\x30\x33\x31\x32\x35\x53\x49\x47\x46\x50\x45\x3a\x20\x66\x6c\x6f\x61\x74\x69\x6e\x67\x2d\x70\x6f\x69\x6e\x74\x20\x65\x78\x63\x65\x70\x74\x69\x6f\x6e\x53\x49\x47\x54\x54\x4f\x55\x3a\x20\x62\x61\x63\x6b\x67\x72\x6f\x75\x6e\x64\x20\x77\x72\x69\x74\x65\x20\x74\x6f\x20\x74\x74\x79\x67\x63\x68\x65\x6c\x70\x65\x72\x20\x6e\x6f\x74\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x6f\x6e\x20\x67\x30\x20\x73\x74\x61\x63\x6b\x6e\x6f\x6e\x2d\x47\x6f\x20\x63\x6f\x64\x65\x20\x64\x69\x73\x61\x62\x6c\x65\x64\x20\x73\x69\x67\x61\x6c\x74\x73\x74\x61\x63\x6b\x6e\x75\x6d\x65\x72\x69\x63\x61\x6c\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x64\x6f\x6d\x61\x69\x6e\x70\x61\x6e\x69\x63\x20\x77\x68\x69\x6c\x65\x20\x70\x72\x69\x6e\x74\x69\x6e\x67\x20\x70\x61\x6e\x69\x63\x20\x76\x61\x6c\x75\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x6e\x61\x6d\x65\x46\x72\x6f\x6d\x3a\x20\x74\x61\x67\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x4f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x6d\x6f\x76\x65\x73\x70\x65\x63\x69\x61\x6c\x20\x6f\x6e\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x72\x65\x73\x6f\x75\x72\x63\x65\x20\x74\x65\x6d\x70\x6f\x72\x61\x72\x69\x6c\x79\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x65\x70\x6f\x6c\x6c\x63\x72\x65\x61\x74\x65\x20\x66\x61\x69\x6c\x65\x64\x20\x77\x69\x74\x68\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x63\x61\x6c\x6c\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x72\x65\x74\x75\x72\x6e\x65\x64\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x20\x63\x61\x6c\x6c\x65\x64\x20\x66\x72\x6f\x6d\x20\x67\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x74\x61\x63\x6b\x20\x73\x70\x6c\x69\x74\x20\x61\x74\x20\x62\x61\x64\x20\x74\x69\x6d\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x65\x6c\x65\x6d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x6e\x65\x78\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x70\x72\x65\x76\x73\x63\x61\x6e\x73\x74\x61\x63\x6b\x3a\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x73\x6f\x66\x74\x77\x61\x72\x65\x20\x63\x61\x75\x73\x65\x64\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x61\x62\x6f\x72\x74\x73\x74\x61\x63\x6b\x6d\x61\x70\x64\x61\x74\x61\x3a\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x77\x65\x65\x70\x20\x69\x6e\x63\x72\x65\x61\x73\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x63\x6f\x75\x6e\x74\x75\x73\x65\x20\x6f\x66\x20\x63\x6c\x6f\x73\x65\x64\x20\x6e\x65\x74\x77\x6f\x72\x6b\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x6f\x66\x20\x6d\x65\x74\x68\x6f\x64\x20\x6f\x6e\x20\x6e\x69\x6c\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x76\x61\x6c\x75\x65\x31\x34\x32\x31\x30\x38\x35\x34\x37\x31\x35\x32\x30\x32\x30\x30\x33\x37\x31\x37\x34\x32\x32\x34\x38\x35\x33\x35\x31\x35\x36\x32\x35\x37\x31\x30\x35\x34\x32\x37\x33\x35\x37\x36\x30\x31\x30\x30\x31\x38\x35\x38\x37\x31\x31\x32\x34\x32\x36\x37\x35\x37\x38\x31\x32\x35\x53\x49\x47\x43\x48\x4c\x44\x3a\x20\x63\x68\x69\x6c\x64\x20\x73\x74\x61\x74\x75\x73\x20\x68\x61\x73\x20\x63\x68\x61\x6e\x67\x65\x64\x53\x49\x47\x54\x54\x49\x4e\x3a\x20\x62\x61\x63\x6b\x67\x72\x6f\x75\x6e\x64\x20\x72\x65\x61\x64\x20\x66\x72\x6f\x6d\x20\x74\x74\x79\x53\x49\x47\x58\x46\x53\x5a\x3a\x20\x66\x69\x6c\x65\x20\x73\x69\x7a\x65\x20\x6c\x69\x6d\x69\x74\x20\x65\x78\x63\x65\x65\x64\x65\x64\x63\x6f\x6e\x63\x75\x72\x72\x65\x6e\x74\x20\x6d\x61\x70\x20\x72\x65\x61\x64\x20\x61\x6e\x64\x20\x6d\x61\x70\x20\x77\x72\x69\x74\x65\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x6e\x6d\x73\x70\x69\x6e\x6e\x69\x6e\x67\x66\x72\x65\x65\x69\x6e\x67\x20\x73\x74\x61\x63\x6b\x20\x6e\x6f\x74\x20\x69\x6e\x20\x61\x20\x73\x74\x61\x63\x6b\x20\x73\x70\x61\x6e\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x68\x69\x66\x74\x72\x65\x66\x6c\x65\x63\x74\x2e\x6e\x61\x6d\x65\x46\x72\x6f\x6d\x3a\x20\x6e\x61\x6d\x65\x20\x74\x6f\x6f\x20\x6c\x6f\x6e\x67\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x43\x68\x61\x6e\x44\x69\x72\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x63\x68\x61\x6e\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x61\x72\x72\x61\x79\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x74\x6f\x67\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x6f\x6c\x64\x76\x61\x6c\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x73\x74\x61\x63\x6b\x20\x65\x78\x63\x65\x65\x64\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x65\x6d\x6f\x72\x79\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x79\x20\x4f\x53\x20\x28\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x61\x6d\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x65\x78\x74\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x74\x61\x63\x6b\x61\x6c\x6c\x6f\x63\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x73\x63\x68\x65\x64\x75\x6c\x65\x72\x20\x73\x74\x61\x63\x6b\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6c\x6f\x63\x6b\x69\x6e\x67\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x6c\x65\x76\x65\x6c\x73\x20\x6f\x66\x20\x73\x79\x6d\x62\x6f\x6c\x69\x63\x20\x6c\x69\x6e\x6b\x73\x74\x72\x65\x61\x70\x20\x69\x6e\x73\x65\x72\x74\x20\x66\x69\x6e\x64\x73\x20\x61\x20\x62\x72\x6f\x6b\x65\x6e\x20\x74\x72\x65\x61\x70\x74\x72\x65\x61\x70\x20\x6e\x6f\x64\x65\x20\x77\x69\x74\x68\x20\x6e\x69\x6c\x20\x73\x70\x61\x6e\x4b\x65\x79\x20\x66\x6f\x75\x6e\x64\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x75\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x6c\x65\x20\x74\x79\x70\x65\x33\x35\x35\x32\x37\x31\x33\x36\x37\x38\x38\x30\x30\x35\x30\x30\x39\x32\x39\x33\x35\x35\x36\x32\x31\x33\x33\x37\x38\x39\x30\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x41\x6c\x6c\x6f\x63\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x4d\x53\x70\x61\x6e\x20\x6e\x6f\x74\x20\x66\x72\x65\x65\x4d\x53\x70\x61\x6e\x5f\x45\x6e\x73\x75\x72\x65\x53\x77\x65\x70\x74\x3a\x20\x6d\x20\x69\x73\x20\x6e\x6f\x74\x20\x6c\x6f\x63\x6b\x65\x64\x4f\x74\x68\x65\x72\x5f\x44\x65\x66\x61\x75\x6c\x74\x5f\x49\x67\x6e\x6f\x72\x61\x62\x6c\x65\x5f\x43\x6f\x64\x65\x5f\x50\x6f\x69\x6e\x74\x53\x49\x47\x55\x52\x47\x3a\x20\x75\x72\x67\x65\x6e\x74\x20\x63\x6f\x6e\x64\x69\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x73\x6f\x63\x6b\x65\x74\x66\x6f\x72\x45\x61\x63\x68\x50\x3a\x20\x73\x63\x68\x65\x64\x2e\x73\x61\x66\x65\x50\x6f\x69\x6e\x74\x57\x61\x69\x74\x20\x21\x3d\x20\x30\x68\x65\x61\x70\x42\x69\x74\x73\x46\x6f\x72\x53\x70\x61\x6e\x3a\x20\x62\x61\x73\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x3a\x20\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4d\x65\x74\x68\x6f\x64\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x70\x61\x73\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x67\x20\x69\x73\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x62\x75\x74\x20\x70\x20\x69\x73\x20\x6e\x6f\x74\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x72\x65\x74\x75\x72\x6e\x20\x70\x63\x20\x66\x6f\x72\x20\x73\x63\x68\x65\x64\x75\x6c\x65\x3a\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x20\x77\x69\x74\x68\x20\x6c\x6f\x63\x61\x6c\x20\x77\x6f\x72\x6b\x73\x70\x61\x6e\x20\x61\x6e\x64\x20\x74\x72\x65\x61\x70\x20\x73\x69\x7a\x65\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x6d\x61\x74\x63\x68\x3f\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x73\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x73\x70\x6c\x69\x63\x65\x31\x37\x37\x36\x33\x35\x36\x38\x33\x39\x34\x30\x30\x32\x35\x30\x34\x36\x34\x36\x37\x37\x38\x31\x30\x36\x36\x38\x39\x34\x35\x33\x31\x32\x35\x38\x38\x38\x31\x37\x38\x34\x31\x39\x37\x30\x30\x31\x32\x35\x32\x33\x32\x33\x33\x38\x39\x30\x35\x33\x33\x34\x34\x37\x32\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x66\x72\x65\x65\x66\x69\x6e\x64\x66\x75\x6e\x63\x3a\x20\x62\x61\x64\x20\x66\x69\x6e\x64\x66\x75\x6e\x63\x74\x61\x62\x20\x65\x6e\x74\x72\x79\x20\x69\x64\x78\x66\x69\x6e\x64\x72\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x6e\x65\x74\x70\x6f\x6c\x6c\x20\x77\x69\x74\x68\x20\x73\x70\x69\x6e\x6e\x69\x6e\x67\x67\x72\x65\x79\x6f\x62\x6a\x65\x63\x74\x3a\x20\x6f\x62\x6a\x20\x6e\x6f\x74\x20\x70\x6f\x69\x6e\x74\x65\x72\x2d\x61\x6c\x69\x67\x6e\x65\x64\x6d\x69\x73\x72\x6f\x75\x6e\x64\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x69\x6e\x20\x6d\x61\x6c\x6c\x6f\x63\x69\x6e\x69\x74\x6e\x65\x74\x77\x6f\x72\x6b\x20\x64\x72\x6f\x70\x70\x65\x64\x20\x63\x6f\x6e\x6e\x65\x63\x74\x69\x6f\x6e\x20\x6f\x6e\x20\x72\x65\x73\x65\x74\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x61\x6c\x69\x67\x6e\x20\x69\x73\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x70\x69\x64\x6c\x65\x70\x75\x74\x3a\x20\x50\x20\x68\x61\x73\x20\x6e\x6f\x6e\x2d\x65\x6d\x70\x74\x79\x20\x72\x75\x6e\x20\x71\x75\x65\x75\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x6c\x6f\x73\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x20\x77\x2f\x6f\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x64\x69\x64\x20\x6e\x6f\x74\x20\x75\x6e\x77\x69\x6e\x64\x20\x63\x6f\x6d\x70\x6c\x65\x74\x65\x6c\x79\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x69\x73\x20\x6e\x6f\x74\x20\x63\x6f\x6e\x6e\x65\x63\x74\x65\x64\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x34\x34\x34\x30\x38\x39\x32\x30\x39\x38\x35\x30\x30\x36\x32\x36\x31\x36\x31\x36\x39\x34\x35\x32\x36\x36\x37\x32\x33\x36\x33\x32\x38\x31\x32\x35\x47\x6f\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x73\x74\x6f\x72\x65\x64\x20\x69\x6e\x74\x6f\x20\x6e\x6f\x6e\x2d\x47\x6f\x20\x6d\x65\x6d\x6f\x72\x79\x4d\x53\x74\x61\x74\x73\x20\x76\x73\x20\x4d\x65\x6d\x53\x74\x61\x74\x73\x54\x79\x70\x65\x20\x73\x69\x7a\x65\x20\x6d\x69\x73\x6d\x61\x74\x63\x68\x61\x63\x63\x65\x73\x73\x69\x6e\x67\x20\x61\x20\x63\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x6b\x65\x79\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f\x66\x20\x6b\x65\x79\x20\x61\x6c\x69\x67\x6e\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x53\x70\x61\x6e\x73\x20\x64\x75\x72\x69\x6e\x67\x20\x73\x65\x63\x6f\x6e\x64\x20\x6d\x61\x72\x6b\x72\x6f\x6f\x74\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x49\x73\x56\x61\x72\x69\x61\x64\x69\x63\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x4e\x75\x6d\x46\x69\x65\x6c\x64\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x66\x75\x6e\x63\x4c\x61\x79\x6f\x75\x74\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x66\x75\x6e\x63\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x61\x64\x20\x6e\x6f\x74\x69\x66\x79\x4c\x69\x73\x74\x20\x73\x69\x7a\x65\x20\x2d\x20\x73\x79\x6e\x63\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x49\x6e\x73\x65\x72\x74\x42\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x63\x2d\x65\x6e\x63\x6f\x64\x65\x64\x20\x74\x61\x62\x6c\x65\x20\x66\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x63\x61\x6c\x6c\x20\x63\x61\x6c\x6c\x65\x64\x20\x6f\x6e\x20\x6d\x2d\x3e\x67\x30\x20\x73\x74\x61\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x77\x61\x69\x74\x6c\x69\x6e\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x6e\x62\x6c\x6f\x63\x6b\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x77\x72\x6f\x6e\x67\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x69\x6e\x20\x6e\x65\x77\x73\x74\x61\x63\x6b\x73\x69\x67\x6e\x61\x6c\x20\x61\x72\x72\x69\x76\x65\x64\x20\x64\x75\x72\x69\x6e\x67\x20\x63\x67\x6f\x20\x65\x78\x65\x63\x75\x74\x69\x6f\x6e\x0a\x73\x79\x6e\x74\x61\x78\x20\x65\x72\x72\x6f\x72\x20\x73\x63\x61\x6e\x6e\x69\x6e\x67\x20\x63\x6f\x6d\x70\x6c\x65\x78\x20\x6e\x75\x6d\x62\x65\x72\x75\x6e\x63\x61\x63\x68\x69\x6e\x67\x20\x73\x70\x61\x6e\x20\x62\x75\x74\x20\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x3d\x3d\x20\x30\x29\x20\x69\x73\x20\x73\x6d\x61\x6c\x6c\x65\x72\x20\x74\x68\x61\x6e\x20\x6d\x69\x6e\x69\x6d\x75\x6d\x20\x70\x61\x67\x65\x20\x73\x69\x7a\x65\x20\x28\x32\x32\x32\x30\x34\x34\x36\x30\x34\x39\x32\x35\x30\x33\x31\x33\x30\x38\x30\x38\x34\x37\x32\x36\x33\x33\x33\x36\x31\x38\x31\x36\x34\x30\x36\x32\x35\x5f\x63\x67\x6f\x5f\x6e\x6f\x74\x69\x66\x79\x5f\x72\x75\x6e\x74\x69\x6d\x65\x5f\x69\x6e\x69\x74\x5f\x64\x6f\x6e\x65\x20\x6d\x69\x73\x73\x69\x6e\x67\x61\x6c\x6c\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x73\x20\x61\x72\x65\x20\x61\x73\x6c\x65\x65\x70\x20\x2d\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x21\x63\x61\x6e\x6e\x6f\x74\x20\x65\x78\x65\x63\x20\x61\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x20\x64\x69\x72\x65\x63\x74\x6c\x79\x6f\x70\x65\x72\x61\x74\x69\x6f\x6e\x20\x6e\x6f\x74\x20\x70\x6f\x73\x73\x69\x62\x6c\x65\x20\x64\x75\x65\x20\x74\x6f\x20\x52\x46\x2d\x6b\x69\x6c\x6c\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x62\x79\x74\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x72\x75\x6e\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x42\x69\x74\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x61\x72\x69\x74\x68\x6d\x65\x74\x69\x63\x20\x54\x79\x70\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x20\x63\x6f\x6e\x66\x6c\x69\x63\x74\x3a\x20\x6d\x61\x70\x28\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x73\x69\x7a\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x65\x74\x70\x72\x6f\x66\x69\x6c\x65\x62\x75\x63\x6b\x65\x74\x3a\x20\x70\x72\x6f\x66\x69\x6c\x65\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x73\x65\x74\x73\x74\x61\x72\x74\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x20\x6d\x70\x2d\x3e\x6e\x65\x78\x74\x70\x76\x61\x6c\x75\x65\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x20\x66\x6f\x72\x20\x64\x65\x66\x69\x6e\x65\x64\x20\x64\x61\x74\x61\x20\x74\x79\x70\x65\x31\x31\x31\x30\x32\x32\x33\x30\x32\x34\x36\x32\x35\x31\x35\x36\x35\x34\x30\x34\x32\x33\x36\x33\x31\x36\x36\x38\x30\x39\x30\x38\x32\x30\x33\x31\x32\x35\x35\x35\x35\x31\x31\x31\x35\x31\x32\x33\x31\x32\x35\x37\x38\x32\x37\x30\x32\x31\x31\x38\x31\x35\x38\x33\x34\x30\x34\x35\x34\x31\x30\x31\x35\x36\x32\x35\x61\x72\x67\x20\x73\x69\x7a\x65\x20\x74\x6f\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x63\x61\x6c\x6c\x20\x6d\x6f\x72\x65\x20\x74\x68\x61\x6e\x20\x31\x47\x42\x63\x61\x6e\x20\x6e\x6f\x74\x20\x61\x63\x63\x65\x73\x73\x20\x61\x20\x6e\x65\x65\x64\x65\x64\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x79\x63\x6f\x6e\x63\x75\x72\x72\x65\x6e\x74\x20\x6d\x61\x70\x20\x69\x74\x65\x72\x61\x74\x69\x6f\x6e\x20\x61\x6e\x64\x20\x6d\x61\x70\x20\x77\x72\x69\x74\x65\x67\x63\x42\x67\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x3a\x20\x62\x6c\x61\x63\x6b\x65\x6e\x69\x6e\x67\x20\x6e\x6f\x74\x20\x65\x6e\x61\x62\x6c\x65\x64\x6d\x61\x6b\x65\x63\x68\x61\x6e\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x63\x68\x61\x6e\x6e\x65\x6c\x20\x65\x6c\x65\x6d\x65\x6e\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x72\x65\x61\x64\x20\x6f\x6e\x20\x66\x72\x65\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x20\x68\x65\x61\x64\x65\x72\x3a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x73\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x73\x65\x6c\x65\x63\x74\x64\x6f\x6e\x65\x32\x37\x37\x35\x35\x35\x37\x35\x36\x31\x35\x36\x32\x38\x39\x31\x33\x35\x31\x30\x35\x39\x30\x37\x39\x31\x37\x30\x32\x32\x37\x30\x35\x30\x37\x38\x31\x32\x35\x4d\x53\x70\x61\x6e\x5f\x53\x77\x65\x65\x70\x3a\x20\x62\x61\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x20\x61\x66\x74\x65\x72\x20\x73\x77\x65\x65\x70\x6d\x69\x73\x72\x6f\x75\x6e\x64\x65\x64\x20\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x69\x6e\x20\x4d\x48\x65\x61\x70\x5f\x53\x79\x73\x41\x6c\x6c\x6f\x63\x72\x65\x63\x65\x69\x76\x65\x64\x20\x6f\x6e\x20\x74\x68\x72\x65\x61\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x20\x73\x69\x67\x6e\x61\x6c\x20\x73\x74\x61\x63\x6b\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x4e\x61\x6d\x65\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x66\x72\x65\x65\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x66\x61\x69\x6c\x65\x64\x20\x67\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x20\x77\x69\x74\x68\x20\x74\x79\x70\x65\x20\x73\x70\x61\x6e\x20\x61\x6e\x64\x20\x74\x72\x65\x61\x70\x20\x6e\x6f\x64\x65\x20\x6e\x70\x61\x67\x65\x73\x20\x64\x6f\x20\x6e\x6f\x74\x20\x6d\x61\x74\x63\x68\x73\x74\x61\x63\x6b\x20\x67\x72\x6f\x77\x74\x68\x20\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x77\x65\x64\x20\x69\x6e\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x69\x73\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x63\x6f\x6e\x6e\x65\x63\x74\x65\x64\x31\x33\x38\x37\x37\x37\x38\x37\x38\x30\x37\x38\x31\x34\x34\x35\x36\x37\x35\x35\x32\x39\x35\x33\x39\x35\x38\x35\x31\x31\x33\x35\x32\x35\x33\x39\x30\x36\x32\x35\x36\x39\x33\x38\x38\x39\x33\x39\x30\x33\x39\x30\x37\x32\x32\x38\x33\x37\x37\x36\x34\x37\x36\x39\x37\x39\x32\x35\x35\x36\x37\x36\x32\x36\x39\x35\x33\x31\x32\x35\x61\x64\x64\x72\x65\x73\x73\x20\x66\x61\x6d\x69\x6c\x79\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x62\x79\x20\x70\x72\x6f\x74\x6f\x63\x6f\x6c\x62\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x50\x72\x65\x57\x72\x69\x74\x65\x3a\x20\x75\x6e\x61\x6c\x69\x67\x6e\x65\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x63\x61\x6e\x6e\x6f\x74\x20\x66\x72\x65\x65\x20\x77\x6f\x72\x6b\x62\x75\x66\x73\x20\x77\x68\x65\x6e\x20\x77\x6f\x72\x6b\x2e\x66\x75\x6c\x6c\x20\x21\x3d\x20\x30\x64\x65\x66\x65\x72\x70\x72\x6f\x63\x3a\x20\x64\x2e\x70\x61\x6e\x69\x63\x20\x21\x3d\x20\x6e\x69\x6c\x20\x61\x66\x74\x65\x72\x20\x6e\x65\x77\x64\x65\x66\x65\x72\x72\x65\x63\x65\x69\x76\x65\x64\x20\x62\x75\x74\x20\x68\x61\x6e\x64\x6c\x65\x72\x20\x6e\x6f\x74\x20\x6f\x6e\x20\x73\x69\x67\x6e\x61\x6c\x20\x73\x74\x61\x63\x6b\x72\x65\x66\x69\x6c\x6c\x20\x6f\x66\x20\x73\x70\x61\x6e\x20\x77\x69\x74\x68\x20\x66\x72\x65\x65\x20\x73\x70\x61\x63\x65\x20\x72\x65\x6d\x61\x69\x6e\x69\x6e\x67\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x65\x74\x42\x79\x74\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x62\x79\x74\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x73\x65\x74\x52\x75\x6e\x65\x73\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x72\x75\x6e\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x49\x6e\x64\x65\x78\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x72\x73\x74\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6f\x75\x74\x20\x6f\x66\x20\x6d\x65\x6d\x6f\x72\x79\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x20\x76\x61\x6c\x75\x65\x20\x73\x69\x7a\x65\x20\x6e\x6f\x74\x20\x61\x20\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x6f\x66\x20\x76\x61\x6c\x75\x65\x20\x61\x6c\x69\x67\x6e\x33\x34\x36\x39\x34\x34\x36\x39\x35\x31\x39\x35\x33\x36\x31\x34\x31\x38\x38\x38\x32\x33\x38\x34\x38\x39\x36\x32\x37\x38\x33\x38\x31\x33\x34\x37\x36\x35\x36\x32\x35\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x70\x61\x6e\x20\x73\x74\x61\x74\x65\x4d\x48\x65\x61\x70\x5f\x46\x72\x65\x65\x53\x70\x61\x6e\x4c\x6f\x63\x6b\x65\x64\x20\x2d\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x73\x74\x61\x63\x6b\x20\x66\x72\x65\x65\x63\x61\x6e\x27\x74\x20\x63\x61\x6c\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x6e\x20\x61\x20\x6e\x6f\x6e\x2d\x70\x6f\x69\x6e\x74\x65\x72\x20\x56\x61\x6c\x75\x65\x67\x63\x53\x77\x65\x65\x70\x20\x62\x65\x69\x6e\x67\x20\x64\x6f\x6e\x65\x20\x62\x75\x74\x20\x70\x68\x61\x73\x65\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x43\x6f\x66\x66\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x73\x65\x63\x6f\x6e\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x72\x75\x6e\x74\x69\x6d\x65\x2e\x6d\x61\x6b\x65\x6d\x61\x70\x3a\x20\x75\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x6d\x61\x70\x20\x6b\x65\x79\x20\x74\x79\x70\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x72\x65\x61\x64\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x42\x69\x74\x73\x42\x75\x6c\x6b\x42\x61\x72\x72\x69\x65\x72\x20\x77\x69\x74\x68\x6f\x75\x74\x20\x74\x79\x70\x65\x73\x65\x74\x43\x68\x65\x63\x6b\x6d\x61\x72\x6b\x65\x64\x20\x61\x6e\x64\x20\x69\x73\x43\x68\x65\x63\x6b\x6d\x61\x72\x6b\x65\x64\x20\x64\x69\x73\x61\x67\x72\x65\x65\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x20\x28\x73\x74\x6f\x70\x77\x61\x69\x74\x20\x21\x3d\x20\x30\x29\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x41\x70\x70\x65\x6e\x64\x49\x6e\x74\x2f\x46\x6f\x72\x6d\x61\x74\x49\x6e\x74\x20\x62\x61\x73\x65\x31\x37\x33\x34\x37\x32\x33\x34\x37\x35\x39\x37\x36\x38\x30\x37\x30\x39\x34\x34\x31\x31\x39\x32\x34\x34\x38\x31\x33\x39\x31\x39\x30\x36\x37\x33\x38\x32\x38\x31\x32\x35\x38\x36\x37\x33\x36\x31\x37\x33\x37\x39\x38\x38\x34\x30\x33\x35\x34\x37\x32\x30\x35\x39\x36\x32\x32\x34\x30\x36\x39\x35\x39\x35\x33\x33\x36\x39\x31\x34\x30\x36\x32\x35\x61\x63\x71\x75\x69\x72\x65\x53\x75\x64\x6f\x67\x3a\x20\x66\x6f\x75\x6e\x64\x20\x73\x2e\x65\x6c\x65\x6d\x20\x21\x3d\x20\x6e\x69\x6c\x20\x69\x6e\x20\x63\x61\x63\x68\x65\x70\x65\x72\x73\x69\x73\x74\x65\x6e\x74\x61\x6c\x6c\x6f\x63\x3a\x20\x61\x6c\x69\x67\x6e\x20\x69\x73\x20\x6e\x6f\x74\x20\x61\x20\x70\x6f\x77\x65\x72\x20\x6f\x66\x20\x32\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x62\x6c\x6f\x63\x6b\x65\x64\x20\x77\x72\x69\x74\x65\x20\x6f\x6e\x20\x63\x6c\x6f\x73\x69\x6e\x67\x20\x70\x6f\x6c\x6c\x64\x65\x73\x63\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x47\x43\x50\x72\x6f\x67\x3a\x20\x74\x6f\x74\x61\x6c\x20\x62\x69\x74\x73\x73\x79\x6e\x63\x2f\x61\x74\x6f\x6d\x69\x63\x3a\x20\x73\x74\x6f\x72\x65\x20\x6f\x66\x20\x6e\x69\x6c\x20\x76\x61\x6c\x75\x65\x20\x69\x6e\x74\x6f\x20\x56\x61\x6c\x75\x65\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x69\x67\x6e\x61\x6c\x20\x64\x75\x72\x69\x6e\x67\x20\x72\x75\x6e\x74\x69\x6d\x65\x20\x65\x78\x65\x63\x75\x74\x69\x6f\x6e\x67\x63\x42\x67\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x67\x63\x4d\x61\x72\x6b\x57\x6f\x72\x6b\x65\x72\x4d\x6f\x64\x65\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x62\x65\x66\x6f\x72\x65\x20\x67\x6f\x65\x78\x69\x74\x50\x43\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x61\x74\x69\x6f\x6e\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x47\x43\x50\x72\x6f\x67\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x62\x69\x74\x20\x63\x6f\x75\x6e\x74\x69\x6e\x74\x65\x72\x72\x75\x70\x74\x65\x64\x20\x73\x79\x73\x74\x65\x6d\x20\x63\x61\x6c\x6c\x20\x73\x68\x6f\x75\x6c\x64\x20\x62\x65\x20\x72\x65\x73\x74\x61\x72\x74\x65\x64\x6d\x75\x6c\x74\x69\x70\x6c\x65\x20\x52\x65\x61\x64\x20\x63\x61\x6c\x6c\x73\x20\x72\x65\x74\x75\x72\x6e\x20\x6e\x6f\x20\x64\x61\x74\x61\x20\x6f\x72\x20\x65\x72\x72\x6f\x72\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x46\x69\x65\x6c\x64\x42\x79\x4e\x61\x6d\x65\x46\x75\x6e\x63\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x73\x74\x72\x75\x63\x74\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x49\x6d\x70\x6c\x65\x6d\x65\x6e\x74\x73\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x6e\x61\x6c\x69\x7a\x65\x72\x20\x61\x6c\x72\x65\x61\x64\x79\x20\x73\x65\x74\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x66\x69\x72\x73\x74\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x20\x69\x73\x20\x6e\x69\x6c\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x20\x62\x61\x64\x20\x6f\x6c\x64\x76\x61\x6c\x20\x67\x70\x3d\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x72\x65\x6c\x65\x61\x73\x65\x53\x75\x64\x6f\x67\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x6e\x69\x6c\x20\x67\x70\x2e\x70\x61\x72\x61\x6d\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x64\x75\x72\x69\x6e\x67\x20\x62\x6f\x6f\x74\x73\x74\x72\x61\x70\x20\x75\x73\x69\x6e\x67\x20\x76\x61\x6c\x75\x65\x20\x6f\x62\x74\x61\x69\x6e\x65\x64\x20\x75\x73\x69\x6e\x67\x20\x75\x6e\x65\x78\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x65\x6c\x64\x67\x63\x6d\x61\x72\x6b\x6e\x65\x77\x6f\x62\x6a\x65\x63\x74\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x68\x69\x6c\x65\x20\x64\x6f\x69\x6e\x67\x20\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x66\x75\x6e\x63\x4c\x61\x79\x6f\x75\x74\x20\x77\x69\x74\x68\x20\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x72\x65\x63\x65\x69\x76\x65\x72\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6c\x66\x73\x74\x61\x63\x6b\x2e\x70\x75\x73\x68\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x70\x61\x63\x6b\x69\x6e\x67\x3a\x20\x6e\x6f\x64\x65\x3d\x73\x79\x73\x74\x65\x6d\x73\x74\x61\x63\x6b\x20\x63\x61\x6c\x6c\x65\x64\x20\x66\x72\x6f\x6d\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x6e\x64\x20\x61\x66\x74\x65\x72\x20\x74\x72\x61\x6e\x73\x70\x6f\x72\x74\x20\x65\x6e\x64\x70\x6f\x69\x6e\x74\x20\x73\x68\x75\x74\x64\x6f\x77\x6e\x65\x78\x69\x74\x73\x79\x73\x63\x61\x6c\x6c\x3a\x20\x73\x79\x73\x63\x61\x6c\x6c\x20\x66\x72\x61\x6d\x65\x20\x69\x73\x20\x6e\x6f\x20\x6c\x6f\x6e\x67\x65\x72\x20\x76\x61\x6c\x69\x64\x68\x65\x61\x70\x42\x69\x74\x73\x53\x65\x74\x54\x79\x70\x65\x3a\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x70\x6f\x69\x6e\x74\x65\x72\x20\x74\x79\x70\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x65\x74\x68\x6f\x64\x20\x69\x6e\x64\x65\x78\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x41\x73\x73\x69\x67\x6e\x61\x62\x6c\x65\x54\x6f\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x4d\x53\x70\x61\x6e\x4c\x69\x73\x74\x5f\x52\x65\x6d\x6f\x76\x65\x20\x73\x70\x61\x6e\x2e\x6e\x70\x61\x67\x65\x73\x3d\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x61\x66\x74\x65\x72\x20\x74\x79\x70\x65\x20\x6e\x61\x6d\x65\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x69\x6c\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x43\x6f\x6e\x76\x65\x72\x74\x69\x62\x6c\x65\x54\x6f\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x66\x61\x69\x6c\x65\x64\x20\x74\x6f\x20\x63\x72\x65\x61\x74\x65\x20\x6e\x65\x77\x20\x4f\x53\x20\x74\x68\x72\x65\x61\x64\x20\x28\x68\x61\x76\x65\x20\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6e\x61\x6d\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x70\x61\x6e\x69\x63\x20\x62\x65\x66\x6f\x72\x65\x20\x6d\x61\x6c\x6c\x6f\x63\x20\x68\x65\x61\x70\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x65\x78\x74\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x74\x79\x70\x65\x20\x6f\x66\x66\x73\x65\x74\x20\x62\x61\x73\x65\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x73\x74\x6f\x70\x54\x68\x65\x57\x6f\x72\x6c\x64\x3a\x20\x6e\x6f\x74\x20\x73\x74\x6f\x70\x70\x65\x64\x20\x28\x73\x74\x61\x74\x75\x73\x20\x21\x3d\x20\x5f\x50\x67\x63\x73\x74\x6f\x70\x29\x50\x20\x68\x61\x73\x20\x63\x61\x63\x68\x65\x64\x20\x47\x43\x20\x77\x6f\x72\x6b\x20\x61\x74\x20\x65\x6e\x64\x20\x6f\x66\x20\x6d\x61\x72\x6b\x20\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x61\x74\x74\x65\x6d\x70\x74\x69\x6e\x67\x20\x74\x6f\x20\x6c\x69\x6e\x6b\x20\x69\x6e\x20\x74\x6f\x6f\x20\x6d\x61\x6e\x79\x20\x73\x68\x61\x72\x65\x64\x20\x6c\x69\x62\x72\x61\x72\x69\x65\x73\x50\x20\x68\x61\x73\x20\x75\x6e\x66\x6c\x75\x73\x68\x65\x64\x20\x73\x74\x61\x74\x73\x20\x61\x74\x20\x65\x6e\x64\x20\x6f\x66\x20\x6d\x61\x72\x6b\x20\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x6d\x61\x70\x20\x70\x61\x67\x65\x73\x20\x69\x6e\x20\x61\x72\x65\x6e\x61\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6c\x6c\x65\x67\x61\x6c\x20\x41\x70\x70\x65\x6e\x64\x46\x6c\x6f\x61\x74\x2f\x46\x6f\x72\x6d\x61\x74\x46\x6c\x6f\x61\x74\x20\x62\x69\x74\x53\x69\x7a\x65\x63\x61\x73\x67\x73\x74\x61\x74\x75\x73\x3a\x20\x77\x61\x69\x74\x69\x6e\x67\x20\x66\x6f\x72\x20\x47\x77\x61\x69\x74\x69\x6e\x67\x20\x62\x75\x74\x20\x69\x73\x20\x47\x72\x75\x6e\x6e\x61\x62\x6c\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x6d\x65\x6d\x6f\x72\x79\x20\x61\x64\x64\x72\x65\x73\x73\x20\x6f\x72\x20\x6e\x69\x6c\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x69\x6e\x76\x61\x6c\x69\x64\x20\x6f\x72\x20\x69\x6e\x63\x6f\x6d\x70\x6c\x65\x74\x65\x20\x6d\x75\x6c\x74\x69\x62\x79\x74\x65\x20\x6f\x72\x20\x77\x69\x64\x65\x20\x63\x68\x61\x72\x61\x63\x74\x65\x72\x70\x61\x6e\x69\x63\x77\x72\x61\x70\x3a\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x61\x66\x74\x65\x72\x20\x70\x61\x63\x6b\x61\x67\x65\x20\x6e\x61\x6d\x65\x3a\x20\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x6c\x69\x63\x65\x20\x6f\x66\x20\x75\x6e\x61\x64\x64\x72\x65\x73\x73\x61\x62\x6c\x65\x20\x61\x72\x72\x61\x79\x73\x2e\x61\x6c\x6c\x6f\x63\x43\x6f\x75\x6e\x74\x20\x21\x3d\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x20\x26\x26\x20\x66\x72\x65\x65\x49\x6e\x64\x65\x78\x20\x3d\x3d\x20\x73\x2e\x6e\x65\x6c\x65\x6d\x73\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x2c\x20\x72\x65\x73\x74\x20\x21\x3d\x20\x30\x20\x62\x75\x74\x20\x6e\x65\x65\x64\x65\x64\x20\x3e\x20\x30\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x6e\x75\x6d\x20\x3e\x20\x64\x65\x6e\x3c\x3c\x73\x68\x69\x66\x74\x20\x69\x6e\x20\x61\x64\x6a\x75\x73\x74\x4c\x61\x73\x74\x44\x69\x67\x69\x74\x46\x69\x78\x65\x64\x77\x72\x69\x74\x65\x62\x61\x72\x72\x69\x65\x72\x70\x74\x72\x5f\x70\x72\x65\x77\x72\x69\x74\x65\x31\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6d\x70\x2e\x70\x20\x3d\x3d\x20\x6e\x69\x6c\x61\x74\x74\x65\x6d\x70\x74\x20\x74\x6f\x20\x65\x78\x65\x63\x75\x74\x65\x20\x73\x79\x73\x74\x65\x6d\x20\x73\x74\x61\x63\x6b\x20\x63\x6f\x64\x65\x20\x6f\x6e\x20\x75\x73\x65\x72\x20\x73\x74\x61\x63\x6b\x6d\x61\x6c\x6c\x6f\x63\x67\x63\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x67\x63\x70\x68\x61\x73\x65\x20\x3d\x3d\x20\x5f\x47\x43\x6d\x61\x72\x6b\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x72\x65\x63\x75\x72\x73\x69\x76\x65\x20\x63\x61\x6c\x6c\x20\x64\x75\x72\x69\x6e\x67\x20\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x61\x74\x69\x6f\x6e\x20\x2d\x20\x6c\x69\x6e\x6b\x65\x72\x20\x73\x6b\x65\x77\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x73\x65\x72\x76\x65\x20\x61\x72\x65\x6e\x61\x20\x76\x69\x72\x74\x75\x61\x6c\x20\x61\x64\x64\x72\x65\x73\x73\x20\x73\x70\x61\x63\x65\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x3a\x20\x67\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x20\x73\x63\x61\x6e\x20\x73\x74\x61\x74\x65\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x73\x79\x6d\x62\x6f\x6c\x20\x74\x61\x62\x6c\x65\x20\x6e\x6f\x74\x20\x73\x6f\x72\x74\x65\x64\x20\x62\x79\x20\x70\x72\x6f\x67\x72\x61\x6d\x20\x63\x6f\x75\x6e\x74\x65\x72\x3a\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6e\x6f\x74\x20\x69\x6e\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x6c\x6f\x63\x6b\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x75\x73\x65\x20\x6f\x66\x20\x46\x69\x78\x41\x6c\x6c\x6f\x63\x5f\x41\x6c\x6c\x6f\x63\x20\x62\x65\x66\x6f\x72\x65\x20\x46\x69\x78\x41\x6c\x6c\x6f\x63\x5f\x49\x6e\x69\x74\x0a\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x53\x6c\x69\x63\x65\x3a\x20\x73\x74\x72\x69\x6e\x67\x20\x73\x6c\x69\x63\x65\x20\x69\x6e\x64\x65\x78\x20\x6f\x75\x74\x20\x6f\x66\x20\x62\x6f\x75\x6e\x64\x73\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x6e\x6f\x6e\x2d\x69\x6e\x74\x65\x72\x66\x61\x63\x65\x20\x74\x79\x70\x65\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x54\x79\x70\x65\x2e\x49\x6d\x70\x6c\x65\x6d\x65\x6e\x74\x73\x09\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x72\x75\x6e\x6e\x69\x6e\x67\x20\x6f\x6e\x20\x6f\x74\x68\x65\x72\x20\x74\x68\x72\x65\x61\x64\x3b\x20\x73\x74\x61\x63\x6b\x20\x75\x6e\x61\x76\x61\x69\x6c\x61\x62\x6c\x65\x0a\x67\x63\x43\x6f\x6e\x74\x72\x6f\x6c\x6c\x65\x72\x53\x74\x61\x74\x65\x2e\x66\x69\x6e\x64\x52\x75\x6e\x6e\x61\x62\x6c\x65\x3a\x20\x62\x6c\x61\x63\x6b\x65\x6e\x69\x6e\x67\x20\x6e\x6f\x74\x20\x65\x6e\x61\x62\x6c\x65\x64\x6e\x6f\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x73\x20\x28\x6d\x61\x69\x6e\x20\x63\x61\x6c\x6c\x65\x64\x20\x72\x75\x6e\x74\x69\x6d\x65\x2e\x47\x6f\x65\x78\x69\x74\x29\x20\x2d\x20\x64\x65\x61\x64\x6c\x6f\x63\x6b\x21\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x20\x64\x6f\x65\x73\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x20\x6d\x6f\x72\x65\x20\x74\x68\x61\x6e\x20\x35\x30\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x63\x61\x73\x66\x72\x6f\x6d\x5f\x47\x73\x63\x61\x6e\x73\x74\x61\x74\x75\x73\x3a\x74\x6f\x70\x20\x67\x70\x2d\x3e\x73\x74\x61\x74\x75\x73\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x20\x73\x63\x61\x6e\x20\x73\x74\x61\x74\x65\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x63\x61\x6c\x6c\x62\x61\x63\x6b\x20\x63\x61\x6e\x6e\x6f\x74\x20\x62\x65\x20\x75\x73\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x6f\x6e\x2d\x7a\x65\x72\x6f\x20\x73\x6b\x69\x70\x6e\x65\x77\x70\x72\x6f\x63\x3a\x20\x66\x75\x6e\x63\x74\x69\x6f\x6e\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x73\x20\x74\x6f\x6f\x20\x6c\x61\x72\x67\x65\x20\x66\x6f\x72\x20\x6e\x65\x77\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x72\x65\x66\x6c\x65\x63\x74\x2e\x46\x75\x6e\x63\x4f\x66\x3a\x20\x6c\x61\x73\x74\x20\x61\x72\x67\x20\x6f\x66\x20\x76\x61\x72\x69\x61\x64\x69\x63\x20\x66\x75\x6e\x63\x20\x6d\x75\x73\x74\x20\x62\x65\x20\x73\x6c\x69\x63\x65\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x69\x6e\x76\x61\x6c\x69\x64\x20\x75\x73\x65\x20\x6f\x66\x20\x6d\x61\x6b\x65\x4d\x65\x74\x68\x6f\x64\x56\x61\x6c\x75\x65\x69\x6e\x20\x67\x63\x4d\x61\x72\x6b\x20\x65\x78\x70\x65\x63\x74\x69\x6e\x67\x20\x74\x6f\x20\x73\x65\x65\x20\x67\x63\x70\x68\x61\x73\x65\x20\x61\x73\x20\x5f\x47\x43\x6d\x61\x72\x6b\x74\x65\x72\x6d\x69\x6e\x61\x74\x69\x6f\x6e\x67\x65\x6e\x74\x72\x61\x63\x65\x62\x61\x63\x6b\x20\x63\x61\x6e\x6e\x6f\x74\x20\x74\x72\x61\x63\x65\x20\x75\x73\x65\x72\x20\x67\x6f\x72\x6f\x75\x74\x69\x6e\x65\x20\x6f\x6e\x20\x69\x74\x73\x20\x6f\x77\x6e\x20\x73\x74\x61\x63\x6b\x6e\x6f\x6e\x2d\x47\x6f\x20\x63\x6f\x64\x65\x20\x73\x65\x74\x20\x75\x70\x20\x73\x69\x67\x6e\x61\x6c\x20\x68\x61\x6e\x64\x6c\x65\x72\x20\x77\x69\x74\x68\x6f\x75\x74\x20\x53\x41\x5f\x4f\x4e\x53\x54\x41\x43\x4b\x20\x66\x6c\x61\x67\x72\x75\x6e\x74\x69\x6d\x65\x3a\x73\x74\x6f\x70\x6c\x6f\x63\x6b\x65\x64\x6d\x3a\x20\x67\x20\x69\x73\x20\x6e\x6f\x74\x20\x47\x72\x75\x6e\x6e\x61\x62\x6c\x65\x20\x6f\x72\x20\x47\x73\x63\x61\x6e\x72\x75\x6e\x6e\x61\x62\x6c\x65\x0a\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x6d\x61\x70\x3a\x20\x74\x6f\x6f\x20\x6d\x75\x63\x68\x20\x6c\x6f\x63\x6b\x65\x64\x20\x6d\x65\x6d\x6f\x72\x79\x20\x28\x63\x68\x65\x63\x6b\x20\x27\x75\x6c\x69\x6d\x69\x74\x20\x2d\x6c\x27\x29\x2e\x0a\x73\x79\x6e\x63\x2f\x61\x74\x6f\x6d\x69\x63\x3a\x20\x73\x74\x6f\x72\x65\x20\x6f\x66\x20\x69\x6e\x63\x6f\x6e\x73\x69\x73\x74\x65\x6e\x74\x6c\x79\x20\x74\x79\x70\x65\x64\x20\x76\x61\x6c\x75\x65\x20\x69\x6e\x74\x6f\x20\x56\x61\x6c\x75\x65\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x6d\x61\x79\x20\x6e\x65\x65\x64\x20\x74\x6f\x20\x69\x6e\x63\x72\x65\x61\x73\x65\x20\x6d\x61\x78\x20\x75\x73\x65\x72\x20\x70\x72\x6f\x63\x65\x73\x73\x65\x73\x20\x28\x75\x6c\x69\x6d\x69\x74\x20\x2d\x75\x29\x72\x65\x66\x6c\x65\x63\x74\x3a\x20\x63\x72\x65\x61\x74\x69\x6e\x67\x20\x61\x20\x6e\x61\x6d\x65\x20\x77\x69\x74\x68\x20\x61\x20\x70\x61\x63\x6b\x61\x67\x65\x20\x70\x61\x74\x68\x20\x69\x73\x20\x6e\x6f\x74\x20\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x66\x6f\x75\x6e\x64\x20\x62\x61\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x69\x6e\x20\x47\x6f\x20\x68\x65\x61\x70\x20\x28\x69\x6e\x63\x6f\x72\x72\x65\x63\x74\x20\x75\x73\x65\x20\x6f\x66\x20\x75\x6e\x73\x61\x66\x65\x20\x6f\x72\x20\x63\x67\x6f\x3f\x29\x72\x75\x6e\x74\x69\x6d\x65\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x6d\x69\x73\x75\x73\x65\x20\x6f\x66\x20\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x2f\x75\x6e\x6c\x6f\x63\x6b\x4f\x53\x54\x68\x72\x65\x61\x64\x72\x75\x6e\x74\x69\x6d\x65\x2e\x53\x65\x74\x46\x69\x6e\x61\x6c\x69\x7a\x65\x72\x3a\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x6e\x6f\x74\x20\x61\x74\x20\x62\x65\x67\x69\x6e\x6e\x69\x6e\x67\x20\x6f\x66\x20\x61\x6c\x6c\x6f\x63\x61\x74\x65\x64\x20\x62\x6c\x6f\x63\x6b\x73\x74\x72\x63\x6f\x6e\x76\x3a\x20\x69\x6e\x74\x65\x72\x6e\x61\x6c\x20\x65\x72\x72\x6f\x72\x3a\x20\x65\x78\x74\x46\x6c\x6f\x61\x74\x2e\x46\x69\x78\x65\x64\x44\x65\x63\x69\x6d\x61\x6c\x20\x63\x61\x6c\x6c\x65\x64\x20\x77\x69\x74\x68\x20\x6e\x20\x3d\x3d\x20\x30\x72\x75\x6e\x74\x69\x6d\x65\x3a\x67\x72\x65\x79\x6f\x62\x6a\x65\x63\x74\x3a\x20\x63\x68\x65\x63\x6b\x6d\x61\x72\x6b\x73\x20\x66\x69\x6e\x64\x73\x20\x75\x6e\x65\x78\x70\x65\x63\x74\x65\x64\x20\x75\x6e\x6d\x61\x72\x6b\x65\x64\x20\x6f\x62\x6a\x65\x63\x74\x20\x6f\x62\x6a\x3d\x72\x65\x66\x6c\x65\x63\x74\x2e\x56\x61\x6c\x75\x65\x2e\x49\x6e\x74\x65\x72\x66\x61\x63\x65\x3a\x20\x63\x61\x6e\x6e\x6f\x74\x20\x72\x65\x74\x75\x72\x6e\x20\x76\x61\x6c\x75\x65\x20\x6f\x62\x74\x61\x69\x6e\x65\x64\x20\x66\x72\x6f\x6d\x20\x75\x6e\x65\x78\x70\x6f\x72\x74\x65\x64\x20\x66\x69\x65\x6c\x64\x20\x6f\x72\x20\x6d\x65\x74\x68\x6f\x64\x30\x30\x30\x31\x30\x32\x30\x33\x30\x34\x30\x35\x30\x36\x30\x37\x30\x38\x30\x39\x31\x30\x31\x31\x31\x32\x31\x33\x31\x34\x31\x35\x31\x36\x31\x37\x31\x38\x31\x39\x32\x30\x32\x31\x32\x32\x32\x33\x32\x34\x32\x35\x32\x36\x32\x37\x32\x38\x32\x39\x33\x30\x33\x31\x33\x32\x33\x33\x33\x34\x33\x35\x33\x36\x33\x37\x33\x38\x33\x39\x34\x30\x34\x31\x34\x32\x34\x33\x34\x34\x34\x35\x34\x36\x34\x37\x34\x38\x34\x39\x35\x30\x35\x31\x35\x32\x35\x33\x35\x34\x35\x35\x35\x36\x35\x37\x35\x38\x35\x39\x36\x30\x36\x31\x36\x32\x36\x33\x36\x34\x36\x35\x36\x36\x36\x37\x36\x38\x36\x39\x37\x30\x37\x31\x37\x32\x37\x33\x37\x34\x37\x35\x37\x36\x37\x37\x37\x38\x37\x39\x38\x30\x38\x31\x38\x32\x38\x33\x38\x34\x38\x35\x38\x36\x38\x37\x38\x38\x38\x39\x39\x30\x39\x31\x39\x32\x39\x33\x39\x34\x39\x35\x39\x36\x39\x37\x39\x38\x39\x39"; // 0x80e3fae
int32_t g21 = 0x746e7572; // 0x80e49e4
int32_t g22 = 0x808d400; // 0x80e7ba8
int32_t g23 = 0; // 0x81454a4
int32_t g24 = 0; // 0x81454a8
int32_t g25 = 0; // 0x81454ac
int32_t g26 = 0; // 0x8149108
int32_t g27 = 0; // 0x814910c
int32_t g28 = 0; // 0x81493a0
struct runtime_mheap * g29 = NULL; // 0x81493a8
int32_t g30 = 0; // 0x81493ac
char g31 = 0; // 0x81576f4
char g32 = 0; // 0x81576f5
bool g33 = false; // of
int32_t runtime_bss = 0;
int32_t runtime_fwdSig[0];
int32_t runtime_g0 = 0;
bool runtime_gcBlackenPromptly = false;
int32_t runtime_gcphase = 0;
int32_t runtime_handlingSig[0];
bool runtime_isarchive = false;
bool runtime_iscgo = false;
bool runtime_islibrary = false;
int32_t runtime_modulesSlice = 0;
bool runtime_signalsOK = false;
struct runtime_sigTabT runtime_sigtable[0];
bool runtime_support_erms = false;
bool runtime_support_sse2 = false;
int32_t runtime_tls_entry_number = -1;
bool runtime_useCheckmark = false;
struct struct_runtime_enabledbool_runtime_pad_3_uint8_runtime_neededbool_runtime_cgobool_runtime_alignmeuint64_ runtime_writeBarrier = {
    .e0 = false,
    .e2 = false,
    .e3 = false,
    .e4 = 0
};
bool g34 = false; // sf
bool g35 = false; // zf

// ------------------------ Functions -------------------------

// Address range: 0x8049370 - 0x804939f
void runtime_internal_sys_Ctz64(void) {
    // 0x8049370
    int32_t v1;
    int32_t v2;
    if (v1 != 0 || v2 == 0) {
        // 0x8049379
        return;
    }
}

// Address range: 0x80493a0 - 0x80493af
void runtime_internal_atomic_Load(int32_t * ptr, int32_t a2) {
    // 0x80493a0
    return;
}

// Address range: 0x80493b0 - 0x80493bf
void runtime_internal_atomic_Loadp(char * ptr, char * a2) {
    // 0x80493b0
    return;
}

// Address range: 0x80493c0 - 0x804941f
void runtime_internal_atomic_Xadd64(int64_t * ptr, int64_t delta, int64_t a3) {
    // 0x80493c0
    runtime_internal_atomic_Cas64();
    // branch -> 0x80493c3
    uint32_t v1;
    while (v1 % 256 == 0) {
        // 0x80493c3
        runtime_internal_atomic_Cas64();
        // continue -> 0x80493c3
    }
}

// Address range: 0x8049420 - 0x804947f
void runtime_internal_atomic_Xchg64(int64_t * ptr, int64_t new, int64_t a3) {
    // 0x8049420
    runtime_internal_atomic_Cas64();
    // branch -> 0x8049423
    uint32_t v1;
    while (v1 % 256 == 0) {
        // 0x8049423
        runtime_internal_atomic_Cas64();
        // continue -> 0x8049423
    }
}

// Address range: 0x8049480 - 0x804949f
void runtime_internal_atomic_Cas(void) {
    // 0x8049480
    int32_t v1;
    int32_t * v2 = (int32_t *)v1; // 0x804948d_0
    int32_t v3;
    if (v3 == *v2) {
        // if_804948d_4_true
        int32_t v4;
        *v2 = v4;
        // branch -> after_if_804948d_4
    }
}

// Address range: 0x80494a0 - 0x80494af
void runtime_internal_atomic_Casuintptr(void) {
    // 0x80494a0
    runtime_internal_atomic_Cas();
}

// Address range: 0x80494b0 - 0x80494bf
void runtime_internal_atomic_Loaduintptr(void) {
    // 0x80494b0
    runtime_internal_atomic_Load(NULL, 0);
}

// Address range: 0x80494d0 - 0x80494df
void runtime_internal_atomic_Storeuintptr(void) {
    // 0x80494d0
    runtime_internal_atomic_Store();
}

// Address range: 0x80494e0 - 0x80494ef
void runtime_internal_atomic_Xadduintptr(void) {
    // 0x80494e0
    runtime_internal_atomic_Xadd();
}

// Address range: 0x80494f0 - 0x80494ff
void runtime_internal_atomic_Loadint64(void) {
    // 0x80494f0
    runtime_internal_atomic_Load64();
}

// Address range: 0x8049500 - 0x804950f
void runtime_internal_atomic_Xaddint64(void) {
    // 0x8049500
    runtime_internal_atomic_Xadd64(NULL, 0, 0);
}

// Address range: 0x8049510 - 0x804953f
void runtime_internal_atomic_Cas64(void) {
    // 0x8049510
    int32_t v1;
    if (v1 != 7) {
        // 0x804951c
        abort();
        // UNREACHABLE
    }
    // 0x8049522
    int32_t v2;
    int32_t v3;
    if (v3 == *(int32_t *)7 & v2 == *(int32_t *)11) {
        // if_8049533_2_true
        int32_t v4;
        *(int32_t *)7 = v4;
        int32_t v5;
        *(int32_t *)11 = v5;
        // branch -> after_if_8049533_2
    }
}

// Address range: 0x8049540 - 0x804955f
void runtime_internal_atomic_Casp1(void) {
    // 0x8049540
    int32_t v1;
    int32_t * v2 = (int32_t *)v1; // 0x804954d_0
    int32_t v3;
    if (v3 == *v2) {
        // if_804954d_4_true
        int32_t v4;
        *v2 = v4;
        // branch -> after_if_804954d_4
    }
}

// Address range: 0x8049560 - 0x804957f
void runtime_internal_atomic_Xadd(void) {
    // 0x8049560
    int32_t v1;
    int32_t * v2 = (int32_t *)v1; // 0x804956b_0
    int32_t v3;
    *v2 = *v2 + v3;
}

// Address range: 0x8049580 - 0x804958f
void runtime_internal_atomic_Xchg(void) {
    // 0x8049580
    int32_t v1;
    int32_t v2;
    *(int32_t *)v1 = v2;
}

// Address range: 0x80495a0 - 0x80495af
void runtime_internal_atomic_StorepNoWB(void) {
    // 0x80495a0
    int32_t v1;
    int32_t v2;
    *(int32_t *)v1 = v2;
}

// Address range: 0x80495b0 - 0x80495bf
void runtime_internal_atomic_Store(void) {
    // 0x80495b0
    int32_t v1;
    int32_t v2;
    *(int32_t *)v1 = v2;
}

// Address range: 0x80495c0 - 0x80495df
void runtime_internal_atomic_Load64(void) {
    // 0x80495c0
    int32_t v1;
    if (v1 != 7) {
        // 0x80495cb
        abort();
        // UNREACHABLE
    }
    char * v2 = (char *)g7; // 0x80495d7_0
    *v2 = (char)(g5 + (int32_t)*v2);
    if (g5 <= 255) {
        // 0x80495db
        unknown_80495a1();
        // branch -> 0x80495de
    }
}

// Address range: 0x80495e0 - 0x804960f
void runtime_internal_atomic_Store64(void) {
    // 0x80495e0
    int32_t v1;
    if (v1 == 7) {
        // 0x80495f1
        return;
    }
    // 0x80495eb
    abort();
    // UNREACHABLE
}

// Address range: 0x8049610 - 0x804961f
void runtime_internal_atomic_Or8(void) {
    // 0x8049610
    int32_t v1;
    char * v2 = (char *)v1;
    uint32_t v3;
    *v2 = (char)(g4 & -256 | v3 % 256 | (int32_t)*v2);
}

// Address range: 0x8049620 - 0x804962c
void runtime_internal_atomic_And8(void) {
    // 0x8049620
    int32_t v1;
    char * v2 = (char *)v1;
    uint32_t v3;
    *v2 = (char)((g4 & -256 | v3 % 256) & (int32_t)*v2);
}

// Address range: 0x804a270 - 0x804a3bf
void runtime_alginit(void) {
    // 0x804a270
    abort();
    // UNREACHABLE
}

// Address range: 0x804a3c0 - 0x804a3ff
void runtime_atomicstorep(char * ptr, char * new) {
    // 0x804a3c0
    runtime_writebarrierptr_prewrite((int32_t *)ptr, (int32_t)new);
    runtime_internal_atomic_StorepNoWB();
}

// Address range: 0x804a400 - 0x804a44f
void runtime_casp(char ** ptr, char * old, char * new, bool a4) {
    // 0x804a400
    runtime_writebarrierptr_prewrite((int32_t *)ptr, (int32_t)new);
    runtime_internal_atomic_Casp1();
}

// Address range: 0x804aa50 - 0x804ab4f
void runtime_cgoIsGoPointer(char * p, bool a2) {
    struct _lsb__rsb__ptr_runtime_moduledata v1; // 0x804aa65
    // 0x804aa50
    int32_t v2;
    struct runtime_moduledata ** v3 = (struct runtime_moduledata **)v2;
    uint32_t v4 = (int32_t)p; // 0x804aa53_0
    if (p == NULL) {
        // 0x804ab32
        return;
    }
    // 0x804aacf
    uint32_t v5; // 0x804aa71_0
    int32_t v6;
    int32_t v7; // 0x804aa8357
    int32_t v8; // 0x804aa87
    int32_t v9; // 0x804aa9563
    int32_t v10; // 0x804aa7962
    uint32_t v11; // 0x804aa89
    if ((char *)g29 <= p) {
        // 0x804aad9
        if (v4 < g30) {
            uint32_t v12 = (v4 - (int32_t)g29) / 0x2000; // 0x804aaf3
            if (v12 >= g27) {
                // 0x804ab3b
                runtime_panicindex();
                return;
            }
            int32_t v13 = *(int32_t *)(g26 + 4 * v12); // 0x804aafa
            if (v13 == 0) {
                // 0x804aa65
                v1 = (struct _lsb__rsb__ptr_runtime_moduledata){
                    .e0 = NULL,
                    .e1 = 0,
                    .e2 = 0
                };
                v1.e0 = v3;
                runtime_activeModules(v1);
                v5 = (int32_t)p;
                v7 = -v6;
                if (v7 < 0 ^ (v6 & v7) < 0) {
                    // 0x804aa87
                    v9 = 0;
                    v10 = (int32_t)v3;
                    // branch -> 0x804aa87
                    while (true) {
                        // 0x804aa87
                        v8 = *(int32_t *)v10;
                        v11 = *(int32_t *)(v8 + 64);
                        if (v11 > v5) {
                            goto lab_0x804aa9c_5;
                        }
                        goto lab_0x804aa9c_6;
                    }
                }
                // 0x804aac6
                return;
            }
            // 0x804ab05
            if (v4 < *(int32_t *)(v13 + 12)) {
                // 0x804aa65
                v1 = (struct _lsb__rsb__ptr_runtime_moduledata){
                    .e0 = NULL,
                    .e1 = 0,
                    .e2 = 0
                };
                v1.e0 = v3;
                runtime_activeModules(v1);
                v5 = (int32_t)p;
                v7 = -v6;
                if (v7 < 0 ^ (v6 & v7) < 0) {
                    // 0x804aa87
                    v9 = 0;
                    v10 = (int32_t)v3;
                    // branch -> 0x804aa87
                    while (true) {
                        // 0x804aa87
                        v8 = *(int32_t *)v10;
                        v11 = *(int32_t *)(v8 + 64);
                        if (v11 > v5) {
                            goto lab_0x804aa9c_5;
                        }
                        goto lab_0x804aa9c_6;
                    }
                }
                // 0x804aac6
                return;
            }
            // 0x804ab10
            if ((char)((int32_t)*(char *)(v13 + 60) - 1) <= 1) {
                // 0x804ab1e
                if (v4 < *(int32_t *)(v13 + 80)) {
                    // 0x804ab29
                    return;
                }
            }
            // 0x804aa65
            v1 = (struct _lsb__rsb__ptr_runtime_moduledata){
                .e0 = NULL,
                .e1 = 0,
                .e2 = 0
            };
            v1.e0 = v3;
            runtime_activeModules(v1);
            v5 = (int32_t)p;
            v7 = -v6;
            if (v7 < 0 ^ (v6 & v7) < 0) {
                // 0x804aa87
                v9 = 0;
                v10 = (int32_t)v3;
                // branch -> 0x804aa87
                while (true) {
                    // 0x804aa87
                    v8 = *(int32_t *)v10;
                    v11 = *(int32_t *)(v8 + 64);
                    if (v11 > v5) {
                      lab_0x804aa9c_5:;
                        // 0x804aa9c
                        // branch -> 0x804aaa2
                    } else {
                      lab_0x804aa9c_6:
                        // 0x804aa9c
                        if (((int32_t)(v5 < *(int32_t *)(v8 + 68)) || v11 & -256) != 0) {
                            // 0x804aab5
                            return;
                        }
                    }
                    uint32_t v14 = *(int32_t *)(v8 + 76); // 0x804aaa5
                    if (*(int32_t *)(v8 + 72) > v5) {
                        // 0x804aab1
                        // branch -> 0x804aa79
                    } else {
                        // 0x804aab1
                        if (v5 < v14) {
                            // 0x804aab5
                            return;
                        }
                    }
                    int32_t v15 = v9 + 1; // 0x804aa7c
                    int32_t v16 = v15 - v6; // 0x804aa83
                    if (!((v16 < 0 ^ ((v16 ^ v15) & (v15 ^ v6)) < 0))) {
                        // break -> 0x804aac6
                        break;
                    }
                    v9 = v15;
                    v10 += 4;
                    // continue -> 0x804aa87
                }
                // 0x804aac6
                return;
            }
            // 0x804aac6
            return;
        }
    }
    // 0x804aa65
    v1 = (struct _lsb__rsb__ptr_runtime_moduledata){
        .e0 = NULL,
        .e1 = 0,
        .e2 = 0
    };
    v1.e0 = v3;
    runtime_activeModules(v1);
    v5 = (int32_t)p;
    v7 = -v6;
    if (v7 < 0 ^ (v6 & v7) < 0) {
        // 0x804aa87
        v9 = 0;
        v10 = (int32_t)v3;
        // branch -> 0x804aa87
        while (true) {
            // 0x804aa87
            v8 = *(int32_t *)v10;
            v11 = *(int32_t *)(v8 + 64);
            if (v11 > v5) {
                goto lab_0x804aa9c_5;
            }
            goto lab_0x804aa9c_6;
        }
    }
}

// Address range: 0x804ab50 - 0x804abdf
void runtime_cgoCheckWriteBarrier(int32_t * dst, int32_t src) {
    // 0x804ab50
    uint32_t v1;
    runtime_cgoIsGoPointer((char *)src, v1 % 2 != 0);
    if (v1 % 256 == 0) {
        // 0x804abd9
        return;
    }
    // 0x804ab6a
    runtime_cgoIsGoPointer((char *)dst, v1 % 2 != 0);
}

// Address range: 0x804abe0 - 0x804ac4f
void runtime_cgoCheckMemmove(struct runtime__type * typ, char * dst, char * src, int32_t off, int32_t size) {
    // 0x804abe0
    if (*(char *)((int32_t)typ + 15) != -128) {
        // 0x804ac4a
        return;
    }
    // 0x804abf0
    uint32_t v1;
    runtime_cgoIsGoPointer(src, v1 % 2 != 0);
    if (v1 % 256 == 0) {
        // 0x804ac46
        return;
    }
    // 0x804ac05
    runtime_cgoIsGoPointer(dst, v1 % 2 != 0);
}

// Address range: 0x804acf0 - 0x804af4f
void runtime_cgoCheckTypedBlock(struct runtime__type * typ, char * src, uint32_t off, uint32_t size) {
    struct _lsb__rsb__ptr_runtime_moduledata v1; // 0x804ad25
    int32_t v2 = (int32_t)typ; // 0x804acf3_0
    uint32_t v3 = *(int32_t *)(v2 + 4); // 0x804acf7
    int32_t v4 = v3 - off; // 0x804acfe
    if (v3 <= off) {
        // 0x804af3a
        return;
    }
    int32_t v5 = v4; // 0x804af26
    if (v4 >= size) {
        // 0x804af33
        v5 = size;
        // branch -> 0x804ad14
    }
    // 0x804ad14
    if (*(char *)(v2 + 15) == 64) {
        // 0x804af14
        runtime_cgoCheckBits(src, (char *)*(int32_t *)(v2 + 20), off, v5);
        return;
    }
    // 0x804ad21
    v1 = (struct _lsb__rsb__ptr_runtime_moduledata){
        .e0 = NULL,
        .e1 = 0,
        .e2 = 0
    };
    int32_t v6;
    v1.e0 = (struct runtime_moduledata **)v6;
    runtime_activeModules(v1);
    uint32_t v7 = (int32_t)src; // 0x804ad31_0
    uint32_t v8; // 0x804ae5b
    int32_t v9;
    uint32_t v10;
    uint32_t v11; // 0x804adf5
    int32_t v12; // 0x804ae7763104
    int32_t v13; // 0x804ae65
    int32_t v14; // 0x804ae8e108
    int32_t v15; // 0x804ae56
    int32_t v16; // 0x804ae32
    int32_t v17; // 0x804ae4b
    int32_t v18; // 0x804ae80106
    uint32_t v19; // 0x804ae84105
    uint32_t v20; // 0x804adf9
    if (v10 <= 0) {
        // 0x804aded
        v11 = v7 - (int32_t)g29;
        v20 = v11 / 0x2000;
        if (v20 >= g27) {
            // 0x804af3e
            runtime_panicindex();
            return;
        }
        // 0x804ae12
        if (*(char *)(*(int32_t *)(4 * v20 + g26) + 60) == 2) {
            // 0x804aecf
            g7 = &v9;
            g2 = 0;
            function_808fd8b();
            v9 = (int32_t)runtime_cgoCheckTypedBlock_func1;
            runtime_systemstack();
            return;
        }
        // 0x804ae22
        v16 = g28 - v11 / 16 - 1;
        v17 = v5 + off;
        if (v17 != 0) {
            v14 = 0;
            v18 = v16;
            v12 = v16;
            v19 = v11 / 4 % 4;
            while (true) {
                // 0x804ae52
                v15 = (int32_t)*(char *)v18;
                v8 = v19 % 32;
                if (v8 == 0) {
                    v13 = v15;
                    goto lab_after_if_804ae5b_0;
                }
                goto lab_if_804ae5b_0_true;
            }
        }
        // 0x804aecb
        return;
    }
    int32_t v21 = 0; // 0x804ad3c111
    int32_t v22 = (int32_t)(char *)v6; // 0x804ad7b110
    while (true) {
        int32_t v23 = *(int32_t *)v22; // 0x804ad4d
        uint32_t v24 = *(int32_t *)(v23 + 64); // 0x804ad4f
        uint32_t v25 = *(int32_t *)(v23 + 68); // 0x804ad54
        if (v24 > v7) {
            // 0x804ad64
            // branch -> 0x804ad68
        } else {
            // 0x804ad64
            if (v7 < v25) {
                int32_t v26 = *(int32_t *)(v23 + 200); // 0x804adb9
                runtime_cgoCheckBits((char *)v24, (char *)v26, v7 - v24 + off, v5);
                return;
            }
        }
        uint32_t v27 = *(int32_t *)(v23 + 72); // 0x804ad68
        uint32_t v28 = *(int32_t *)(v23 + 76); // 0x804ad6b
        if (v27 > v7) {
            // 0x804ad7b
            // branch -> 0x804ad39
        } else {
            // 0x804ad7b
            if (((int32_t)(v7 < v28) || v28 & -256) != 0) {
                int32_t v29 = *(int32_t *)(v23 + 208); // 0x804ad85
                runtime_cgoCheckBits((char *)v27, (char *)v29, v7 - v27 + off, v5);
                return;
            }
        }
        int32_t v30 = v21 + 1; // 0x804ad3c
        if (v30 >= v10) {
            // break -> 0x804aded
            break;
        }
        v21 = v30;
        v22 += 4;
        // continue -> 0x804ad4d
    }
    // 0x804aded
    v11 = v7 - (int32_t)g29;
    v20 = v11 / 0x2000;
    if (v20 >= g27) {
        // 0x804af3e
        runtime_panicindex();
        return;
    }
    // 0x804ae12
    if (*(char *)(*(int32_t *)(4 * v20 + g26) + 60) == 2) {
        // 0x804aecf
        g7 = &v9;
        g2 = 0;
        function_808fd8b();
        v9 = (int32_t)runtime_cgoCheckTypedBlock_func1;
        runtime_systemstack();
        return;
    }
    // 0x804ae22
    v16 = g28 - v11 / 16 - 1;
    v17 = v5 + off;
    if (v17 == 0) {
        // 0x804aecb
        return;
    }
    v14 = 0;
    v18 = v16;
    v12 = v16;
    v19 = v11 / 4 % 4;
    while (true) {
        // 0x804ae52
        v15 = (int32_t)*(char *)v18;
        v8 = v19 % 32;
        v13 = v15;
        if (v8 != 0) {
          lab_if_804ae5b_0_true:;
            int32_t v31 = v15 >> v8; // 0x804ae5b
            if (v8 == 1) {
                // if_804ae5b_3_true
                v13 = v31;
                // branch -> after_if_804ae5b_0
            } else {
                v13 = v31;
            }
        }
      lab_after_if_804ae5b_0:;
        int32_t v32 = v12; // 0x804ae77
        if (v14 >= off) {
            // 0x804ae65
            if (v13 != 1) {
                char * v33 = (char *)*(int32_t *)(v14 + v7);
                runtime_cgoIsGoPointer(v33, v10 % 2 != 0);
                if (v10 % 256 != 0) {
                    // 0x804aebb
                    runtime_systemstack();
                    // branch -> 0x804aea3
                }
                // 0x804aea3
                v32 = v18;
                // branch -> 0x804ae6d
            } else {
                v32 = v12;
            }
        }
        // 0x804ae6d
        int32_t v34;
        int32_t v35; // 0x804ae5658
        int32_t v36; // 0x804ae7764
        if (v19 < 3) {
            // 0x804ae72
            v35 = v18;
            v36 = v32;
            v34 = v19 + 1;
            // branch -> 0x804ae3c
        } else {
            int32_t v37 = v32 - 1; // 0x804ae79
            v35 = v37;
            v36 = v37;
            v34 = 0;
            // branch -> 0x804ae3c
        }
        int32_t v38 = v14 + 4; // 0x804ae3c
        if (v38 >= v17) {
            // break -> 0x804aecb
            break;
        }
        v14 = v38;
        v18 = v35;
        v12 = v36;
        v19 = v34;
        // continue -> 0x804ae52
    }
}

// Address range: 0x804af50 - 0x804afff
void runtime_cgoCheckBits(char * src, char * gcbits, uint32_t off, int32_t size) {
    uint32_t v1 = off / 32; // 0x804af59
    int32_t v2 = 32 * v1; // 0x804af5e
    int32_t v3 = off - v2; // 0x804af61
    uint32_t v4 = v3 + size; // 0x804af67
    if (v4 != 0) {
        int32_t v5 = 0; // 0x804af8343
        int32_t v6 = 0; // 0x804aff842
        int32_t v7 = v1 + (int32_t)gcbits; // 0x804af9241
        while (true) {
            // 0x804af8a
            int32_t v8; // 0x804afab
            int32_t v9; // 0x804afb3
            if ((v5 & 28) == 0) {
                // 0x804af92
                v9 = v7 + 1;
                v8 = (int32_t)*(char *)v7;
                // branch -> 0x804af96
            } else {
                // 0x804aff8
                v9 = v7;
                v8 = v6 / 2;
                // branch -> 0x804af96
            }
            // 0x804af96
            int32_t v10; // 0x804af9645
            if (v3 == 0) {
                // 0x804af9f
                if (v8 % 2 != 0) {
                    int32_t v11 = *(int32_t *)(v5 + (int32_t)src + v2); // 0x804afbb
                    uint32_t v12;
                    runtime_cgoIsGoPointer((char *)v11, v12 % 2 != 0);
                    if (v12 % 256 != 0) {
                        // 0x804afe8
                        runtime_systemstack();
                        // branch -> 0x804afce
                    }
                    // 0x804afce
                    v10 = 0;
                    // branch -> 0x804af83
                } else {
                    v10 = 0;
                }
            } else {
                // 0x804af9a
                v10 = v3 - 4;
                // branch -> 0x804af83
            }
            int32_t v13 = v5 + 4; // 0x804af83
            if (v13 >= v4) {
                // break -> 0x804af86
                break;
            }
            v3 = v10;
            v5 = v13;
            v6 = v8;
            v7 = v9;
            // continue -> 0x804af8a
        }
        // 0x804af86
        // branch -> 0x804affc
    }
}

// Address range: 0x804ce70 - 0x804cf7f
void runtime_gogetenv(struct string key, struct string a2) {
    // 0x804ce70
    abort();
    // UNREACHABLE
}

// Address range: 0x804d1e0 - 0x804d21f
void runtime_typestring(struct runtime_eface x, struct string a2) {
    // 0x804d1e0
    abort();
    // UNREACHABLE
}

// Address range: 0x804d220 - 0x804db0f
void runtime_printany(struct runtime_eface i) {
    // 0x804d220
    abort();
    // UNREACHABLE
}

// Address range: 0x804e250 - 0x804e49f
void runtime_memhash(char * p, int32_t seed, int32_t s, int32_t a4) {
    // 0x804e250
    abort();
    // UNREACHABLE
}

// Address range: 0x804e4a0 - 0x804e7ef
void runtime__lb__ptr_hmap_rb__newoverflow(struct runtime_hmap * h, struct runtime_maptype * t, struct runtime_bmap * b, struct runtime_bmap * a4) {
    // 0x804e4a0
    abort();
    // UNREACHABLE
}

// Address range: 0x804e7f0 - 0x804ed7f
void runtime_makemap(struct runtime_maptype * t, int64_t hint, struct runtime_hmap * h, char * bucket, struct runtime_hmap * a5) {
    // 0x804e7f0
    abort();
    // UNREACHABLE
}

// Address range: 0x80500f0 - 0x80502af
void runtime_makeBucketArray(struct runtime_maptype * t, char b, char * buckets, struct runtime_bmap * nextOverflow) {
    // 0x80500f0
    abort();
    // UNREACHABLE
}

// Address range: 0x80502b0 - 0x805058f
void runtime_hashGrow(struct runtime_maptype * t, struct runtime_hmap * h) {
    // 0x80502b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8050590 - 0x805061f
void runtime_growWork(struct runtime_maptype * t, struct runtime_hmap * h, int32_t bucket) {
    // 0x8050590
    abort();
    // UNREACHABLE
}

// Address range: 0x8050620 - 0x8050eef
void runtime_evacuate(struct runtime_maptype * t, struct runtime_hmap * h, int32_t oldbucket) {
    // 0x8050620
    abort();
    // UNREACHABLE
}

// Address range: 0x8051050 - 0x80511af
void runtime_mapaccess1_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4) {
    // 0x8051050
    abort();
    // UNREACHABLE
}

// Address range: 0x80511b0 - 0x805131f
void runtime_mapaccess2_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4, bool a5) {
    // 0x80511b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8051320 - 0x80514af
void runtime_mapaccess2_fast64(struct runtime_maptype * t, struct runtime_hmap * h, int64_t key, char * a4, bool a5) {
    // 0x8051320
    abort();
    // UNREACHABLE
}

// Address range: 0x80514b0 - 0x805190f
void runtime_mapassign_fast32(struct runtime_maptype * t, struct runtime_hmap * h, int32_t key, char * a4) {
    // 0x80514b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8051910 - 0x8051d8f
void runtime_mapassign_fast64(struct runtime_maptype * t, struct runtime_hmap * h, int64_t key, char * a4) {
    // 0x8051910
    abort();
    // UNREACHABLE
}

// Address range: 0x8052240 - 0x80525bf
void runtime_getitab(struct runtime_interfacetype * inter, struct runtime__type * typ, bool canfail, struct runtime_itab * a4) {
    // 0x8052240
    abort();
    // UNREACHABLE
}

// Address range: 0x80525c0 - 0x8052abf
void runtime_additab(struct runtime_itab * m, bool locked, bool canfail) {
    // 0x80525c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8052ac0 - 0x8052b8f
void runtime_itabsinit(void) {
    // 0x8052ac0
    abort();
    // UNREACHABLE
}

// Address range: 0x8052b90 - 0x8052d0f
void runtime_panicdottypeE(struct runtime__type * have, struct runtime__type * want, struct runtime__type * iface) {
    // 0x8052b90
    abort();
    // UNREACHABLE
}

// Address range: 0x8052d10 - 0x8052d5f
void runtime_panicdottypeI(struct runtime_itab * have, struct runtime__type * want, struct runtime__type * iface) {
    // 0x8052d10
    abort();
    // UNREACHABLE
}

// Address range: 0x8052e40 - 0x8052ecf
void runtime_convT2Estring(struct runtime__type * t, char * elem, struct runtime_eface e) {
    // 0x8052e40
    abort();
    // UNREACHABLE
}

// Address range: 0x80530e0 - 0x805316f
void runtime_assertE2I2(struct runtime_interfacetype * inter, struct runtime_eface e, struct runtime_iface r, bool b) {
    // 0x80530e0
    abort();
    // UNREACHABLE
}

// Address range: 0x8053200 - 0x805335f
void runtime__lb__ptr_lfstack_rb__push(int64_t * head, struct runtime_lfnode * node) {
    // 0x8053200
    abort();
    // UNREACHABLE
}

// Address range: 0x8053360 - 0x805340f
void runtime__lb__ptr_lfstack_rb__pop(int64_t * head, char * a2) {
    // 0x8053360
    abort();
    // UNREACHABLE
}

// Address range: 0x8053410 - 0x805345f
void runtime__lb__ptr_lfstack_rb__empty(int64_t * head, bool a2) {
    // 0x8053410
    abort();
    // UNREACHABLE
}

// Address range: 0x8053460 - 0x805361f
void runtime_lock(struct runtime_mutex * l) {
    // 0x8053460
    abort();
    // UNREACHABLE
}

// Address range: 0x8053620 - 0x80536ef
void runtime_unlock(struct runtime_mutex * l) {
    // 0x8053620
    abort();
    // UNREACHABLE
}

// Address range: 0x80536f0 - 0x80537af
void runtime_notewakeup(struct runtime_note * n) {
    // 0x80536f0
    abort();
    // UNREACHABLE
}

// Address range: 0x80537b0 - 0x80538bf
void runtime_notesleep(struct runtime_note * n) {
    // 0x80537b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80538c0 - 0x8053aff
void runtime_notetsleep_internal(struct runtime_note * n, int64_t ns, bool a3) {
    // 0x80538c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8053b80 - 0x8053c1f
void runtime_notetsleepg(struct runtime_note * n, int64_t ns, bool a3) {
    // 0x8053b80
    abort();
    // UNREACHABLE
}

// Address range: 0x8053c20 - 0x805403f
void runtime_mallocinit(void) {
    // 0x8053c20
    abort();
    // UNREACHABLE
}

// Address range: 0x8054040 - 0x80543df
void runtime__lb__ptr_mheap_rb__sysAlloc(struct runtime_mheap * h, int32_t n, char * a3) {
    // 0x8054040
    abort();
    // UNREACHABLE
}

// Address range: 0x80543e0 - 0x80544df
void runtime_nextFreeFast(struct runtime_mspan * s, int32_t a2) {
    // 0x80543e0
    abort();
    // UNREACHABLE
}

// Address range: 0x80544e0 - 0x805472f
void runtime__lb__ptr_mcache_rb__nextFree(struct runtime_mcache * c, char spc, int32_t v, struct runtime_mspan * s, bool shouldhelpgc) {
    // 0x80544e0
    abort();
    // UNREACHABLE
}

// Address range: 0x8054730 - 0x8054e8f
void runtime_mallocgc(int32_t size, struct runtime__type * typ, bool needzero, char * a4) {
    // 0x8054730
    abort();
    // UNREACHABLE
}

// Address range: 0x8054fa0 - 0x8054fdf
void runtime_newobject(struct runtime__type * typ, char * a2) {
    // 0x8054fa0
    abort();
    // UNREACHABLE
}

// Address range: 0x8055020 - 0x80550af
void runtime_newarray(struct runtime__type * typ, int32_t n, char * a3) {
    // 0x8055020
    abort();
    // UNREACHABLE
}

// Address range: 0x80550b0 - 0x80550ff
void runtime_profilealloc(struct runtime_m * mp, char * x, int32_t size) {
    // 0x80550b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8055100 - 0x80552bf
void runtime_nextSample(int32_t a1) {
    // 0x8055100
    abort();
    // UNREACHABLE
}

// Address range: 0x80552c0 - 0x805533f
void runtime_persistentalloc(int32_t size, int32_t align, int64_t * sysStat, char * a4) {
    // 0x80552c0
    abort();
    // UNREACHABLE
}

// Address range: 0x80556a0 - 0x805576f
void runtime_writebarrierptr_prewrite1(int32_t * dst, int32_t src) {
    // 0x80556a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8055770 - 0x805580f
void runtime_writebarrierptr(int32_t * dst, int32_t src) {
    // 0x8055770
    if (g32 != 0) {
        // 0x80557ec
        runtime_cgoCheckWriteBarrier(dst, src);
        // branch -> 0x805577e
    }
    // 0x805577e
    if (g31 == 0) {
        // 0x80557de
        *dst = src;
        return;
    }
    // 0x8055789
    if (src == 0) {
        // 0x8055798
        runtime_writebarrierptr_prewrite1(dst, 0);
        *dst = src;
        return;
    }
    // 0x8055791
    if (src < 0x1000) {
        // 0x80557b6
        runtime_systemstack();
        // branch -> 0x8055798
    }
    // 0x8055798
    runtime_writebarrierptr_prewrite1(dst, src);
    *dst = src;
}

// Address range: 0x8055810 - 0x805587f
void runtime_writebarrierptr_prewrite(int32_t * dst, int32_t src) {
    // 0x8055810
    if (g32 != 0) {
        // 0x8055864
        runtime_cgoCheckWriteBarrier(dst, src);
        // branch -> 0x805581e
    }
    // 0x805581e
    if (g31 == 0) {
        // 0x8055860
        return;
    }
    // 0x8055829
    if (src == 0) {
        // 0x8055838
        runtime_writebarrierptr_prewrite1(dst, 0);
        return;
    }
    // 0x8055831
    if (src < 0x1000) {
        // 0x805584c
        runtime_systemstack();
        // branch -> 0x8055838
    }
    // 0x8055838
    runtime_writebarrierptr_prewrite1(dst, src);
}

// Address range: 0x8055880 - 0x805590f
void runtime_typedmemmove(struct runtime__type * typ, char * dst, char * src) {
    int32_t v1 = (int32_t)typ; // 0x8055883_0
    g2 = v1;
    if (*(char *)(v1 + 15) == -128) {
        // 0x80558e5
        runtime_bulkBarrierPreWrite((int32_t)dst, (int32_t)src, typ->e0);
        g2 = (int32_t)typ;
        // branch -> 0x8055890
    } else {
        // 0x8055880
        // branch -> 0x8055890
    }
    // 0x8055890
    g5 = (int32_t)dst;
    g8 = (int32_t)src;
    runtime_memmove();
    if (g32 != 0) {
        // 0x80558b9
        runtime_cgoCheckMemmove(typ, dst, src, 0, typ->e0);
        // branch -> 0x80558b5
    }
}

// Address range: 0x8055a50 - 0x8055acf
void runtime_reflectcallmove(struct runtime__type * typ, char * dst, char * src, int32_t size) {
    // 0x8055a50
    if (g31 == 0) {
        // 0x8055ac2
        g2 = size;
        // branch -> 0x8055a78
        // 0x8055a78
        g5 = (int32_t)src;
        runtime_memmove();
        return;
    }
    // 0x8055a5e
    if (typ == NULL) {
        // 0x8055abc
        g2 = size;
        // branch -> 0x8055a78
    } else {
        // 0x8055a66
        g2 = size;
        if (*(char *)((int32_t)typ + 15) == -128) {
            // 0x8055a6f
            if (size > 3) {
                // 0x8055a94
                runtime_bulkBarrierPreWrite((int32_t)dst, (int32_t)src, size);
                g2 = size;
                // branch -> 0x8055a78
            }
        }
    }
    // 0x8055a78
    g5 = (int32_t)src;
    runtime_memmove();
}

// Address range: 0x8055bf0 - 0x8055c3f
void runtime_typedmemclr(struct runtime__type * typ, char * ptr) {
    // 0x8055bf0
    if (*(char *)((int32_t)typ + 15) == -128) {
        // 0x8055c16
        runtime_bulkBarrierPreWrite((int32_t)ptr, 0, typ->e0);
        // branch -> 0x8055c00
    }
    // 0x8055c00
    runtime_memclrNoHeapPointers();
}

// Address range: 0x8055c40 - 0x8055c7f
void runtime_memclrHasPointers(char * ptr, int32_t n) {
    // 0x8055c40
    runtime_bulkBarrierPreWrite((int32_t)ptr, 0, n);
    runtime_memclrNoHeapPointers();
}

// Address range: 0x8055c80 - 0x8055d2f
void runtime__lb__ptr_mheap_rb__mapBits(struct runtime_mheap * h, int32_t arena_used) {
    // 0x8055c80
    abort();
    // UNREACHABLE
}

// Address range: 0x8055d30 - 0x8055dcf
void runtime__lb__ptr_mspan_rb__refillAllocCache(struct runtime_mspan * s, int32_t whichByte) {
    // 0x8055d30
    abort();
    // UNREACHABLE
}

// Address range: 0x8055dd0 - 0x8055f6f
void runtime__lb__ptr_mspan_rb__nextFreeIndex(struct runtime_mspan * s, int32_t a2) {
    // 0x8055dd0
    abort();
    // UNREACHABLE
}

// Address range: 0x8055f70 - 0x805608f
void runtime_markBitsForAddr(int32_t p, struct runtime_markBits a2) {
    // 0x8055f70
    abort();
    // UNREACHABLE
}

// Address range: 0x8056090 - 0x80560cf
void runtime_markBits_setMarked(struct runtime_markBits m) {
    // 0x8056090
    abort();
    // UNREACHABLE
}

// Address range: 0x8056200 - 0x805660f
void runtime_heapBitsForObject(int32_t p, int32_t refBase, int32_t refOff, int32_t base, struct runtime_heapBits hbits, struct runtime_mspan * s, int32_t objIndex) {
    // 0x8056200
    abort();
    // UNREACHABLE
}

// Address range: 0x8056610 - 0x805668f
void runtime_heapBits_setCheckmarked(struct runtime_heapBits h, int32_t size) {
    // 0x8056610
    abort();
    // UNREACHABLE
}

// Address range: 0x8056690 - 0x805692f
void runtime_bulkBarrierPreWrite(uint32_t dst, int32_t src, uint32_t size) {
    int32_t v1 = dst;
    g8 = dst;
    if ((src || dst || size) != 3) {
        // 0x805690f
        runtime_throw((struct string){.e0 = "bulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        return;
    }
    // 0x80566b0
    if (g31 == 0) {
        // 0x8056904
        return;
    }
    // 0x80566bf
    if (dst != 0) {
        uint32_t v2 = (int32_t)g29;
        uint32_t v3 = dst - v2; // 0x80566cd
        if (v2 <= dst) {
            // 0x80566d5
            if (g30 > dst) {
                uint32_t v4 = v3 / 0x2000; // 0x80566f5
                g8 = v4;
                if (v4 >= g27) {
                    // 0x8056908
                    runtime_panicindex();
                    // branch -> 0x805690f
                    // 0x805690f
                    runtime_throw((struct string){.e0 = "bulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
                    return;
                }
                int32_t v5 = *(int32_t *)(g26 + 4 * v4); // 0x8056700
                g8 = v5;
                if (v5 == 0 || *(int32_t *)(v5 + 12) > dst) {
                    // 0x805681d
                    abort();
                    // UNREACHABLE
                }
                // 0x8056716
                if (*(int32_t *)(v5 + 80) > dst) {
                    unsigned char v6 = *(char *)(v5 + 60); // 0x8056721
                    g8 = v6;
                    if (v6 == 1) {
                        int32_t v7 = g28 - v3 / 16 - 1; // 0x805673e
                        g8 = v7;
                        int32_t v8 = v3 / 4 % 4; // 0x8056741
                        if (src == 0) {
                            // 0x8056748
                            if (size != 0) {
                                int32_t v9 = 0; // 0x8056777117
                                while (true) {
                                    int32_t v10 = (int32_t)*(char *)v7; // 0x8056755
                                    uint32_t v11 = v8 % 32; // 0x805675c
                                    int32_t v12 = v10; // 0x805675e
                                    if (v11 != 0) {
                                        int32_t v13 = v10 >> v11; // 0x805675c
                                        if (v11 == 1) {
                                            // if_805675c_3_true
                                            v12 = v13;
                                            // branch -> after_if_805675c_0
                                        } else {
                                            v12 = v13;
                                        }
                                    }
                                    int32_t v14 = dst; // 0x805674f
                                    int32_t v15 = v7; // 0x805676e
                                    if (v12 != 1) {
                                        // 0x8056777
                                        runtime_writebarrierptr_prewrite1((int32_t *)(v9 + dst), 0);
                                        g8 = v7;
                                        v14 = v1;
                                        v15 = v7;
                                        // branch -> 0x8056766
                                    }
                                    // 0x8056766
                                    int32_t v16;
                                    int32_t v17; // 0x805676e88
                                    if (v8 < 3) {
                                        // 0x805676b
                                        v17 = v15;
                                        v16 = v8 + 1;
                                        // branch -> 0x805674c
                                    } else {
                                        int32_t v18 = v15 - 1; // 0x8056770
                                        g8 = v18;
                                        v17 = v18;
                                        v16 = 0;
                                        // branch -> 0x805674c
                                    }
                                    int32_t v19 = v9 + 4; // 0x805674c
                                    if (v19 >= size) {
                                        // break -> 0x80567ae
                                        break;
                                    }
                                    v9 = v19;
                                    v7 = v17;
                                    dst = v14;
                                    v8 = v16;
                                    // continue -> 0x8056755
                                }
                                // 0x80567ae
                                return;
                            }
                        } else {
                            // 0x80567b2
                            if (size != 0) {
                                int32_t v20 = 0; // 0x80567f4128
                                while (true) {
                                    int32_t v21 = (int32_t)*(char *)v7; // 0x80567c1
                                    uint32_t v22 = v8 % 32; // 0x80567c6
                                    int32_t v23 = v21; // 0x80567c8
                                    if (v22 != 0) {
                                        int32_t v24 = v21 >> v22; // 0x80567c6
                                        if (v22 == 1) {
                                            // if_80567c6_3_true
                                            v23 = v24;
                                            // branch -> after_if_80567c6_0
                                        } else {
                                            v23 = v24;
                                        }
                                    }
                                    int32_t v25 = v7; // 0x80567d8
                                    if (v23 != 1) {
                                        int32_t v26 = *(int32_t *)(v20 + src); // 0x80567f7
                                        runtime_writebarrierptr_prewrite1((int32_t *)(v20 + dst), v26);
                                        g8 = v7;
                                        v25 = v7;
                                        // branch -> 0x80567d0
                                    }
                                    // 0x80567d0
                                    int32_t v27;
                                    int32_t v28; // 0x80567d874
                                    if (v8 < 3) {
                                        // 0x80567d5
                                        v28 = v25;
                                        v27 = v8 + 1;
                                        // branch -> 0x80567b6
                                    } else {
                                        int32_t v29 = v25 - 1; // 0x80567da
                                        g8 = v29;
                                        v28 = v29;
                                        v27 = 0;
                                        // branch -> 0x80567b6
                                    }
                                    int32_t v30 = v20 + 4; // 0x80567b6
                                    if (v30 >= size) {
                                        // break -> 0x80567ae
                                        break;
                                    }
                                    v20 = v30;
                                    v7 = v28;
                                    v8 = v27;
                                    dst = v1;
                                    // continue -> 0x80567c1
                                }
                                // 0x80567ae
                                return;
                            }
                        }
                        // 0x80567ae
                        return;
                    }
                }
                // 0x805681d
                abort();
                // UNREACHABLE
            }
        }
    }
    // 0x80568fd
    // branch -> 0x805681d
    // 0x805681d
    abort();
    // UNREACHABLE
}

// Address range: 0x8056930 - 0x80569df
void runtime_bulkBarrierBitmap(int32_t dst, int32_t src, uint32_t size, uint32_t maskOffset, char * bits) {
    uint32_t v1 = maskOffset / 4 % 8; // 0x805693f
    int32_t v2 = 1; // 0x805695e20
    if (v1 != 0) {
        int32_t v3 = 1 << v1; // 0x8056947
        if (v1 == 1) {
            // if_8056947_3_true
            v2 = v3;
            // branch -> after_if_8056947_0
        } else {
            v2 = v3;
        }
    }
    // after_if_8056947_0
    if (size != 0) {
        int32_t v4 = 0; // 0x805696c42
        int32_t v5 = v2; // 0x805695e41
        int32_t v6 = (int32_t)bits + maskOffset / 32; // 0x805696240
        while (true) {
            // 0x805695e
            int32_t v7; // 0x8056962
            int32_t v8; // 0x805697f
            int32_t v9; // 0x805698b
            if (0x1000000 * v5 == 0) {
                // 0x8056962
                v7 = v6 + 1;
                int32_t v10; // 0x805695e21
                int32_t v11; // 0x8056953
                if (*(char *)v7 == 0) {
                    // 0x805696c
                    v11 = v4 + 28;
                    v10 = v5;
                    // branch -> 0x8056953
                } else {
                    // 0x8056971
                    v9 = 1;
                    // branch -> 0x8056976
                    // 0x8056976
                    v8 = v9;
                    if (v9 != (int32_t)*(char *)v7) {
                      lab_0x8056983:;
                        int32_t v12 = dst + v4; // 0x8056993
                        if (src == 0) {
                            // 0x805699e
                            runtime_writebarrierptr_prewrite1((int32_t *)v12, 0);
                            // branch -> 0x80569ae
                        } else {
                            // 0x80569c1
                            runtime_writebarrierptr_prewrite1((int32_t *)v12, *(int32_t *)(v4 + src));
                            // branch -> 0x80569ae
                        }
                        // 0x80569ae
                        v8 = v9 % 256;
                        // branch -> 0x805697f
                    }
                  lab_0x805697f:
                    // 0x805697f
                    v11 = v4;
                    v10 = 2 * v8;
                    // branch -> 0x8056953
                }
                int32_t v13 = v11 + 4; // 0x8056953
                if (v13 >= size) {
                    // break -> 0x8056956
                    break;
                }
                v4 = v13;
                v5 = v10;
                v6 = v7;
                // continue -> 0x805695e
                continue;
            } else {
                v9 = v5;
                v7 = v6;
                // 0x8056976
                if (v9 == (int32_t)*(char *)v7) {
                    v8 = v9;
                    goto lab_0x805697f;
                }
                goto lab_0x8056983;
            }
        }
        // 0x8056956
        // branch -> 0x80569d4
    }
}

// Address range: 0x8056e10 - 0x805735f
void runtime_heapBitsSetType(int32_t x, int32_t size, int32_t dataSize, struct runtime__type * typ) {
    // 0x8056e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8057360 - 0x805762f
void runtime_heapBitsSetTypeGCProg(struct runtime_heapBits h, int32_t progSize, int32_t elemSize, int32_t dataSize, int32_t allocSize, char * prog) {
    // 0x8057360
    abort();
    // UNREACHABLE
}

// Address range: 0x8057630 - 0x805771f
void runtime_progToPointerMask(char * prog, int32_t size, struct runtime_bitvector a3) {
    // 0x8057630
    abort();
    // UNREACHABLE
}

// Address range: 0x8057720 - 0x8057e8f
void runtime_runGCProg(char * prog, char * trailer, char * dst, int32_t size, int32_t a5) {
    // 0x8057720
    abort();
    // UNREACHABLE
}

// Address range: 0x8057e90 - 0x8057f2f
void runtime_allocmcache(struct runtime_mcache * a1) {
    // 0x8057e90
    abort();
    // UNREACHABLE
}

// Address range: 0x8057f30 - 0x8057f6f
void runtime_freemcache(struct runtime_mcache * c) {
    // 0x8057f30
    abort();
    // UNREACHABLE
}

// Address range: 0x8058090 - 0x805812f
void runtime__lb__ptr_mcache_rb__releaseAll(struct runtime_mcache * c) {
    // 0x8058090
    abort();
    // UNREACHABLE
}

// Address range: 0x8058590 - 0x80586cf
void runtime__lb__ptr_mcentral_rb__uncacheSpan(struct runtime_mcentral * c, struct runtime_mspan * s) {
    // 0x8058590
    abort();
    // UNREACHABLE
}

// Address range: 0x8058930 - 0x80589af
void runtime_addrspace_free(char * v, int32_t n, bool a3) {
    // 0x8058930
    abort();
    // UNREACHABLE
}

// Address range: 0x80589b0 - 0x8058a9f
void runtime_mmap_fixed(char * v, int32_t n, int32_t prot, int32_t flags, int32_t fd, int32_t offset, char * a7) {
    // 0x80589b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8058aa0 - 0x8058b7f
void runtime_sysAlloc(int32_t n, int64_t * sysStat, char * a3) {
    // 0x8058aa0
    runtime_mmap();
    uint32_t v1;
    if (v1 > 4095) {
        // 0x8058b5f
        runtime_mSysStatInc(sysStat, n);
        return;
    }
    int32_t v2 = v1; // 0x8058aee
    if (v1 == 13) {
        // 0x8058b2d
        runtime_printlock();
        runtime_printstring((struct string){.e0 = "runtime: mmap: access denied\nruntime: split stack overflowruntime: stat underflow: val runtime: sudog with non-nil cruntime: unknown pc in defer semacquire not on the G stackstring concatenation too longsyntax error scanning booleantoo many open files in systemtraceback has leftover defers locals stack map entries for 227373675443232059478759765625MHeap_AllocLocked - bad npagesSIGPROF: profiling alarm clockSIGUSR1: user-defined signal 1SIGUSR2: user-defined signal 2SIGVTALRM: virtual alarm clockassignment to entry in nil mapcheckdead: inconsistent countsfailed to get system page sizefreedefer with d._panic != nilinappropriate ioctl for deviceinvalid function symbol table\ninvalid pointer found on stackneed padding in bucket (value)protocol wrong type for socketreflect: Len of non-array typerunqputslow: queue is not fullruntime: bad pointer in frame runtime: found in object at *(socket operation on non-socketsync: inconsistent mutex statesync: unlock of unlocked mutex...additional frames elided...\n.lib section in a.out corrupted11368683772161602973937988281255684341886080801486968994140625SIGSEGV: segmentation violationcannot assign requested addresscasgstatus: bad incoming valuescheckmark found unmarked objectentersyscallblock inconsistent fmt: unknown base; can't happeninserting span already in treapinternal error - misuse of itabmalformed time zone informationnon in-use span in unswept listpacer: sweep done at heap size reflect: NumIn of non-func typeresetspinning: not a spinning mruntime: address space conflictruntime: cannot allocate memoryruntime: split stack overflow: 28421709430404007434844970703125SIGFPE: floating-point exceptionSIGTTOU: background write to ttygchelper not running on g0 stacknon-Go code disabled sigaltstacknumerical argument out of domainpanic while printing panic valuereflect.nameFrom: tag too long: reflect: NumOut of non-func typeremovespecial on invalid pointerresource temporarily unavailableruntime: epollcreate failed withruntime: failed MSpanList_Insertruntime: mcall function returnedruntime: newstack called from g=runtime: stack split at bad timeruntime: sudog with non-nil elemruntime: sudog with non-nil nextruntime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        runtime_printunlock();
        runtime_exit();
        v2 = 13;
        // branch -> 0x8058aee
    }
    // 0x8058aee
    if (v2 == 11) {
        // 0x8058aff
        runtime_printlock();
        runtime_printstring((struct string){.e0 = "runtime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        runtime_printunlock();
        runtime_exit();
        // branch -> 0x8058af3
    }
}

// Address range: 0x8058ce0 - 0x8058d3f
void runtime_sysUsed(char * v, int32_t n) {
    // 0x8058ce0
    abort();
    // UNREACHABLE
}

// Address range: 0x8058d40 - 0x8058d6f
void runtime_sysFree(char * v, int32_t n, int64_t * sysStat) {
    // 0x8058d40
    runtime_mSysStatDec(sysStat, n);
    runtime_munmap();
}

// Address range: 0x8058d70 - 0x8058dcf
void runtime_sysFault(char * v, int32_t n) {
    // 0x8058d70
    abort();
    // UNREACHABLE
}

// Address range: 0x8058dd0 - 0x8058e4f
void runtime_sysReserve(char * v, int32_t n, bool * reserved, char * a4) {
    // 0x8058dd0
    abort();
    // UNREACHABLE
}

// Address range: 0x8058e50 - 0x8058fff
void runtime_sysMap(char * v, int32_t n, bool reserved, int64_t * sysStat) {
    // 0x8058e50
    abort();
    // UNREACHABLE
}

// Address range: 0x8059250 - 0x80592cf
void runtime_wakefing(struct runtime_g * a1) {
    // 0x8059250
    abort();
    // UNREACHABLE
}

// Address range: 0x8059f80 - 0x805a0af
void runtime__lb__ptr_fixalloc_rb__alloc(struct runtime_fixalloc * f, char * a2) {
    // 0x8059f80
    abort();
    // UNREACHABLE
}

// Address range: 0x805a0b0 - 0x805a16f
void runtime_gcinit(void) {
    // 0x805a0b0
    abort();
    // UNREACHABLE
}

// Address range: 0x805a170 - 0x805a1ff
void runtime_readgogc(int32_t a1) {
    // 0x805a170
    abort();
    // UNREACHABLE
}

// Address range: 0x805a280 - 0x805a33f
void runtime_debug_setGCPercent(int32_t in, int32_t out) {
    // 0x805a280
    abort();
    // UNREACHABLE
}

// Address range: 0x805a340 - 0x805a39f
void runtime_setGCPhase(int32_t x) {
    // 0x805a340
    runtime_internal_atomic_Store();
    int32_t v1 = 1;
    if (runtime_gcphase != 1) {
        // 0x805a38b
        v1 = (int32_t)(runtime_gcphase == 2) | runtime_gcphase & -256;
        // branch -> 0x805a369
    }
    // 0x805a369
    g31 = v1;
    int32_t v2 = 1;
    if (0x1000000 * v1 == 0) {
        // 0x805a382
        v2 = g32;
        // branch -> 0x805a378
    }
    // 0x805a378
    *(char *)&runtime_writeBarrier = (char)v2;
}

// Address range: 0x805a3a0 - 0x805a81f
void runtime__lb__ptr_gcControllerState_rb__startCycle(struct runtime_gcControllerState * c) {
    // 0x805a3a0
    abort();
    // UNREACHABLE
}

// Address range: 0x805a820 - 0x805a97f
void runtime__lb__ptr_gcControllerState_rb__revise(struct runtime_gcControllerState * c) {
    // 0x805a820
    abort();
    // UNREACHABLE
}

// Address range: 0x805a980 - 0x805ae6f
void runtime__lb__ptr_gcControllerState_rb__endCycle(struct runtime_gcControllerState * c, float64_t a2) {
    // 0x805a980
    abort();
    // UNREACHABLE
}

// Address range: 0x805ae70 - 0x805afbf
void runtime__lb__ptr_gcControllerState_rb__enlistWorker(struct runtime_gcControllerState * c) {
    // 0x805ae70
    abort();
    // UNREACHABLE
}

// Address range: 0x805afc0 - 0x805b1df
void runtime__lb__ptr_gcControllerState_rb__findRunnableGCWorker(struct runtime_gcControllerState * c, struct runtime_p * _p_, struct runtime_g * a3) {
    // 0x805afc0
    abort();
    // UNREACHABLE
}

// Address range: 0x805b1e0 - 0x805b80f
void runtime_gcSetTriggerRatio(float64_t triggerRatio) {
    // 0x805b1e0
    abort();
    // UNREACHABLE
}

// Address range: 0x805b810 - 0x805b95f
void runtime_gcTrigger_test(struct runtime_gcTrigger t, bool a2) {
    // 0x805b810
    abort();
    // UNREACHABLE
}

// Address range: 0x805b960 - 0x805bd3f
void runtime_gcStart(int32_t mode, struct runtime_gcTrigger trigger) {
    // 0x805b960
    abort();
    // UNREACHABLE
}

// Address range: 0x805bd40 - 0x805bf8f
void runtime_gcMarkDone(void) {
    // 0x805bd40
    abort();
    // UNREACHABLE
}

// Address range: 0x805bf90 - 0x805ce6f
void runtime_gcMarkTermination(float64_t nextTriggerRatio) {
    // 0x805bf90
    abort();
    // UNREACHABLE
}

// Address range: 0x805ce70 - 0x805cf1f
void runtime_gcBgMarkStartWorkers(void) {
    // 0x805ce70
    abort();
    // UNREACHABLE
}

// Address range: 0x805d440 - 0x805d4ef
void runtime_gcMarkWorkAvailable(struct runtime_p * p, bool a2) {
    // 0x805d440
    abort();
    // UNREACHABLE
}

// Address range: 0x805da00 - 0x805dabf
void runtime_gcResetMarkState(void) {
    // 0x805da00
    abort();
    // UNREACHABLE
}

// Address range: 0x805db10 - 0x805dc9f
void runtime_clearpools(void) {
    // 0x805db10
    abort();
    // UNREACHABLE
}

// Address range: 0x805dca0 - 0x805ddcf
void runtime_gchelper(void) {
    // 0x805dca0
    abort();
    // UNREACHABLE
}

// Address range: 0x805ddd0 - 0x805de4f
void runtime_gchelperstart(void) {
    // 0x805ddd0
    abort();
    // UNREACHABLE
}

// Address range: 0x805de50 - 0x805df9f
void runtime_itoaDiv(struct _lsb__rsb_uint8 buf, int64_t val, int32_t dec, struct _lsb__rsb_uint8 a4) {
    // 0x805de50
    abort();
    // UNREACHABLE
}

// Address range: 0x805dfa0 - 0x805e15f
void runtime_fmtNSAsMS(struct _lsb__rsb_uint8 buf, int64_t ns, struct _lsb__rsb_uint8 a3) {
    // 0x805dfa0
    abort();
    // UNREACHABLE
}

// Address range: 0x805e160 - 0x805e3ff
void runtime__lb__ptr_mTreap_rb__insert(struct runtime_mTreap * root, struct runtime_mspan * span) {
    // 0x805e160
    abort();
    // UNREACHABLE
}

// Address range: 0x805e400 - 0x805e50f
void runtime__lb__ptr_mTreap_rb__removeNode(struct runtime_mTreap * root, struct runtime_treapNode * t, struct runtime_mspan * a3) {
    // 0x805e400
    abort();
    // UNREACHABLE
}

// Address range: 0x805e510 - 0x805e5af
void runtime__lb__ptr_mTreap_rb__remove(struct runtime_mTreap * root, int32_t npages, struct runtime_mspan * a3) {
    // 0x805e510
    abort();
    // UNREACHABLE
}

// Address range: 0x805e5b0 - 0x805e61f
void runtime__lb__ptr_mTreap_rb__removeSpan(struct runtime_mTreap * root, struct runtime_mspan * span) {
    // 0x805e5b0
    abort();
    // UNREACHABLE
}

// Address range: 0x805e710 - 0x805e7af
void runtime__lb__ptr_mTreap_rb__rotateLeft(struct runtime_mTreap * root, struct runtime_treapNode * x) {
    // 0x805e710
    abort();
    // UNREACHABLE
}

// Address range: 0x805e7b0 - 0x805e83f
void runtime__lb__ptr_mTreap_rb__rotateRight(struct runtime_mTreap * root, struct runtime_treapNode * y) {
    // 0x805e7b0
    abort();
    // UNREACHABLE
}

// Address range: 0x805e840 - 0x805ea3f
void runtime_gcMarkRootPrepare(void) {
    // 0x805e840
    abort();
    // UNREACHABLE
}

// Address range: 0x805ea40 - 0x805ed0f
void runtime_gcMarkRootCheck(void) {
    // 0x805ea40
    abort();
    // UNREACHABLE
}

// Address range: 0x805ed10 - 0x805f00f
void runtime_markroot(struct runtime_gcWork * gcw, int32_t i) {
    // 0x805ed10
    abort();
    // UNREACHABLE
}

// Address range: 0x805f010 - 0x805f08f
void runtime_markrootBlock(int32_t b0, int32_t n0, char * ptrmask0, struct runtime_gcWork * gcw, int32_t shard) {
    // 0x805f010
    abort();
    // UNREACHABLE
}

// Address range: 0x805f1a0 - 0x805f3bf
void runtime_markrootSpans(struct runtime_gcWork * gcw, int32_t shard) {
    // 0x805f1a0
    abort();
    // UNREACHABLE
}

// Address range: 0x805f3c0 - 0x805f7df
void runtime_gcAssistAlloc(struct runtime_g * gp) {
    // 0x805f3c0
    abort();
    // UNREACHABLE
}

// Address range: 0x805fc80 - 0x805fcef
void runtime_gcWakeAllAssists(void) {
    // 0x805fc80
    abort();
    // UNREACHABLE
}

// Address range: 0x805fcf0 - 0x805fe5f
void runtime_gcParkAssist(bool a1) {
    // 0x805fcf0
    abort();
    // UNREACHABLE
}

// Address range: 0x805fe60 - 0x80600af
void runtime_gcFlushBgCredit(int64_t scanWork) {
    // 0x805fe60
    abort();
    // UNREACHABLE
}

// Address range: 0x80600b0 - 0x806052f
void runtime_scanstack(struct runtime_g * gp, struct runtime_gcWork * gcw) {
    // 0x80600b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8060ae0 - 0x8060fcf
void runtime_gcDrain(struct runtime_gcWork * gcw, int32_t flags) {
    // 0x8060ae0
    abort();
    // UNREACHABLE
}

// Address range: 0x8061240 - 0x806136f
void runtime_scanblock(int32_t b0, int32_t n0, char * ptrmask, struct runtime_gcWork * gcw) {
    // 0x8061240
    abort();
    // UNREACHABLE
}

// Address range: 0x8061370 - 0x806163f
void runtime_scanobject(int32_t b, struct runtime_gcWork * gcw) {
    // 0x8061370
    abort();
    // UNREACHABLE
}

// Address range: 0x8061710 - 0x8061b8f
void runtime_greyobject(int32_t obj, int32_t base, int32_t off, struct runtime_heapBits hbits, struct runtime_mspan * span, struct runtime_gcWork * gcw, int32_t objIndex) {
    // 0x8061710
    abort();
    // UNREACHABLE
}

// Address range: 0x8061b90 - 0x806206f
void runtime_gcDumpObject(struct string label, int32_t obj, int32_t off) {
    // 0x8061b90
    abort();
    // UNREACHABLE
}

// Address range: 0x8062070 - 0x806214f
void runtime_gcmarknewobject(int32_t obj, int32_t size, int32_t scanSize) {
    struct runtime_markBits v1; // 0x8062094
    // 0x8062070
    int32_t v2;
    char * v3 = (char *)v2;
    if (*(char *)&runtime_useCheckmark == 0) {
        // 0x806208d
        v1 = (struct runtime_markBits){
            .e0 = NULL,
            .e1 = 0,
            .e2 = 0
        };
        v1.e0 = v3;
        runtime_markBitsForAddr(obj, v1);
        runtime_markBits_setMarked(v1);
        abort();
        // UNREACHABLE
    }
    // 0x806207e
    if (*(char *)&runtime_gcBlackenPromptly == 0) {
        // 0x806212e
        runtime_throw((struct string){.e0 = "gcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        return;
    }
    // 0x806208d
    v1 = (struct runtime_markBits){
        .e0 = NULL,
        .e1 = 0,
        .e2 = 0
    };
    v1.e0 = v3;
    runtime_markBitsForAddr(obj, v1);
    runtime_markBits_setMarked(v1);
    abort();
    // UNREACHABLE
}

// Address range: 0x8062150 - 0x806225f
void runtime_gcMarkTinyAllocs(void) {
    // 0x8062150
    abort();
    // UNREACHABLE
}

// Address range: 0x8062960 - 0x80629af
void runtime_gosweepone(int32_t a1) {
    // 0x8062960
    abort();
    // UNREACHABLE
}

// Address range: 0x8063760 - 0x80637af
void runtime__lb__ptr_gcSweepBuf_rb__numBlocks(struct runtime_gcSweepBuf * b, int32_t a2) {
    // 0x8063760
    abort();
    // UNREACHABLE
}

// Address range: 0x80637b0 - 0x80638af
void runtime__lb__ptr_gcSweepBuf_rb__block(struct runtime_gcSweepBuf * b, int32_t i, struct _lsb__rsb__ptr_runtime_mspan a3) {
    // 0x80637b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80638d0 - 0x806391f
void runtime__lb__ptr_gcWork_rb__init(struct runtime_gcWork * w) {
    // 0x80638d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8063920 - 0x80639ef
void runtime__lb__ptr_gcWork_rb__put(struct runtime_gcWork * w, int32_t obj) {
    // 0x8063920
    abort();
    // UNREACHABLE
}

// Address range: 0x80639f0 - 0x8063aaf
void runtime__lb__ptr_gcWork_rb__tryGet(struct runtime_gcWork * w, int32_t a2) {
    // 0x80639f0
    abort();
    // UNREACHABLE
}

// Address range: 0x8063ab0 - 0x8063b6f
void runtime__lb__ptr_gcWork_rb__get(struct runtime_gcWork * w, int32_t a2) {
    // 0x8063ab0
    abort();
    // UNREACHABLE
}

// Address range: 0x8063b70 - 0x8063c8f
void runtime__lb__ptr_gcWork_rb__dispose(struct runtime_gcWork * w) {
    // 0x8063b70
    abort();
    // UNREACHABLE
}

// Address range: 0x8063c90 - 0x8063d1f
void runtime__lb__ptr_gcWork_rb__balance(struct runtime_gcWork * w) {
    // 0x8063c90
    abort();
    // UNREACHABLE
}

// Address range: 0x8063d20 - 0x8063d6f
void runtime__lb__ptr_workbuf_rb__checknonempty(struct runtime_workbuf * b) {
    // 0x8063d20
    abort();
    // UNREACHABLE
}

// Address range: 0x8063d70 - 0x8063dbf
void runtime__lb__ptr_workbuf_rb__checkempty(struct runtime_workbuf * b) {
    // 0x8063d70
    abort();
    // UNREACHABLE
}

// Address range: 0x8063dc0 - 0x8063f8f
void runtime_getempty(struct runtime_workbuf * a1) {
    // 0x8063dc0
    abort();
    // UNREACHABLE
}

// Address range: 0x8063f90 - 0x8063fdf
void runtime_putempty(struct runtime_workbuf * b) {
    // 0x8063f90
    abort();
    // UNREACHABLE
}

// Address range: 0x8063fe0 - 0x806402f
void runtime_putfull(struct runtime_workbuf * b) {
    // 0x8063fe0
    abort();
    // UNREACHABLE
}

// Address range: 0x8064030 - 0x806408f
void runtime_trygetfull(struct runtime_workbuf * a1) {
    // 0x8064030
    abort();
    // UNREACHABLE
}

// Address range: 0x8064090 - 0x80643cf
void runtime_getfull(struct runtime_workbuf * a1) {
    // 0x8064090
    abort();
    // UNREACHABLE
}

// Address range: 0x80643d0 - 0x806445f
void runtime_handoff(struct runtime_workbuf * b, struct runtime_workbuf * a2) {
    // 0x80643d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8064460 - 0x806450f
void runtime_prepareFreeWorkbufs(void) {
    // 0x8064460
    abort();
    // UNREACHABLE
}

// Address range: 0x8064840 - 0x8064e0f
void runtime__lb__ptr_mheap_rb__init(struct runtime_mheap * h, int32_t spansStart, int32_t spansBytes) {
    // 0x8064840
    abort();
    // UNREACHABLE
}

// Address range: 0x8064e10 - 0x8064e6f
void runtime__lb__ptr_mheap_rb__setArenaUsed(struct runtime_mheap * h, int32_t arena_used, bool racemap) {
    // 0x8064e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8064e70 - 0x8064f1f
void runtime__lb__ptr_mheap_rb__mapSpans(struct runtime_mheap * h, int32_t arena_used) {
    // 0x8064e70
    abort();
    // UNREACHABLE
}

// Address range: 0x80655d0 - 0x806569f
void runtime__lb__ptr_mheap_rb__allocManual(struct runtime_mheap * h, int32_t npage, int64_t * stat, struct runtime_mspan * a4) {
    // 0x80655d0
    abort();
    // UNREACHABLE
}

// Address range: 0x80656a0 - 0x8065a3f
void runtime__lb__ptr_mheap_rb__allocSpanLocked(struct runtime_mheap * h, int32_t npage, int64_t * stat, struct runtime_mspan * a4) {
    // 0x80656a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8065a40 - 0x8065a8f
void runtime__lb__ptr_mheap_rb__allocLarge(struct runtime_mheap * h, int32_t npage, struct runtime_mspan * a3) {
    // 0x8065a40
    abort();
    // UNREACHABLE
}

// Address range: 0x8065a90 - 0x8065d0f
void runtime__lb__ptr_mheap_rb__grow(struct runtime_mheap * h, int32_t npage, bool a3) {
    // 0x8065a90
    abort();
    // UNREACHABLE
}

// Address range: 0x8065d60 - 0x8065e0f
void runtime__lb__ptr_mheap_rb__freeManual(struct runtime_mheap * h, struct runtime_mspan * s, int64_t * stat) {
    // 0x8065d60
    abort();
    // UNREACHABLE
}

// Address range: 0x8065e10 - 0x806632f
void runtime__lb__ptr_mheap_rb__freeSpanLocked(struct runtime_mheap * h, struct runtime_mspan * s, bool acctinuse, bool acctidle, int64_t unusedsince) {
    // 0x8065e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8066900 - 0x8066a6f
void runtime__lb__ptr_mSpanList_rb__remove(struct runtime_mSpanList * list, struct runtime_mspan * span) {
    // 0x8066900
    abort();
    // UNREACHABLE
}

// Address range: 0x8066a70 - 0x8066b5f
void runtime__lb__ptr_mSpanList_rb__insert(struct runtime_mSpanList * list, struct runtime_mspan * span) {
    // 0x8066a70
    abort();
    // UNREACHABLE
}

// Address range: 0x8066c50 - 0x8066cbf
void runtime__lb__ptr_mSpanList_rb__takeAll(struct runtime_mSpanList * list, struct runtime_mSpanList * other) {
    // 0x8066c50
    abort();
    // UNREACHABLE
}

// Address range: 0x80678f0 - 0x806799f
void runtime_newBucket(int32_t typ, int32_t nstk, struct runtime_bucket * a3) {
    // 0x80678f0
    abort();
    // UNREACHABLE
}

// Address range: 0x80679a0 - 0x80679ef
void runtime__lb__ptr_bucket_rb__mp(struct runtime_bucket * b, struct runtime_memRecord * a2) {
    // 0x80679a0
    abort();
    // UNREACHABLE
}

// Address range: 0x80679f0 - 0x8067a4f
void runtime__lb__ptr_bucket_rb__bp(struct runtime_bucket * b, struct runtime_blockRecord * a2) {
    // 0x80679f0
    abort();
    // UNREACHABLE
}

// Address range: 0x8067a50 - 0x8067cef
void runtime_stkbucket(int32_t typ, int32_t size, struct _lsb__rsb_uintptr stk, bool alloc, struct runtime_bucket * a5) {
    // 0x8067a50
    abort();
    // UNREACHABLE
}

// Address range: 0x8067cf0 - 0x8067d4f
void runtime_eqslice(struct _lsb__rsb_uintptr x, struct _lsb__rsb_uintptr y, bool a3) {
    // 0x8067cf0
    abort();
    // UNREACHABLE
}

// Address range: 0x8067d50 - 0x8067dbf
void runtime_mProf_NextCycle(void) {
    // 0x8067d50
    abort();
    // UNREACHABLE
}

// Address range: 0x8067dc0 - 0x8067e1f
void runtime_mProf_Flush(void) {
    // 0x8067dc0
    abort();
    // UNREACHABLE
}

// Address range: 0x8067e20 - 0x8067eef
void runtime_mProf_FlushLocked(void) {
    // 0x8067e20
    abort();
    // UNREACHABLE
}

// Address range: 0x8067ef0 - 0x806804f
void runtime_mProf_Malloc(char * p, int32_t size) {
    // 0x8067ef0
    abort();
    // UNREACHABLE
}

// Address range: 0x80680e0 - 0x806817f
void runtime_blockevent(int64_t cycles, int32_t skip) {
    // 0x80680e0
    abort();
    // UNREACHABLE
}

// Address range: 0x8068180 - 0x806827f
void runtime_blocksampled(int64_t cycles, bool a2) {
    // 0x8068180
    abort();
    // UNREACHABLE
}

// Address range: 0x8068280 - 0x806840f
void runtime_saveblockevent(int64_t cycles, int32_t skip, int32_t which) {
    // 0x8068280
    abort();
    // UNREACHABLE
}

// Address range: 0x8068410 - 0x806851f
void sync_event(int64_t cycles, int32_t skip) {
    // 0x8068410
    abort();
    // UNREACHABLE
}

// Address range: 0x8068520 - 0x806876f
void runtime_tracealloc(char * p, int32_t size, struct runtime__type * typ) {
    // 0x8068520
    abort();
    // UNREACHABLE
}

// Address range: 0x8068ab0 - 0x8068b1f
void runtime_flushmcache(int32_t i) {
    // 0x8068ab0
    abort();
    // UNREACHABLE
}

// Address range: 0x8068c60 - 0x8068d0f
void runtime_mSysStatInc(int64_t * sysStat, uint32_t n) {
    // 0x8068c60
    runtime_internal_atomic_Xadduintptr();
    uint32_t v1;
    if (v1 < n) {
        // 0x8068c87
        runtime_printlock();
        runtime_printstring((struct string){.e0 = (char *)&g21, .e1 = 0});
        runtime_printint((int64_t)(int32_t)v1);
        runtime_printstring((struct string){.e0 = (char *)&g13, .e1 = 0});
        runtime_printint((int64_t)(int32_t)n);
        runtime_printstring((struct string){.e0 = (char *)&g11, .e1 = 0});
        runtime_printunlock();
        runtime_exit();
        // branch -> 0x8068c83
    }
}

// Address range: 0x8068d10 - 0x8068dcf
void runtime_mSysStatDec(int64_t * sysStat, uint32_t n) {
    // 0x8068d10
    runtime_internal_atomic_Xadduintptr();
    int32_t v1;
    if (v1 + n < n) {
        // 0x8068d3e
        runtime_printlock();
        runtime_printstring((struct string){.e0 = "runtime: stat underflow: val runtime: sudog with non-nil cruntime: unknown pc in defer semacquire not on the G stackstring concatenation too longsyntax error scanning booleantoo many open files in systemtraceback has leftover defers locals stack map entries for 227373675443232059478759765625MHeap_AllocLocked - bad npagesSIGPROF: profiling alarm clockSIGUSR1: user-defined signal 1SIGUSR2: user-defined signal 2SIGVTALRM: virtual alarm clockassignment to entry in nil mapcheckdead: inconsistent countsfailed to get system page sizefreedefer with d._panic != nilinappropriate ioctl for deviceinvalid function symbol table\ninvalid pointer found on stackneed padding in bucket (value)protocol wrong type for socketreflect: Len of non-array typerunqputslow: queue is not fullruntime: bad pointer in frame runtime: found in object at *(socket operation on non-socketsync: inconsistent mutex statesync: unlock of unlocked mutex...additional frames elided...\n.lib section in a.out corrupted11368683772161602973937988281255684341886080801486968994140625SIGSEGV: segmentation violationcannot assign requested addresscasgstatus: bad incoming valuescheckmark found unmarked objectentersyscallblock inconsistent fmt: unknown base; can't happeninserting span already in treapinternal error - misuse of itabmalformed time zone informationnon in-use span in unswept listpacer: sweep done at heap size reflect: NumIn of non-func typeresetspinning: not a spinning mruntime: address space conflictruntime: cannot allocate memoryruntime: split stack overflow: 28421709430404007434844970703125SIGFPE: floating-point exceptionSIGTTOU: background write to ttygchelper not running on g0 stacknon-Go code disabled sigaltstacknumerical argument out of domainpanic while printing panic valuereflect.nameFrom: tag too long: reflect: NumOut of non-func typeremovespecial on invalid pointerresource temporarily unavailableruntime: epollcreate failed withruntime: failed MSpanList_Insertruntime: mcall function returnedruntime: newstack called from g=runtime: stack split at bad timeruntime: sudog with non-nil elemruntime: sudog with non-nil nextruntime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        runtime_printint((int64_t)v1);
        runtime_printstring((struct string){.e0 = (char *)&g13, .e1 = 0});
        runtime_printint((int64_t)(int32_t)n);
        runtime_printstring((struct string){.e0 = (char *)&g11, .e1 = 0});
        runtime_printunlock();
        runtime_exit();
        // branch -> 0x8068d3a
    }
}

// Address range: 0x8068e10 - 0x8068e4f
void runtime_netpollinited(bool a1) {
    // 0x8068e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8069430 - 0x806950f
void runtime_netpollready(int32_t * gpp, struct runtime_pollDesc * pd, int32_t mode) {
    // 0x8069430
    abort();
    // UNREACHABLE
}

// Address range: 0x8069780 - 0x806982f
void runtime_netpollunblock(struct runtime_pollDesc * pd, int32_t mode, bool ioready, struct runtime_g * a4) {
    // 0x8069780
    abort();
    // UNREACHABLE
}

// Address range: 0x8069aa0 - 0x8069c9f
void runtime_netpoll(bool block, struct runtime_g * a2) {
    // 0x8069aa0
    abort();
    // UNREACHABLE
}

// Address range: 0x8069ca0 - 0x8069d6f
void runtime_futexsleep(int32_t * addr, int32_t val, int64_t ns) {
    int32_t v1 = 0; // bp-4
    int32_t v2;
    if ((g5 & -256 || (int32_t)(v2 < 0)) != 0) {
        // 0x8069cd2
        runtime_futex();
        return;
    }
    // 0x8069d0a
    v1 = 0;
    int32_t v3;
    runtime_timediv(ns, 0x3b9aca00, &v1, v3);
    runtime_futex();
}

// Address range: 0x8069d70 - 0x8069def
void runtime_futexwakeup(int32_t * addr, int32_t cnt) {
    // 0x8069d70
    runtime_futex();
    int32_t v1;
    if (v1 >= 0) {
        // 0x8069daf
        return;
    }
    // 0x8069db3
    runtime_systemstack();
    *(int32_t *)0x1006 = 0x1006;
}

// Address range: 0x8069df0 - 0x8069ecf
void runtime_getproccount(int32_t a1) {
    // 0x8069df0
    abort();
    // UNREACHABLE
}

// Address range: 0x8069ed0 - 0x806a06f
void runtime_newosproc(struct runtime_m * mp, char * stk) {
    // 0x8069ed0
    abort();
    // UNREACHABLE
}

// Address range: 0x806a070 - 0x806a27f
void runtime_sysargs(int32_t argc, char ** argv) {
    // 0x806a070
    abort();
    // UNREACHABLE
}

// Address range: 0x806a280 - 0x806a35f
void runtime_sysauxv(struct _lsb__rsb_uintptr auxv, int32_t a2) {
    // 0x806a280
    abort();
    // UNREACHABLE
}

// Address range: 0x806a360 - 0x806a38f
void runtime_osinit(void) {
    // 0x806a360
    abort();
    // UNREACHABLE
}

// Address range: 0x806a390 - 0x806a4af
void runtime_getRandomData(struct _lsb__rsb_uint8 r) {
    // 0x806a390
    abort();
    // UNREACHABLE
}

// Address range: 0x806a4b0 - 0x806a4cf
void runtime_goenvs(void) {
    // 0x806a4b0
    abort();
    // UNREACHABLE
}

// Address range: 0x806a4d0 - 0x806a54f
void runtime_mpreinit(struct runtime_m * mp) {
    // 0x806a4d0
    abort();
    // UNREACHABLE
}

// Address range: 0x806a550 - 0x806a59f
void runtime_minit(void) {
    // 0x806a550
    abort();
    // UNREACHABLE
}

// Address range: 0x806a5b0 - 0x806a5df
void runtime_sigprocmask(int32_t how, int32_t (*new)[1], int32_t (*old)[1]) {
    // 0x806a5b0
    runtime_rtsigprocmask();
}

// Address range: 0x806a5e0 - 0x806a6ef
void runtime_setsig(int32_t i, int32_t fn) {
    int32_t v1;
    g7 = &v1;
    g2 = 0;
    function_808fd8b();
    if (fn != 0x807ba40) {
        // 0x806a6e1
        // branch -> 0x806a692
        // 0x806a692
        v1 = fn;
        runtime_rt_sigaction();
        return;
    }
    // 0x806a66c
    int32_t v2; // 0x806a692
    if (*(char *)&runtime_iscgo == 0) {
        // 0x806a6be
        v2 = 0x8090900;
        // branch -> 0x806a692
    } else {
        // 0x806a677
        v2 = 0x8090950;
        // branch -> 0x806a692
    }
    // 0x806a692
    v1 = v2;
    runtime_rt_sigaction();
}

// Address range: 0x806a6f0 - 0x806a76f
void runtime_setsigstack(int32_t i) {
    int32_t v1;
    g7 = &v1;
    g2 = 0;
    function_808fd8b();
    runtime_rt_sigaction();
    int32_t v2;
    if (v2 != 0x8000000) {
        // 0x806a72e
        return;
    }
    // 0x806a732
    runtime_rt_sigaction();
}

// Address range: 0x806a770 - 0x806a7cf
void runtime_getsig(int32_t i, int32_t a2) {
    int32_t v1;
    g7 = &v1;
    g2 = 0;
    function_808fd8b();
    runtime_rt_sigaction();
    int32_t v2;
    if (v2 == 0) {
        // 0x806a7aa
        return;
    }
    // 0x806a7b6
    runtime_throw((struct string){.e0 = (char *)&g20, .e1 = 0});
}

// Address range: 0x806a7d0 - 0x806a85f
void runtime_panicCheckMalloc(struct runtime_iface err) {
    // 0x806a7d0
    abort();
    // UNREACHABLE
}

// Address range: 0x806a860 - 0x806a8bf
void runtime_panicindex(void) {
    // 0x806a860
    abort();
    // UNREACHABLE
}

// Address range: 0x806a8c0 - 0x806a91f
void runtime_panicslice(void) {
    // 0x806a8c0
    abort();
    // UNREACHABLE
}

// Address range: 0x806a920 - 0x806a97f
void runtime_panicdivide(void) {
    // 0x806a920
    abort();
    // UNREACHABLE
}

// Address range: 0x806aae0 - 0x806ac0f
void runtime_deferproc(int32_t siz, struct runtime_funcval * fn) {
    // 0x806aae0
    abort();
    // UNREACHABLE
}

// Address range: 0x806ac10 - 0x806ae3f
void runtime_testdefersizes(void) {
    // 0x806ac10
    abort();
    // UNREACHABLE
}

// Address range: 0x806aeb0 - 0x806b08f
void runtime_newdefer(uint32_t siz, struct runtime__defer * a2) {
    // 0x806aeb0
    if (siz > 4) {
        // 0x806b06e
        // branch -> 0x806aeca
    }
    // 0x806aeca
    abort();
    // UNREACHABLE
}

// Address range: 0x806b090 - 0x806b24f
void runtime_freedefer(struct runtime__defer * d) {
    int32_t v1 = (int32_t)d; // 0x806b093_0
    int32_t v2 = v1; // 0x806b0a2
    if (*(int32_t *)(v1 + 20) != 0) {
        // 0x806b242
        runtime_freedeferpanic();
        v2 = (int32_t)d;
        // branch -> 0x806b0a2
    }
    int32_t v3 = v2; // 0x806b0ad
    if (*(int32_t *)(v2 + 16) != 0) {
        // 0x806b234
        runtime_freedeferfn();
        v3 = (int32_t)d;
        // branch -> 0x806b0ad
    }
    uint32_t v4 = *(int32_t *)v3; // 0x806b0ad
    int32_t v5;
    if (v4 > 4) {
        // 0x806b229
        v5 = (v4 + 11) / 16;
        // branch -> 0x806b0ba
    } else {
        // 0x806b0b8
        v5 = 0;
        // branch -> 0x806b0ba
    }
    // 0x806b0ba
    if (v5 >= 5) {
        // 0x806b146
        return;
    }
    // 0x806b0c3
    abort();
    // UNREACHABLE
}

// Address range: 0x806b250 - 0x806b28f
void runtime_freedeferpanic(void) {
    // 0x806b250
    abort();
    // UNREACHABLE
}

// Address range: 0x806b290 - 0x806b2cf
void runtime_freedeferfn(void) {
    // 0x806b290
    abort();
    // UNREACHABLE
}

// Address range: 0x806b2d0 - 0x806b3ef
void runtime_deferreturn(int32_t arg0) {
    // 0x806b2d0
    abort();
    // UNREACHABLE
}

// Address range: 0x806b3f0 - 0x806b59f
void runtime_preprintpanics(struct runtime__panic * p) {
    // 0x806b3f0
    abort();
    // UNREACHABLE
}

// Address range: 0x806b5a0 - 0x806b68f
void runtime_printpanics(struct runtime__panic * p) {
    // 0x806b5a0
    abort();
    // UNREACHABLE
}

// Address range: 0x806b690 - 0x806bcdf
void runtime_gopanic(struct runtime_eface e) {
    // 0x806b690
    abort();
    // UNREACHABLE
}

// Address range: 0x806bce0 - 0x806bcef
void runtime_getargp(int32_t x, int32_t a2) {
    // 0x806bce0
    return;
}

// Address range: 0x806bd40 - 0x806bd5f
void runtime_startpanic(void) {
    // 0x806bd40
    runtime_systemstack();
}

// Address range: 0x806bd60 - 0x806bdbf
void runtime_dopanic(int32_t unused) {
    // 0x806bd60
    runtime_getcallerpc();
    abort();
    // UNREACHABLE
}

// Address range: 0x806bdc0 - 0x806be4f
void runtime_throw(struct string s) {
    struct string v1; // 0x806bded
    // 0x806bdc0
    runtime_printlock();
    runtime_printstring((struct string){.e0 = (char *)&g17, .e1 = 0});
    v1 = (struct string){
        .e0 = NULL,
        .e1 = 0
    };
    v1.e0 = s.e0;
    runtime_printstring(v1);
    runtime_printstring((struct string){.e0 = (char *)&g11, .e1 = 0});
    runtime_printunlock();
    abort();
    // UNREACHABLE
}

// Address range: 0x806c550 - 0x806c64f
void runtime_recordForPanic(struct _lsb__rsb_uint8 b) {
    // 0x806c550
    abort();
    // UNREACHABLE
}

// Address range: 0x806c650 - 0x806c6bf
void runtime_printlock(void) {
    // 0x806c650
    abort();
    // UNREACHABLE
}

// Address range: 0x806c6c0 - 0x806c71f
void runtime_printunlock(void) {
    // 0x806c6c0
    abort();
    // UNREACHABLE
}

// Address range: 0x806c720 - 0x806c82f
void runtime_gwrite(struct _lsb__rsb_uint8 b) {
    // 0x806c720
    abort();
    // UNREACHABLE
}

// Address range: 0x806c830 - 0x806c86f
void runtime_printsp(void) {
    // 0x806c830
    abort();
    // UNREACHABLE
}

// Address range: 0x806c870 - 0x806c8af
void runtime_printnl(void) {
    // 0x806c870
    abort();
    // UNREACHABLE
}

// Address range: 0x806c8b0 - 0x806c91f
void runtime_printbool(bool v) {
    // 0x806c8b0
    abort();
    // UNREACHABLE
}

// Address range: 0x806c920 - 0x806cbaf
void runtime_printfloat(float64_t v) {
    // 0x806c920
    abort();
    // UNREACHABLE
}

// Address range: 0x806cbb0 - 0x806cc2f
void runtime_printcomplex(float80_t c) {
    // 0x806cbb0
    abort();
    // UNREACHABLE
}

// Address range: 0x806cc30 - 0x806cd5f
void runtime_printuint(int64_t v) {
    // 0x806cc30
    abort();
    // UNREACHABLE
}

// Address range: 0x806cd60 - 0x806cdef
void runtime_printint(int64_t v) {
    // 0x806cd60
    abort();
    // UNREACHABLE
}

// Address range: 0x806cdf0 - 0x806cecf
void runtime_printhex(int64_t v) {
    // 0x806cdf0
    abort();
    // UNREACHABLE
}

// Address range: 0x806ced0 - 0x806cf0f
void runtime_printpointer(char * p) {
    // 0x806ced0
    abort();
    // UNREACHABLE
}

// Address range: 0x806cf10 - 0x806cf8f
void runtime_printstring(struct string s) {
    // 0x806cf10
    abort();
    // UNREACHABLE
}

// Address range: 0x806cf90 - 0x806d04f
void runtime_printslice(struct _lsb__rsb_uint8 s) {
    // 0x806cf90
    abort();
    // UNREACHABLE
}

// Address range: 0x806d050 - 0x806d0df
void runtime_printeface(struct runtime_eface e) {
    // 0x806d050
    abort();
    // UNREACHABLE
}

// Address range: 0x806d620 - 0x806d63f
void runtime_Gosched(void) {
    // 0x806d620
    runtime_mcall();
}

// Address range: 0x806d640 - 0x806d7bf
void runtime_gopark(void (*unlockf)(struct runtime_g *, char *, bool *), char * lock, struct string reason, char traceEv, int32_t traceskip) {
    // 0x806d640
    abort();
    // UNREACHABLE
}

// Address range: 0x806d7c0 - 0x806d81f
void runtime_goparkunlock(struct runtime_mutex * lock, struct string reason, char traceEv, int32_t traceskip) {
    // 0x806d7c0
    abort();
    // UNREACHABLE
}

// Address range: 0x806d820 - 0x806d86f
void runtime_goready(struct runtime_g * gp, int32_t traceskip) {
    // 0x806d820
    abort();
    // UNREACHABLE
}

// Address range: 0x806d870 - 0x806dbff
void runtime_acquireSudog(struct runtime_sudog * a1) {
    // 0x806d870
    abort();
    // UNREACHABLE
}

// Address range: 0x806dc00 - 0x806dfbf
void runtime_releaseSudog(struct runtime_sudog * s) {
    int32_t v1 = (int32_t)s; // 0x806dc03_0
    if (*(int32_t *)(v1 + 16) == 0) {
        // 0x806dc12
        if (*(int32_t *)(v1 + 4) == 0) {
            // 0x806dc1d
            if (*(int32_t *)(v1 + 8) == 0) {
                // 0x806dc28
                if (*(int32_t *)(v1 + 12) == 0) {
                    // 0x806dc33
                    if (*(int32_t *)(v1 + 44) == 0) {
                        // 0x806dc3e
                        if (*(int32_t *)(v1 + 52) == 0) {
                            // 0x806dc49
                            abort();
                            // UNREACHABLE
                        }
                        // 0x806df24
                        runtime_throw((struct string){.e0 = "runtime: sudog with non-nil cruntime: unknown pc in defer semacquire not on the G stackstring concatenation too longsyntax error scanning booleantoo many open files in systemtraceback has leftover defers locals stack map entries for 227373675443232059478759765625MHeap_AllocLocked - bad npagesSIGPROF: profiling alarm clockSIGUSR1: user-defined signal 1SIGUSR2: user-defined signal 2SIGVTALRM: virtual alarm clockassignment to entry in nil mapcheckdead: inconsistent countsfailed to get system page sizefreedefer with d._panic != nilinappropriate ioctl for deviceinvalid function symbol table\ninvalid pointer found on stackneed padding in bucket (value)protocol wrong type for socketreflect: Len of non-array typerunqputslow: queue is not fullruntime: bad pointer in frame runtime: found in object at *(socket operation on non-socketsync: inconsistent mutex statesync: unlock of unlocked mutex...additional frames elided...\n.lib section in a.out corrupted11368683772161602973937988281255684341886080801486968994140625SIGSEGV: segmentation violationcannot assign requested addresscasgstatus: bad incoming valuescheckmark found unmarked objectentersyscallblock inconsistent fmt: unknown base; can't happeninserting span already in treapinternal error - misuse of itabmalformed time zone informationnon in-use span in unswept listpacer: sweep done at heap size reflect: NumIn of non-func typeresetspinning: not a spinning mruntime: address space conflictruntime: cannot allocate memoryruntime: split stack overflow: 28421709430404007434844970703125SIGFPE: floating-point exceptionSIGTTOU: background write to ttygchelper not running on g0 stacknon-Go code disabled sigaltstacknumerical argument out of domainpanic while printing panic valuereflect.nameFrom: tag too long: reflect: NumOut of non-func typeremovespecial on invalid pointerresource temporarily unavailableruntime: epollcreate failed withruntime: failed MSpanList_Insertruntime: mcall function returnedruntime: newstack called from g=runtime: stack split at bad timeruntime: sudog with non-nil elemruntime: sudog with non-nil nextruntime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
                        // branch -> 0x806df3c
                    }
                    // 0x806df3c
                    runtime_throw((struct string){.e0 = "runtime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
                    // branch -> 0x806df54
                }
                // 0x806df54
                runtime_throw((struct string){.e0 = "runtime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
                // branch -> 0x806df6c
            }
            // 0x806df6c
            runtime_throw((struct string){.e0 = "runtime: sudog with non-nil nextruntime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
            // branch -> 0x806df84
        }
        // 0x806df84
        runtime_throw((struct string){.e0 = "runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
        // branch -> 0x806df9c
    }
    // 0x806df9c
    runtime_throw((struct string){.e0 = "runtime: sudog with non-nil elemruntime: sudog with non-nil nextruntime: sudog with non-nil prevscanstack: goroutine not stoppedsoftware caused connection abortstackmapdata: index out of rangesweep increased allocation countuse of closed network connection of method on nil interface value142108547152020037174224853515625710542735760100185871124267578125SIGCHLD: child status has changedSIGTTIN: background read from ttySIGXFSZ: file size limit exceededconcurrent map read and map writefindrunnable: negative nmspinningfreeing stack not in a stack spanheapBitsSetType: unexpected shiftreflect.nameFrom: name too long: reflect: ChanDir of non-chan typereflect: Field index out of rangereflect: Field of non-struct typereflect: array index out of rangereflect: slice index out of rangeruntime: castogscanstatus oldval=runtime: goroutine stack exceeds runtime: memory allocated by OS (runtime: name offset out of rangeruntime: text offset out of rangeruntime: type offset out of rangestackalloc not on scheduler stackstoplockedm: inconsistent lockingtoo many levels of symbolic linkstreap insert finds a broken treaptreap node with nil spanKey foundwaiting for unsupported file type3552713678800500929355621337890625MHeap_AllocLocked - MSpan not freeMSpan_EnsureSwept: m is not lockedOther_Default_Ignorable_Code_PointSIGURG: urgent condition on socketforEachP: sched.safePointWait != 0heapBitsForSpan: base out of rangereflect.FuncOf: too many argumentsreflect: Field index out of boundsreflect: Method index out of rangereflect: string index out of rangeruntime.SetFinalizer: cannot pass runtime: g is running but p is notruntime: unexpected return pc for schedule: spinning with local workspan and treap sizes do not match?too many references: cannot splice1776356839400250464677810668945312588817841970012523233890533447265625MHeap_FreeSpanLocked - invalid freefindfunc: bad findfunctab entry idxfindrunnable: netpoll with spinninggreyobject: obj not pointer-alignedmisrounded allocation in mallocinitnetwork dropped connection on resetpersistentalloc: align is too largepidleput: P has non-empty run queueruntime: close polldesc w/o unblocktraceback did not unwind completelytransport endpoint is not connected0123456789abcdefghijklmnopqrstuvwxyz444089209850062616169452667236328125Go pointer stored into non-Go memoryMStats vs MemStatsType size mismatchaccessing a corrupted shared librarykey size not a multiple of key alignmarkrootSpans during second markrootreflect: IsVariadic of non-func typereflect: NumField of non-struct typereflect: funcLayout of non-func typeruntime: bad notifyList size - sync=runtime: failed MSpanList_InsertBackruntime: invalid pc-encoded table f=runtime: invalid typeBitsBulkBarrierruntime: mcall called on m->g0 stackruntime: sudog with non-nil waitlinkruntime: unblock on closing polldescruntime: wrong goroutine in newstacksignal arrived during cgo execution\nsyntax error scanning complex numberuncaching span but s.allocCount == 0) is smaller than minimum page size (2220446049250313080847263336181640625_cgo_notify_runtime_init_done missingall goroutines are asleep - deadlock!cannot exec a shared library directlyoperation not possible due to RF-killreflect.Value.Bytes of non-byte slicereflect.Value.Bytes of non-rune slicereflect: Bits of non-arithmetic Type runtime: address space conflict: map(runtime: allocation size out of rangesetprofilebucket: profile already setstartTheWorld: inconsistent mp->nextpvalue too large for defined data type1110223024625156540423631668090820312555511151231257827021181583404541015625arg size to reflect.call more than 1GBcan not access a needed shared libraryconcurrent map iteration and map writegcBgMarkWorker: blackening not enabledmakechan: invalid channel element typeruntime: blocked read on free polldescruntime: function symbol table header:runtime: sudog with non-nil selectdone277555756156289135105907917022705078125MSpan_Sweep: bad span state after sweepmisrounded allocation in MHeap_SysAllocreceived on thread with no signal stackreflect: FieldByName of non-struct typeruntime: blocked write on free polldescruntime: casfrom_Gscanstatus failed gp=runtime: typeBitsBulkBarrier with type span and treap node npages do not matchstack growth not allowed in system calltransport endpoint is already connected13877787807814456755295395851135253906256938893903907228377647697925567626953125address family not supported by protocolbulkBarrierPreWrite: unaligned argumentscannot free workbufs when work.full != 0deferproc: d.panic != nil after newdeferreceived but handler not on signal stackrefill of span with free space remainingreflect.Value.SetBytes of non-byte slicereflect.Value.setRunes of non-rune slicereflect: FieldByIndex of non-struct typeruntime.SetFinalizer: first argument is runtime: out of memory: cannot allocate value size not a multiple of value align34694469519536141888238489627838134765625MHeap_FreeSpanLocked - invalid span stateMHeap_FreeSpanLocked - invalid stack freecan't call pointer on a non-pointer ValuegcSweep being done but phase is not GCoffruntime.SetFinalizer: second argument is runtime.makemap: unsupported map key typeruntime: blocked read on closing polldescruntime: typeBitsBulkBarrier without typesetCheckmarked and isCheckmarked disagreestopTheWorld: not stopped (stopwait != 0)strconv: illegal AppendInt/FormatInt base173472347597680709441192448139190673828125867361737988403547205962240695953369140625acquireSudog: found s.elem != nil in cachepersistentalloc: align is not a power of 2runtime: blocked write on closing polldescruntime: heapBitsSetTypeGCProg: total bitssync/atomic: store of nil value into Valueunexpected signal during runtime executiongcBgMarkWorker: unexpected gcMarkWorkerModegentraceback before goexitPC initializationheapBitsSetTypeGCProg: unexpected bit countinterrupted system call should be restartedmultiple Read calls return no data or errorreflect: FieldByNameFunc of non-struct typereflect: nil type passed to Type.Implementsruntime.SetFinalizer: finalizer already setruntime.SetFinalizer: first argument is nilruntime: casfrom_Gscanstatus bad oldval gp=runtime: releaseSudog with non-nil gp.paramunknown runnable goroutine during bootstrap using value obtained using unexported fieldgcmarknewobject called while doing checkmarkreflect: funcLayout with interface receiver runtime: lfstack.push invalid packing: node=systemstack called from unexpected goroutinecannot send after transport endpoint shutdownexitsyscall: syscall frame is no longer validheapBitsSetType: called with non-pointer typereflect: internal error: invalid method indexreflect: nil type passed to Type.AssignableToruntime: failed MSpanList_Remove span.npages=panicwrap: unexpected string after type name: reflect.Value.Slice: slice index out of boundsreflect: nil type passed to Type.ConvertibleToruntime: failed to create new OS thread (have runtime: name offset base pointer out of rangeruntime: panic before malloc heap initialized\nruntime: text offset base pointer out of rangeruntime: type offset base pointer out of rangestopTheWorld: not stopped (status != _Pgcstop)P has cached GC work at end of mark terminationattempting to link in too many shared librariesP has unflushed stats at end of mark terminationruntime: cannot map pages in arena address spacestrconv: illegal AppendFloat/FormatFloat bitSizecasgstatus: waiting for Gwaiting but is Grunnableinvalid memory address or nil pointer dereferenceinvalid or incomplete multibyte or wide characterpanicwrap: unexpected string after package name: reflect.Value.Slice: slice of unaddressable arrays.allocCount != s.nelems && freeIndex == s.nelemsstrconv: internal error, rest != 0 but needed > 0strconv: num > den<<shift in adjustLastDigitFixedwritebarrierptr_prewrite1 called with mp.p == nilattempt to execute system stack code on user stackmallocgc called with gcphase == _GCmarkterminationrecursive call during initialization - linker skewruntime: cannot reserve arena virtual address spacecasfrom_Gscanstatus: gp->status is not in scan statefunction symbol table not sorted by program counter:runtime.SetFinalizer: pointer not in allocated blockruntime: use of FixAlloc_Alloc before FixAlloc_Init\nreflect.Value.Slice: string slice index out of boundsreflect: non-interface type passed to Type.Implements\tgoroutine running on other thread; stack unavailable\ngcControllerState.findRunnable: blackening not enabledno goroutines (main called runtime.Goexit) - deadlock!reflect.FuncOf does not support more than 50 argumentscasfrom_Gscanstatus:top gp->status is not in scan stategentraceback callback cannot be used with non-zero skipnewproc: function arguments too large for new goroutinereflect.FuncOf: last arg of variadic func must be slicereflect: internal error: invalid use of makeMethodValuein gcMark expecting to see gcphase as _GCmarkterminationgentraceback cannot trace user goroutine on its own stacknon-Go code set up signal handler without SA_ONSTACK flagruntime:stoplockedm: g is not Grunnable or Gscanrunnable\nruntime: mmap: too much locked memory (check 'ulimit -l').\nsync/atomic: store of inconsistently typed value into Valueruntime: may need to increase max user processes (ulimit -u)reflect: creating a name with a package path is not supportedfound bad pointer in Go heap (incorrect use of unsafe or cgo?)runtime: internal error: misuse of lockOSThread/unlockOSThreadruntime.SetFinalizer: pointer not at beginning of allocated blockstrconv: internal error: extFloat.FixedDecimal called with n == 0runtime:greyobject: checkmarks finds unexpected unmarked object obj=reflect.Value.Interface: cannot return value obtained from unexported field or method00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", .e1 = 0});
}

// Address range: 0x806dfe0 - 0x806e01f
void runtime_badmcall(void (*fn)(struct runtime_g *)) {
    // 0x806dfe0
    abort();
    // UNREACHABLE
}

// Address range: 0x806e020 - 0x806e05f
void runtime_badmcall2(void (*fn)(struct runtime_g *)) {
    // 0x806e020
    abort();
    // UNREACHABLE
}

// Address range: 0x806e060 - 0x806e09f
void runtime_badreflectcall(void) {
    // 0x806e060
    abort();
    // UNREACHABLE
}

// Address range: 0x806e0a0 - 0x806e0cf
void runtime_badmorestackg0(void) {
    // 0x806e0a0
    runtime_write();
}

// Address range: 0x806e0d0 - 0x806e0ff
void runtime_badmorestackgsignal(void) {
    // 0x806e0d0
    runtime_write();
}

// Address range: 0x806e100 - 0x806e11f
void runtime_badctxt(void) {
    // 0x806e100
    runtime_throw((struct string){.e0 = (char *)&g14, .e1 = 0});
}

// Address range: 0x806e120 - 0x806e25f
void runtime_allgadd(struct runtime_g * gp) {
    // 0x806e120
    abort();
    // UNREACHABLE
}

// Address range: 0x806e260 - 0x806e3ef
void runtime_schedinit(void) {
    // 0x806e260
    abort();
    // UNREACHABLE
}

// Address range: 0x806e3f0 - 0x806e59f
void runtime_dumpgstatus(struct runtime_g * gp) {
    // 0x806e3f0
    abort();
    // UNREACHABLE
}

// Address range: 0x806e5a0 - 0x806e63f
void runtime_checkmcount(void) {
    // 0x806e5a0
    abort();
    // UNREACHABLE
}

// Address range: 0x806e640 - 0x806e7cf
void runtime_mcommoninit(struct runtime_m * mp) {
    // 0x806e640
    abort();
    // UNREACHABLE
}

// Address range: 0x806e7d0 - 0x806e91f
void runtime_ready(struct runtime_g * gp, int32_t traceskip, bool next) {
    // 0x806e7d0
    abort();
    // UNREACHABLE
}

// Address range: 0x806e920 - 0x806e99f
void runtime_gcprocs(int32_t a1) {
    // 0x806e920
    abort();
    // UNREACHABLE
}

// Address range: 0x806ec00 - 0x806ec1f
void runtime_readgstatus(struct runtime_g * gp, int32_t a2) {
    // 0x806ec00
    int32_t v1;
    runtime_internal_atomic_Load((int32_t *)((int32_t)gp + 72), v1);
}

// Address range: 0x806ec20 - 0x806ee0f
void runtime_casfrom_Gscanstatus(struct runtime_g * gp, int32_t oldval, int32_t newval) {
    // 0x806ec20
    abort();
    // UNREACHABLE
}

// Address range: 0x806ee10 - 0x806eeff
void runtime_castogscanstatus(struct runtime_g * gp, int32_t oldval, int32_t newval, bool a4) {
    // 0x806ee10
    abort();
    // UNREACHABLE
}

// Address range: 0x806ef00 - 0x806f19f
void runtime_casgstatus(struct runtime_g * gp, int32_t oldval, int32_t newval) {
    if (oldval == 0x1000) {
        // 0x806f0c4
        if (newval == 0x1000) {
            // 0x806f0d4
            // branch -> 0x806ef34
        }
    }
    // 0x806ef34
    runtime_systemstack();
    int32_t v1 = (int32_t)gp;
    uint32_t v2;
    int64_t v3; // bp-48
    int32_t v4; // 0x806f022
    int32_t v5; // 0x806ef99
    int32_t v6; // 0x806ef9d
    int32_t v7; // 0x806efa1
    if (oldval == 2) {
        // 0x806ef41
        if (*(char *)(v1 + 112) != 0) {
            // 0x806f0e1
            runtime_printlock();
            runtime_printstring((struct string){.e0 = (char *)&g18, .e1 = 0});
            runtime_printhex(2);
            runtime_printstring((struct string){.e0 = (char *)&g12, .e1 = 0});
            runtime_printhex((int64_t)newval);
            runtime_printstring((struct string){.e0 = (char *)&g16, .e1 = 0});
            runtime_printhex((int64_t)*(int32_t *)(v1 + 72));
            runtime_printstring((struct string){.e0 = (char *)&g19, .e1 = 0});
            runtime_printunlock();
            runtime_throw((struct string){.e0 = (char *)&g15, .e1 = 0});
            return;
        }
        // 0x806ef51
        v4 = oldval & -256;
        int32_t v8 = v1; // 0x806efa7
        v7 = 0;
        v6 = 0;
        v5 = 0;
        // branch -> 0x806ef99
        while (true) {
            // 0x806ef99
            v3 = v8 + 72;
            runtime_internal_atomic_Cas();
            if (v2 % 256 != 0) {
                // 0x806f0a6
                if (newval != 2) {
                    // 0x806f0b7
                    return;
                }
                // 0x806f0af
                *(char *)((int32_t)gp + 112) = 0;
                // branch -> 0x806f0b7
                // 0x806f0b7
                return;
            }
          lab_0x806efcb:
            // 0x806efcb
            if (oldval == 4) {
                // 0x806efd8
                if (*(int32_t *)((int32_t)gp + 72) == 1) {
                    // 0x806f082
                    v3 = &g22;
                    runtime_systemstack();
                    // branch -> 0x806efe8
                }
            }
            int32_t v9 = v6;
            int32_t v10 = v7;
            if (v5 == 0) {
                // 0x806f067
                runtime_nanotime();
                uint32_t v11 = (int32_t)v3;
                v9 = (int32_t)(v11 > 0xffffec77) + oldval;
                v10 = v11 + 0x1388;
                // branch -> 0x806eff8
            }
            // 0x806eff8
            runtime_nanotime();
            uint32_t v12 = (int32_t)v3;
            int32_t v13 = oldval - v9; // 0x806f010
            int32_t v14; // 0x806ef95
            int32_t v15; // 0x806efa532
            int32_t v16;
            if (((int32_t)(v13 < 0 ^ ((v13 ^ oldval) & (v9 ^ oldval)) < 0) || v4 || ((int32_t)(v12 < v10) || v12 & -256) && (g4 & -256 || (int32_t)(v9 == oldval))) == 0) {
                // 0x806f03f
                runtime_osyield();
                runtime_nanotime();
                uint32_t v17 = (int32_t)v3;
                v14 = (int32_t)(v17 > 0xfffff63b) + oldval;
                v16 = v17 + 2500;
                v15 = (int32_t)gp;
                // branch -> 0x806ef8e
            } else {
                int32_t v18 = (int32_t)gp; // bp+063
                int32_t v19 = 0; // 0x806ef5962
                // branch -> 0x806ef7f
                int32_t v20; // 0x806ef7f_0
                while (true) {
                    // 0x806ef7f
                    if (*(int32_t *)(v18 + 72) != oldval) {
                        // 0x806ef59
                        runtime_procyield();
                        int32_t v21 = v19 + 1; // 0x806ef6d
                        v20 = (int32_t)gp;
                        if (!((v19 < 9 ^ (8 - v19 & v21) < 0))) {
                            // break -> 0x806f032
                            break;
                        }
                        v18 = v20;
                        v19 = v21;
                        // continue -> 0x806ef7f
                        continue;
                    }
                }
                // 0x806f032
                v14 = v9;
                v16 = v10;
                v15 = v20;
                // branch -> 0x806ef8e
            }
            // 0x806ef8e
            v8 = v15;
            v7 = v16;
            v6 = v14;
            v5++;
            // branch -> 0x806ef99
        }
    }
    // 0x806ef51
    v4 = oldval & -256;
    v7 = 0;
    v6 = 0;
    v5 = 0;
    // branch -> 0x806ef99
    while (true) {
        // 0x806ef99
        v3 = v1 + 72;
        runtime_internal_atomic_Cas();
        if (v2 % 256 == 0) {
            goto lab_0x806efcb;
        }
        // 0x806f0a6
        if (newval != 2) {
            // 0x806f0b7
            return;
        }
        // 0x806f0af
        *(char *)((int32_t)gp + 112) = 0;
        // branch -> 0x806f0b7
        // 0x806f0b7
        return;
    }
}

// Address range: 0x806fa80 - 0x806fadf
void runtime_mstart(void) {
    // 0x806fa80
    abort();
    // UNREACHABLE
}

// Address range: 0x806fae0 - 0x806fc0f
void runtime_mstart1(void) {
    // 0x806fae0
    abort();
    // UNREACHABLE
}

// Address range: 0x806ffe0 - 0x807009f
void runtime_runSafePointFn(void) {
    // 0x806ffe0
    abort();
    // UNREACHABLE
}

// Address range: 0x80700a0 - 0x807023f
void runtime_allocm(struct runtime_p * _p_, void (*fn)(), struct runtime_m * a3) {
    // 0x80700a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8070370 - 0x80703ff
void runtime_newextram(void) {
    // 0x8070370
    abort();
    // UNREACHABLE
}

// Address range: 0x8070400 - 0x807060f
void runtime_oneNewExtraM(void) {
    // 0x8070400
    abort();
    // UNREACHABLE
}

// Address range: 0x80706f0 - 0x80707bf
void runtime_lockextra(bool nilokay, struct runtime_m * a2) {
    int32_t v1 = 0; // 0x80706f519
    // branch -> 0x80706f5
    while (true) {
        uint32_t v2 = 0x1000000 * v1 / 0x1000000; // bp+027
        runtime_internal_atomic_Loaduintptr();
        int32_t v3;
        int32_t v4;
        int32_t v5;
        if (v4 == 1) {
            // 0x807079c
            runtime_osyield();
            v5 = v2 % 256;
            v3 = 1;
            // branch -> 0x80706f5
        } else {
            // 0x8070714
            // branch -> 0x8070714
            while (true) {
                // 0x8070714
                if (v4 == 0) {
                    // 0x807071c
                    if (!nilokay) {
                        int32_t v6 = 0;
                        if (v2 % 256 == 0) {
                            // 0x8070741
                            runtime_internal_atomic_Xadd();
                            v6 = 1;
                            // branch -> 0x807072e
                        }
                        // 0x807072e
                        runtime_usleep();
                        v5 = 1;
                        v3 = v6;
                        // branch -> 0x80706f5
                        // 0x80706f5
                        // branch -> 0x80706f5
                        break;
                    }
                }
                // 0x8070759
                runtime_internal_atomic_Casuintptr();
                uint32_t v7;
                if (v7 % 256 != 0) {
                    // 0x8070790
                    return;
                }
                // 0x8070778
                runtime_osyield();
                runtime_internal_atomic_Loaduintptr();
                // branch -> 0x8070714
            }
        }
        // 0x80706f5
        v1 = v5;
        v4 = v3;
        // branch -> 0x80706f5
    }
}

// Address range: 0x80707c0 - 0x80707ef
void runtime_unlockextra(struct runtime_m * mp) {
    // 0x80707c0
    runtime_internal_atomic_Storeuintptr();
}

// Address range: 0x80707f0 - 0x807093f
void runtime_newm(void (*fn)(), struct runtime_p * _p_) {
    // 0x80707f0
    abort();
    // UNREACHABLE
}

// Address range: 0x8070940 - 0x8070a9f
void runtime_stopm(void) {
    // 0x8070940
    abort();
    // UNREACHABLE
}

// Address range: 0x8070ae0 - 0x8070caf
void runtime_startm(struct runtime_p * _p_, bool spinning) {
    // 0x8070ae0
    abort();
    // UNREACHABLE
}

// Address range: 0x8070cb0 - 0x8070f3f
void runtime_handoffp(struct runtime_p * _p_) {
    // 0x8070cb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8070f40 - 0x8070f9f
void runtime_wakep(void) {
    // 0x8070f40
    abort();
    // UNREACHABLE
}

// Address range: 0x8070fa0 - 0x80710ef
void runtime_stoplockedm(void) {
    // 0x8070fa0
    abort();
    // UNREACHABLE
}

// Address range: 0x80710f0 - 0x80711af
void runtime_startlockedm(struct runtime_g * gp) {
    // 0x80710f0
    abort();
    // UNREACHABLE
}

// Address range: 0x80711b0 - 0x80712bf
void runtime_gcstopm(void) {
    // 0x80711b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80712c0 - 0x807141f
void runtime_execute(struct runtime_g * gp, bool inheritTime) {
    // 0x80712c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8071420 - 0x8071d4f
void runtime_findrunnable(struct runtime_g * gp, bool inheritTime) {
    // 0x8071420
    abort();
    // UNREACHABLE
}

// Address range: 0x8071d50 - 0x8071e2f
void runtime_pollWork(bool a1) {
    // 0x8071d50
    abort();
    // UNREACHABLE
}

// Address range: 0x8071e30 - 0x8071eef
void runtime_resetspinning(void) {
    // 0x8071e30
    abort();
    // UNREACHABLE
}

// Address range: 0x8071ef0 - 0x807203f
void runtime_injectglist(struct runtime_g * glist) {
    // 0x8071ef0
    abort();
    // UNREACHABLE
}

// Address range: 0x8072040 - 0x807230f
void runtime_schedule(void) {
    // 0x8072040
    abort();
    // UNREACHABLE
}

// Address range: 0x8072520 - 0x807263f
void runtime_goschedImpl(struct runtime_g * gp) {
    // 0x8072520
    abort();
    // UNREACHABLE
}

// Address range: 0x8072680 - 0x80726bf
void runtime_gopreempt_m(struct runtime_g * gp) {
    // 0x8072680
    abort();
    // UNREACHABLE
}

// Address range: 0x8072ac0 - 0x8072aff
void runtime_save(int32_t pc, int32_t sp) {
    // 0x8072ac0
    abort();
    // UNREACHABLE
}

// Address range: 0x8072ea0 - 0x807301f
void runtime_entersyscallblock(int32_t dummy) {
    // 0x8072ea0
    abort();
    // UNREACHABLE
}

// Address range: 0x8073080 - 0x807327f
void runtime_exitsyscall(int32_t dummy) {
    // 0x8073080
    abort();
    // UNREACHABLE
}

// Address range: 0x8073280 - 0x807337f
void runtime_exitsyscallfast(bool a1) {
    // 0x8073280
    abort();
    // UNREACHABLE
}

// Address range: 0x8073380 - 0x807340f
void runtime_exitsyscallfast_reacquired(void) {
    // 0x8073380
    abort();
    // UNREACHABLE
}

// Address range: 0x8073670 - 0x80736ff
void runtime_malg(int32_t stacksize, struct runtime_g * a2) {
    // 0x8073670
    abort();
    // UNREACHABLE
}

// Address range: 0x8073700 - 0x807376f
void runtime_newproc(int32_t siz, struct runtime_funcval * fn) {
    runtime_getcallerpc();
    int32_t v1;
    g7 = &v1;
    g2 = 0;
    function_808fd8b();
    v1 = (int32_t)runtime_newproc_func1;
    runtime_systemstack();
}

// Address range: 0x80740b0 - 0x80741df
void runtime_gfpurge(struct runtime_p * _p_) {
    // 0x80740b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8074880 - 0x807502f
void runtime_procresize(int32_t nprocs, struct runtime_p * a2) {
    // 0x8074880
    abort();
    // UNREACHABLE
}

// Address range: 0x8075030 - 0x807508f
void runtime_acquirep(struct runtime_p * _p_) {
    // 0x8075030
    abort();
    // UNREACHABLE
}

// Address range: 0x8075090 - 0x80751ff
void runtime_acquirep1(struct runtime_p * _p_) {
    // 0x8075090
    abort();
    // UNREACHABLE
}

// Address range: 0x8075200 - 0x80753ff
void runtime_releasep(struct runtime_p * a1) {
    // 0x8075200
    abort();
    // UNREACHABLE
}

// Address range: 0x8075400 - 0x807545f
void runtime_incidlelocked(int32_t v) {
    // 0x8075400
    abort();
    // UNREACHABLE
}

// Address range: 0x8075460 - 0x807588f
void runtime_checkdead(void) {
    // 0x8075460
    abort();
    // UNREACHABLE
}

// Address range: 0x8076c40 - 0x8076c8f
void runtime_mput(struct runtime_m * mp) {
    // 0x8076c40
    abort();
    // UNREACHABLE
}

// Address range: 0x8076c90 - 0x8076d8f
void runtime_globrunqget(struct runtime_p * _p_, int32_t max, struct runtime_g * a3) {
    // 0x8076c90
    abort();
    // UNREACHABLE
}

// Address range: 0x8076d90 - 0x8076e0f
void runtime_pidleput(struct runtime_p * _p_) {
    // 0x8076d90
    abort();
    // UNREACHABLE
}

// Address range: 0x8076e10 - 0x8076e6f
void runtime_pidleget(struct runtime_p * a1) {
    // 0x8076e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8076e70 - 0x8076f1f
void runtime_runqempty(struct runtime_p * _p_, bool a2) {
    // 0x8076e70
    abort();
    // UNREACHABLE
}

// Address range: 0x8076f20 - 0x807701f
void runtime_runqput(struct runtime_p * _p_, struct runtime_g * gp, bool next) {
    // 0x8076f20
    abort();
    // UNREACHABLE
}

// Address range: 0x8077020 - 0x80771df
void runtime_runqputslow(struct runtime_p * _p_, struct runtime_g * gp, int32_t h, int32_t t, bool a5) {
    // 0x8077020
    abort();
    // UNREACHABLE
}

// Address range: 0x80771e0 - 0x80772bf
void runtime_runqget(struct runtime_p * _p_, struct runtime_g * gp, bool inheritTime) {
    // 0x80771e0
    abort();
    // UNREACHABLE
}

// Address range: 0x80772c0 - 0x807742f
void runtime_runqgrab(struct runtime_p * _p_, int32_t (*batch)[1], int32_t batchHead, bool stealRunNextG, int32_t a5) {
    // 0x80772c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8077430 - 0x807753f
void runtime_runqsteal(struct runtime_p * _p_, struct runtime_p * p2, bool stealRunNextG, struct runtime_g * a4) {
    // 0x8077430
    abort();
    // UNREACHABLE
}

// Address range: 0x8077670 - 0x807778f
void runtime__lb__ptr_randomOrder_rb__reset(struct runtime_randomOrder * ord, int32_t count) {
    // 0x8077670
    abort();
    // UNREACHABLE
}

// Address range: 0x8077790 - 0x80777cf
void runtime_gcd(int32_t a, int32_t b, int32_t a3) {
    // 0x8077790
    abort();
    // UNREACHABLE
}

// Address range: 0x80782c0 - 0x807833f
void runtime_gotraceback(int32_t level, bool all, bool crash) {
    // 0x80782c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8078340 - 0x80783af
void runtime_args(int32_t c, char ** v) {
    // 0x8078340
    abort();
    // UNREACHABLE
}

// Address range: 0x80783b0 - 0x80784af
void runtime_goargs(void) {
    // 0x80783b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80784b0 - 0x80785cf
void runtime_goenvs_unix(void) {
    // 0x80784b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80785d0 - 0x807899f
void runtime_testAtomic64(void) {
    // 0x80785d0
    abort();
    // UNREACHABLE
}

// Address range: 0x80789a0 - 0x8078ebf
void runtime_check(void) {
    // 0x80789a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8078ec0 - 0x807918f
void runtime_parsedebugvars(void) {
    // 0x8078ec0
    abort();
    // UNREACHABLE
}

// Address range: 0x8079190 - 0x807933f
void runtime_debug_SetTraceback(struct string level) {
    // 0x8079190
    abort();
    // UNREACHABLE
}

// Address range: 0x8079340 - 0x807945f
void runtime_timediv(int64_t v, uint32_t div, int32_t * rem, int32_t a4) {
    int32_t v1 = div / 0x80000000; // 0x807937a
    uint32_t v2 = 30; // 0x807935876
    int32_t v3 = 0; // 0x807940274
    int32_t v4 = v; // 0x807941173
    // branch -> 0x807936d
    int32_t v5; // 0x807935f
    int32_t v6; // 0x807944e
    while (true) {
        uint32_t v7 = 32 - v2; // 0x8079386
        int32_t v8 = v1 << v2 | (v7 < 32 ? div >> v7 % 32 : 0); // 0x80793a2
        uint32_t v9 = div << v2; // 0x80793c8
        int32_t v10;
        int32_t v11 = v10 - v8; // 0x80793db
        v5 = v10;
        v6 = v4;
        int32_t v12 = v3;
        if ((((int32_t)(v10 == v8 || v11 < 0 ^ ((v11 ^ v10) & (v8 ^ v10)) < 0) || v2 & -256) ^ 1 || (int32_t)(v10 == v8) & ((int32_t)(v4 < v9) ^ -255)) != 0) {
            // 0x80793e6
            v5 = v11 + (int32_t)(v4 < v9);
            v6 = v4 - v9;
            v12 = (1 << v2) + v3;
            // branch -> 0x8079358
        }
        // 0x8079358
        if (v2 < 1) {
            // break -> 0x807940a
            break;
        }
        v2--;
        v10 = v5;
        v3 = v12;
        v4 = v6;
        // continue -> 0x807936d
    }
    int32_t v13 = div & -256; // 0x8079413
    int32_t v14 = v5 - v1; // 0x807941f
    if ((((int32_t)(v5 == v1 || v14 < 0 ^ ((v14 ^ v5) & (v5 ^ v1)) < 0) || v1 & -256) ^ 1 || (v13 || (int32_t)(v5 == v1)) & (((int32_t)(v6 < div) || v13) ^ 1)) == 0) {
        // 0x8079446
        if (rem != NULL) {
            // 0x807944e
            *rem = v6;
            // branch -> 0x8079450
        }
        // 0x8079450
        return;
    }
    // 0x807942c
    if (rem != NULL) {
        // 0x8079434
        *rem = 0;
        // branch -> 0x807943a
    }
}

// Address range: 0x8079a40 - 0x8079a6f
void runtime__lb__ptr_guintptr_rb__cas(int32_t * gp, int32_t old, int32_t new, bool a4) {
    // 0x8079a40
    runtime_internal_atomic_Casuintptr();
}

// Address range: 0x8079a70 - 0x8079b2f
void runtime_extendRandom(struct _lsb__rsb_uint8 r, int32_t n) {
    // 0x8079a70
    abort();
    // UNREACHABLE
}

// Address range: 0x8079b30 - 0x8079baf
void runtime__lb__ptr_rwmutex_rb__rlock(struct runtime_rwmutex * rw) {
    // 0x8079b30
    abort();
    // UNREACHABLE
}

// Address range: 0x8079bb0 - 0x8079caf
void runtime__lb__ptr_rwmutex_rb__runlock(struct runtime_rwmutex * rw) {
    // 0x8079bb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8079da0 - 0x8079e0f
void runtime_readyWithTime(struct runtime_sudog * s, int32_t traceskip) {
    // 0x8079da0
    abort();
    // UNREACHABLE
}

// Address range: 0x8079e10 - 0x8079e4f
void runtime_semacquire(int32_t * addr) {
    // 0x8079e10
    abort();
    // UNREACHABLE
}

// Address range: 0x8079e50 - 0x807a15f
void runtime_semacquire1(int32_t * addr, bool lifo, int32_t profile) {
    // 0x8079e50
    abort();
    // UNREACHABLE
}

// Address range: 0x807a160 - 0x807a19f
void runtime_semrelease(int32_t * addr) {
    // 0x807a160
    abort();
    // UNREACHABLE
}

// Address range: 0x807a1a0 - 0x807a37f
void runtime_semrelease1(int32_t * addr, bool handoff) {
    // 0x807a1a0
    abort();
    // UNREACHABLE
}

// Address range: 0x807a380 - 0x807a3df
void runtime_cansemacquire(int32_t * addr, bool a2) {
    // 0x807a380
    abort();
    // UNREACHABLE
}

// Address range: 0x807a3e0 - 0x807a94f
void runtime__lb__ptr_semaRoot_rb__queue(struct runtime_semaRoot * root, int32_t * addr, struct runtime_sudog * s, bool lifo) {
    // 0x807a3e0
    abort();
    // UNREACHABLE
}

// Address range: 0x807a950 - 0x807ae4f
void runtime__lb__ptr_semaRoot_rb__dequeue(struct runtime_semaRoot * root, int32_t * addr, struct runtime_sudog * found, int64_t now) {
    // 0x807a950
    abort();
    // UNREACHABLE
}

// Address range: 0x807ae50 - 0x807b0ff
void runtime__lb__ptr_semaRoot_rb__rotateLeft(struct runtime_semaRoot * root, struct runtime_sudog * x) {
    // 0x807ae50
    abort();
    // UNREACHABLE
}

// Address range: 0x807b100 - 0x807b36f
void runtime__lb__ptr_semaRoot_rb__rotateRight(struct runtime_semaRoot * root, struct runtime_sudog * y) {
    // 0x807b100
    abort();
    // UNREACHABLE
}

// Address range: 0x807ba40 - 0x807bfcf
void runtime_sighandler(int32_t sig, struct runtime_siginfo * info, char * ctxt, struct runtime_g * gp) {
    // 0x807ba40
    abort();
    // UNREACHABLE
}

// Address range: 0x807c020 - 0x807c14f
void runtime_initsig(bool preinit) {
    // 0x807c020
    if (!preinit) {
        // 0x807c144
        *(char *)&runtime_signalsOK = 1;
        // branch -> 0x807c03a
    }
    // 0x807c03a
    int32_t v1;
    int32_t v2;
    int32_t v3; // 0x807c0c332
    int32_t v4; // 0x807c068
    if (*(char *)&runtime_isarchive == 0) {
        // 0x807c12e
        if (*(char *)&runtime_islibrary == 0) {
            // 0x807c051
            v3 = 0;
            v2 = v1;
            // branch -> 0x807c05f
            while (true) {
                // 0x807c05f
                v4 = *(int32_t *)(12 * v3 + (int32_t)&runtime_sigtable);
                int32_t v5; // 0x807c055
                if (v4 != 0) {
                  lab_0x807c06f:
                    // 0x807c06f
                    if (v4 == 16) {
                        // 0x807c077
                        runtime_getsig(v3, v2);
                        int32_t v6 = 4 * v3; // 0x807c091
                        int32_t * v7 = (int32_t *)(v6 + (int32_t)&runtime_fwdSig); // 0x807c091_0
                        *v7 = v2;
                        runtime_sigInstallGoHandler(v3, v2 % 2 != 0);
                        int32_t v8 = v3; // eax
                        int32_t v9;
                        if (v2 % 256 == 0) {
                            int32_t v10 = *v7; // 0x807c0af
                            if (v10 != 0) {
                                // 0x807c0b6
                                if (v10 != 1) {
                                    // 0x807c0c3
                                    runtime_setsigstack(v3);
                                    // branch -> 0x807c0bb
                                }
                            }
                            // 0x807c0bb
                            v9 = v2;
                            // branch -> 0x807c055
                        } else {
                            // 0x807c0d7
                            *(int32_t *)(v6 + (int32_t)&runtime_handlingSig) = 1;
                            runtime_setsig(v8, (int32_t)runtime_sighandler);
                            v9 = (int32_t)runtime_sighandler;
                            // branch -> 0x807c055
                        }
                        // 0x807c055
                        v5 = v3 + 1;
                        if (v5 >= 65) {
                            // break -> 0x807c126
                            break;
                        }
                        v3 = v5;
                        v2 = v9;
                        // continue -> 0x807c05f
                        continue;
                    }
                }
              lab_0x807c055:
                // 0x807c055
                v5 = v3 + 1;
                if (v5 >= 65) {
                    // break -> 0x807c126
                    break;
                }
                v3 = v5;
                // continue -> 0x807c05f
            }
            // 0x807c126
            return;
        }
    }
    // 0x807c04b
    if (!preinit) {
        // 0x807c12a
        return;
    }
    // 0x807c051
    v3 = 0;
    v2 = v1;
    // branch -> 0x807c05f
    while (true) {
        // 0x807c05f
        v4 = *(int32_t *)(12 * v3 + (int32_t)&runtime_sigtable);
        if (v4 == 0) {
            goto lab_0x807c055;
        }
        goto lab_0x807c06f;
    }
}

// Address range: 0x807c150 - 0x807c1ff
void runtime_sigInstallGoHandler(int32_t sig, bool a2) {
    // 0x807c150
    uint32_t v1; // 0x807c1b2
    if (sig > 2) {
        v1 = sig;
        // 0x807c182
        if (v1 > 64) {
            // 0x807c1e8
            runtime_panicindex();
            // branch -> 0x807c1ef
            // 0x807c1ef
            runtime_panicindex();
            return;
        }
        // 0x807c18b
        if (*(int32_t *)(12 * v1 + (int32_t)&runtime_sigtable) != 64) {
            // 0x807c1d6
            return;
        }
        // 0x807c19f
        if (*(char *)&runtime_isarchive == 0) {
            // 0x807c1c9
            if (*(char *)&runtime_islibrary != 0) {
                // 0x807c1aa
                // branch -> 0x807c1b7
            }
        }
        // 0x807c1b7
        return;
    }
    // 0x807c15f
    if (sig > 64) {
        // 0x807c1ef
        runtime_panicindex();
        return;
    }
    // 0x807c168
    runtime_internal_atomic_Loaduintptr();
    int32_t v2;
    if (v2 == 1) {
        // 0x807c1df
        return;
    }
    // 0x807c168
    v1 = sig;
    // branch -> 0x807c182
    // 0x807c182
    if (v1 > 64) {
        // 0x807c1e8
        runtime_panicindex();
        // branch -> 0x807c1ef
        // 0x807c1ef
        runtime_panicindex();
        return;
    }
    // 0x807c18b
    if (*(int32_t *)(12 * v1 + (int32_t)&runtime_sigtable) != 64) {
        // 0x807c1d6
        return;
    }
    // 0x807c19f
    if (*(char *)&runtime_isarchive == 0) {
        // 0x807c1c9
        if (*(char *)&runtime_islibrary != 0) {
            // 0x807c1aa
            // branch -> 0x807c1b7
        }
    }
}

// Address range: 0x807c200 - 0x807c2df
void runtime_setThreadCPUProfiler(int32_t hz) {
    // 0x807c200
    abort();
    // UNREACHABLE
}

// Address range: 0x807ce30 - 0x807ce5f
void runtime_msigsave(struct runtime_m * mp) {
    // 0x807ce30
    runtime_sigprocmask(2, NULL, (int32_t (*)[1])((int32_t)mp + 48));
}

// Address range: 0x807cf30 - 0x807cf5f
void runtime_minitSignals(void) {
    // 0x807cf30
    abort();
    // UNREACHABLE
}

// Address range: 0x807cf60 - 0x807d04f
void runtime_minitSignalStack(void) {
    // 0x807cf60
    abort();
    // UNREACHABLE
}

// Address range: 0x807d050 - 0x807d11f
void runtime_minitSignalMask(void) {
    // 0x807d050
    abort();
    // UNREACHABLE
}

// Address range: 0x807d170 - 0x807d1bf
void runtime_signalstack(struct runtime_stack * s) {
    // 0x807d170
    runtime_sigaltstack();
}

// Address range: 0x807d3a0 - 0x807d46f
void runtime_makeslice(struct runtime__type * et, int32_t len, int32_t cap, struct runtime_slice a4) {
    // 0x807d3a0
    abort();
    // UNREACHABLE
}

// Address range: 0x807d470 - 0x807d8ff
void runtime_growslice(struct runtime__type * et, struct runtime_slice old, int32_t cap, struct runtime_slice a4) {
    // 0x807d470
    abort();
    // UNREACHABLE
}

// Address range: 0x807d900 - 0x807d97f
void runtime_stackinit(void) {
    // 0x807d900
    abort();
    // UNREACHABLE
}

// Address range: 0x807d980 - 0x807d9af
void runtime_stacklog2(int32_t n, int32_t a2) {
    // 0x807d980
    abort();
    // UNREACHABLE
}

// Address range: 0x807d9b0 - 0x807db3f
void runtime_stackpoolalloc(char order, int32_t a2) {
    // 0x807d9b0
    abort();
    // UNREACHABLE
}

// Address range: 0x807db40 - 0x807dc7f
void runtime_stackpoolfree(int32_t x, char order) {
    // 0x807db40
    abort();
    // UNREACHABLE
}

// Address range: 0x807dc80 - 0x807dd4f
void runtime_stackcacherefill(struct runtime_mcache * c, char order) {
    // 0x807dc80
    abort();
    // UNREACHABLE
}

// Address range: 0x807dd50 - 0x807de5f
void runtime_stackcacherelease(struct runtime_mcache * c, char order) {
    // 0x807dd50
    abort();
    // UNREACHABLE
}

// Address range: 0x807de60 - 0x807df1f
void runtime_stackcache_clear(struct runtime_mcache * c) {
    // 0x807de60
    abort();
    // UNREACHABLE
}

// Address range: 0x807df20 - 0x807e1bf
void runtime_stackalloc(int32_t n, struct runtime_stack a2) {
    // 0x807df20
    abort();
    // UNREACHABLE
}

// Address range: 0x807e1c0 - 0x807e45f
void runtime_stackfree(struct runtime_stack stk) {
    // 0x807e1c0
    abort();
    // UNREACHABLE
}

// Address range: 0x807ed40 - 0x807edaf
void runtime_adjustctxt(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo) {
    // 0x807ed40
    abort();
    // UNREACHABLE
}

// Address range: 0x807edb0 - 0x807ee6f
void runtime_adjustdefers(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo) {
    // 0x807edb0
    abort();
    // UNREACHABLE
}

// Address range: 0x807ee70 - 0x807eedf
void runtime_adjustsudogs(struct runtime_g * gp, struct runtime_adjustinfo * adjinfo) {
    // 0x807ee70
    abort();
    // UNREACHABLE
}

// Address range: 0x807eee0 - 0x807ef4f
void runtime_findsghi(struct runtime_g * gp, struct runtime_stack stk, int32_t a3) {
    // 0x807eee0
    abort();
    // UNREACHABLE
}

// Address range: 0x807ef50 - 0x807f05f
void runtime_syncadjustsudogs(struct runtime_g * gp, int32_t used, struct runtime_adjustinfo * adjinfo, int32_t a4) {
    // 0x807ef50
    abort();
    // UNREACHABLE
}

// Address range: 0x807f060 - 0x807f2df
void runtime_copystack(struct runtime_g * gp, int32_t newsize, bool sync) {
    // 0x807f060
    abort();
    // UNREACHABLE
}

// Address range: 0x807f2e0 - 0x807f31f
void runtime_round2(int32_t x, int32_t a2) {
    // 0x807f2e0
    abort();
    // UNREACHABLE
}

// Address range: 0x807f320 - 0x807fe5f
void runtime_newstack(char * ctxt) {
    // 0x807f320
    abort();
    // UNREACHABLE
}

// Address range: 0x807fe60 - 0x807ff8f
void runtime_shrinkstack(struct runtime_g * gp) {
    // 0x807fe60
    abort();
    // UNREACHABLE
}

// Address range: 0x80800f0 - 0x808010f
void runtime_morestackc(void) {
    // 0x80800f0
    runtime_systemstack();
}

// Address range: 0x8080490 - 0x808052f
void runtime_slicebytetostring(char (*buf)[1], struct _lsb__rsb_uint8 b, struct string str) {
    // 0x8080490
    abort();
    // UNREACHABLE
}

// Address range: 0x80809e0 - 0x8080a5f
void runtime_rawstring(int32_t size, struct string s, struct _lsb__rsb_uint8 b) {
    // 0x80809e0
    abort();
    // UNREACHABLE
}

// Address range: 0x8080d20 - 0x8080dcf
void runtime_gostring(char * p, struct string a2) {
    // 0x8080d20
    abort();
    // UNREACHABLE
}

// Address range: 0x8080dd0 - 0x8080eaf
void runtime_index(struct string s, struct string t, char * a3) {
    // 0x8080dd0
    abort();
    // UNREACHABLE
}

// Address range: 0x8080eb0 - 0x8080f0f
void runtime_contains(struct string s, struct string t, bool a3) {
    // 0x8080eb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8080f10 - 0x808103f
void runtime_atoi(struct string s, int32_t a2, bool a3) {
    // 0x8080f10
    abort();
    // UNREACHABLE
}

// Address range: 0x8081040 - 0x808108f
void runtime_atoi32(struct string s, int32_t a2, bool a3) {
    // 0x8081040
    abort();
    // UNREACHABLE
}

// Address range: 0x8081090 - 0x80810cf
void runtime_findnull(char * s, int32_t a2) {
    // 0x8081090
    if (s == NULL) {
        // 0x80810b2
        return;
    }
    int32_t v1 = 0; // 0x808109c7
    // branch -> 0x80810a5
    while (true) {
        // 0x80810a5
        if (*(char *)(v1 + (int32_t)s) == 0) {
            // 0x80810ad
            return;
        }
        int32_t v2 = v1 + 1; // 0x808109c
        if (v2 >= 0x7ffffffe) {
            // break -> 0x80810bb
            break;
        }
        v1 = v2;
        // continue -> 0x80810a5
    }
    // 0x80810bb
    runtime_panicindex();
}

// Address range: 0x80810d0 - 0x80810ff
void runtime_gostringnocopy(char * str, struct string a2) {
    // 0x80810d0
    int32_t v1;
    runtime_findnull(str, v1);
}

// Address range: 0x8081100 - 0x808113f
void runtime_badsystemstack(void) {
    // 0x8081100
    abort();
    // UNREACHABLE
}

// Address range: 0x8081c60 - 0x8081caf
void runtime_activeModules(struct _lsb__rsb__ptr_runtime_moduledata a1) {
    // 0x8081c60
    int32_t v1;
    runtime_internal_atomic_Loadp((char *)&runtime_modulesSlice, (char *)v1);
    if (v1 == 0) {
        // 0x8081c91
        return;
    }
}

// Address range: 0x8081cb0 - 0x8081f4f
void runtime_modulesinit(void) {
    // 0x8081cb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8081f50 - 0x8081f9f
void runtime_moduledataverify(void) {
    // 0x8081f50
    abort();
    // UNREACHABLE
}

// Address range: 0x8081fa0 - 0x808274f
void runtime_moduledataverify1(struct runtime_moduledata * datap) {
    // 0x8081fa0
    abort();
    // UNREACHABLE
}

// Address range: 0x8082800 - 0x808284f
void runtime_findmoduledatap(int32_t pc, struct runtime_moduledata * a2) {
    // 0x8082800
    abort();
    // UNREACHABLE
}

// Address range: 0x8082850 - 0x808297f
void runtime_findfunc(int32_t pc, struct runtime_funcInfo a2) {
    // 0x8082850
    abort();
    // UNREACHABLE
}

// Address range: 0x8082980 - 0x8082dff
void runtime_pcvalue(struct runtime_funcInfo f, int32_t off, int32_t targetpc, struct runtime_pcvalueCache * cache, bool strict, int32_t a6) {
    // 0x8082980
    abort();
    // UNREACHABLE
}

// Address range: 0x8082e00 - 0x8082e6f
void runtime_funcname(struct runtime_funcInfo f, struct string a2) {
    // 0x8082e00
    abort();
    // UNREACHABLE
}

// Address range: 0x8082e70 - 0x8082edf
void runtime_funcnameFromNameoff(struct runtime_funcInfo f, int32_t nameoff, struct string a3) {
    // 0x8082e70
    abort();
    // UNREACHABLE
}

// Address range: 0x8082ee0 - 0x8082f5f
void runtime_funcfile(struct runtime_funcInfo f, int32_t fileno, struct string a3) {
    // 0x8082ee0
    abort();
    // UNREACHABLE
}

// Address range: 0x8082f60 - 0x808309f
void runtime_funcline1(struct runtime_funcInfo f, int32_t targetpc, bool strict, struct string file, int32_t line) {
    // 0x8082f60
    abort();
    // UNREACHABLE
}

// Address range: 0x80830a0 - 0x80830ff
void runtime_funcline(struct runtime_funcInfo f, int32_t targetpc, struct string file, int32_t line) {
    // 0x80830a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8083100 - 0x808329f
void runtime_funcspdelta(struct runtime_funcInfo f, int32_t targetpc, struct runtime_pcvalueCache * cache, int32_t a4) {
    // 0x8083100
    abort();
    // UNREACHABLE
}

// Address range: 0x80832a0 - 0x808331f
void runtime_pcdatavalue(struct runtime_funcInfo f, int32_t table, int32_t targetpc, struct runtime_pcvalueCache * cache, int32_t a5) {
    // 0x80832a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8083320 - 0x808336f
void runtime_funcdata(struct runtime_funcInfo f, int32_t i, char * a3) {
    // 0x8083320
    abort();
    // UNREACHABLE
}

// Address range: 0x8083370 - 0x808350f
void runtime_step(struct _lsb__rsb_uint8 p, int32_t * pc, int32_t * val, bool first, struct _lsb__rsb_uint8 newp, bool ok) {
    // 0x8083370
    abort();
    // UNREACHABLE
}

// Address range: 0x8083510 - 0x808357f
void runtime_readvarint(struct _lsb__rsb_uint8 p, int32_t read, int32_t val) {
    // 0x8083510
    abort();
    // UNREACHABLE
}

// Address range: 0x8083b70 - 0x8083c7f
void runtime_timejump(struct runtime_g * a1) {
    // 0x8083b70
    abort();
    // UNREACHABLE
}

// Address range: 0x80840b0 - 0x808412f
void time_now(int64_t sec, int32_t nsec, int64_t mono) {
    // 0x80840b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8084130 - 0x80841ff
void runtime_traceReader(struct runtime_g * a1) {
    // 0x8084130
    abort();
    // UNREACHABLE
}

// Address range: 0x8084200 - 0x808428f
void runtime_traceProcFree(struct runtime_p * pp) {
    // 0x8084200
    abort();
    // UNREACHABLE
}

// Address range: 0x8084290 - 0x80845af
void runtime_traceEvent(char ev, int32_t skip, struct _lsb__rsb_uint64 args) {
    // 0x8084290
    abort();
    // UNREACHABLE
}

// Address range: 0x80845b0 - 0x80846cf
void runtime_traceStackID(struct runtime_m * mp, struct _lsb__rsb_uintptr buf, int32_t skip, int64_t a4) {
    // 0x80845b0
    abort();
    // UNREACHABLE
}

// Address range: 0x80846d0 - 0x808475f
void runtime_traceAcquireBuffer(struct runtime_m * mp, int32_t pid, int32_t * bufp) {
    // 0x80846d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8084760 - 0x80847cf
void runtime_traceReleaseBuffer(int32_t pid) {
    // 0x8084760
    abort();
    // UNREACHABLE
}

// Address range: 0x80847d0 - 0x808491f
void runtime_traceFlush(int32_t buf, int32_t a2) {
    // 0x80847d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8084920 - 0x80849bf
void runtime__lb__ptr_traceBuf_rb__varint(struct runtime_traceBuf * buf, int64_t v) {
    // 0x8084920
    abort();
    // UNREACHABLE
}

// Address range: 0x80849c0 - 0x8084b6f
void runtime__lb__ptr_traceStackTable_rb__put(struct runtime_traceStackTable * tab, struct _lsb__rsb_uintptr pcs, struct runtime_traceStack * a3) {
    // 0x80849c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8084b70 - 0x8084c2f
void runtime__lb__ptr_traceStackTable_rb__find(struct runtime_traceStackTable * tab, struct _lsb__rsb_uintptr pcs, int32_t hash, int32_t a4) {
    // 0x8084b70
    abort();
    // UNREACHABLE
}

// Address range: 0x8084c30 - 0x8084c7f
void runtime__lb__ptr_traceStackTable_rb__newStack(struct runtime_traceStackTable * tab, int32_t n, struct runtime_traceStack * a3) {
    // 0x8084c30
    abort();
    // UNREACHABLE
}

// Address range: 0x8084c80 - 0x8084d6f
void runtime__lb__ptr_traceAlloc_rb__alloc(struct runtime_traceAlloc * a, int32_t n, char * a3) {
    // 0x8084c80
    abort();
    // UNREACHABLE
}

// Address range: 0x8084d70 - 0x8084ddf
void runtime_traceGomaxprocs(int32_t procs) {
    // 0x8084d70
    abort();
    // UNREACHABLE
}

// Address range: 0x8084de0 - 0x8084e5f
void runtime_traceProcStart(void) {
    // 0x8084de0
    abort();
    // UNREACHABLE
}

// Address range: 0x8084e60 - 0x8084f1f
void runtime_traceProcStop(struct runtime_p * pp) {
    // 0x8084e60
    abort();
    // UNREACHABLE
}

// Address range: 0x8084f20 - 0x8084faf
void runtime_traceGCStart(void) {
    // 0x8084f20
    abort();
    // UNREACHABLE
}

// Address range: 0x8084fb0 - 0x8084fff
void runtime_traceGCDone(void) {
    // 0x8084fb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8085000 - 0x808504f
void runtime_traceGCScanStart(void) {
    // 0x8085000
    abort();
    // UNREACHABLE
}

// Address range: 0x8085050 - 0x808509f
void runtime_traceGCScanDone(void) {
    // 0x8085050
    abort();
    // UNREACHABLE
}

// Address range: 0x80852b0 - 0x80852ff
void runtime_traceGCMarkAssistStart(void) {
    // 0x80852b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8085300 - 0x808534f
void runtime_traceGCMarkAssistDone(void) {
    // 0x8085300
    abort();
    // UNREACHABLE
}

// Address range: 0x8085450 - 0x808560f
void runtime_traceGoStart(void) {
    // 0x8085450
    abort();
    // UNREACHABLE
}

// Address range: 0x8085660 - 0x80856cf
void runtime_traceGoSched(void) {
    // 0x8085660
    abort();
    // UNREACHABLE
}

// Address range: 0x80856d0 - 0x808573f
void runtime_traceGoPreempt(void) {
    // 0x80856d0
    abort();
    // UNREACHABLE
}

// Address range: 0x80857d0 - 0x80858ef
void runtime_traceGoUnpark(struct runtime_g * gp, int32_t skip) {
    // 0x80857d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8085940 - 0x8085a7f
void runtime_traceGoSysExit(int64_t ts) {
    // 0x8085940
    abort();
    // UNREACHABLE
}

// Address range: 0x8085bb0 - 0x8085c8f
void runtime_traceNextGC(void) {
    // 0x8085bb0
    abort();
    // UNREACHABLE
}

// Address range: 0x8085c90 - 0x8085f2f
void runtime_tracebackinit(void) {
    // 0x8085c90
    abort();
    // UNREACHABLE
}

// Address range: 0x8085f30 - 0x80860cf
void runtime_tracebackdefers(struct runtime_g * gp, void (*callback)(struct runtime_stkframe *, char *, bool *), char * v) {
    // 0x8085f30
    abort();
    // UNREACHABLE
}

// Address range: 0x80860d0 - 0x808772f
void runtime_gentraceback(int32_t pc0, int32_t sp0, int32_t lr0, struct runtime_g * gp, int32_t skip, int32_t * pcbuf, int32_t max, void (*callback)(struct runtime_stkframe *, char *, bool *), char * v, int32_t flags, int32_t a11) {
    // 0x80860d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8087730 - 0x80878bf
void runtime_getArgInfo(struct runtime_stkframe * frame, struct runtime_funcInfo f, bool needArgMap, struct runtime_funcval * ctxt, int32_t arglen, struct runtime_bitvector * argmap) {
    // 0x8087730
    abort();
    // UNREACHABLE
}

// Address range: 0x80878c0 - 0x8087acf
void runtime_tracebackCgoContext(int32_t * pcbuf, bool printing, int32_t ctxt, int32_t n, int32_t max, int32_t a6) {
    // 0x80878c0
    abort();
    // UNREACHABLE
}

// Address range: 0x8087ad0 - 0x8087cef
void runtime_printcreatedby(struct runtime_g * gp) {
    // 0x8087ad0
    abort();
    // UNREACHABLE
}

// Address range: 0x8087cf0 - 0x8087d3f
void runtime_traceback(int32_t pc, int32_t sp, int32_t lr, struct runtime_g * gp) {
    // 0x8087cf0
    abort();
    // UNREACHABLE
}

// Address range: 0x8087d90 - 0x8087fef
void runtime_traceback1(int32_t pc, int32_t sp, int32_t lr, struct runtime_g * gp, int32_t flags) {
    // 0x8087d90
    abort();
    // UNREACHABLE
}

// Address range: 0x8087ff0 - 0x80880af
void runtime_callers(int32_t skip, struct _lsb__rsb_uintptr pcbuf, int32_t a3) {
    // 0x8087ff0
    abort();
    // UNREACHABLE
}

// Address range: 0x80880b0 - 0x808813f
void runtime_gcallers(struct runtime_g * gp, int32_t skip, struct _lsb__rsb_uintptr pcbuf, int32_t a4) {
    // 0x80880b0
    abort();
    // UNREACHABLE
}

// Address range: 0x8088140 - 0x80882ff
void runtime_showframe(struct runtime_funcInfo f, struct runtime_g * gp, bool firstFrame, bool a4) {
    // 0x8088140
    abort();
    // UNREACHABLE
}

// Address range: 0x8088300 - 0x808858f
void runtime_goroutineheader(struct runtime_g * gp) {
    // 0x8088300
    abort();
    // UNREACHABLE
}

// Address range: 0x8088820 - 0x808892f
void runtime_printCgoTraceback(int32_t (*callers)[1]) {
    // 0x8088820
    abort();
    // UNREACHABLE
}

// Address range: 0x8088930 - 0x8088b1f
void runtime_printOneCgoTraceback(int32_t pc, int32_t max, struct runtime_cgoSymbolizerArg * arg, int32_t a4) {
    // 0x8088930
    abort();
    // UNREACHABLE
}

// Address range: 0x8088b20 - 0x8088b8f
void runtime_callCgoSymbolizer(struct runtime_cgoSymbolizerArg * arg) {
    // 0x8088b20
    abort();
    // UNREACHABLE
}

// Address range: 0x8088b90 - 0x8088c3f
void runtime_cgoContextPCs(int32_t ctxt, struct _lsb__rsb_uintptr buf) {
    // 0x8088b90
    abort();
    // UNREACHABLE
}

// Address range: 0x8088c40 - 0x8088ccf
void runtime__lb__ptr__type_rb__string(struct runtime__type * t, struct string a2) {
    // 0x8088c40
    abort();
    // UNREACHABLE
}

// Address range: 0x8088cd0 - 0x8088d8f
void runtime__lb__ptr__type_rb__uncommon(struct runtime__type * t, struct runtime_uncommontype * a2) {
    // 0x8088cd0
    abort();
    // UNREACHABLE
}

// Address range: 0x8088d90 - 0x8088dbf
void runtime_reflectOffsLock(void) {
    // 0x8088d90
    abort();
    // UNREACHABLE
}

// Address range: 0x8088dc0 - 0x8088def
void runtime_reflectOffsUnlock(void) {
    // 0x8088dc0
    abort();
    // UNREACHABLE
}

// Address range: 0x8088df0 - 0x80890cf
void runtime_resolveNameOff(char * ptrInModule, int32_t off, struct runtime_name a3) {
    // 0x8088df0
    abort();
    // UNREACHABLE
}

// Address range: 0x80890d0 - 0x808910f
void runtime__lb__ptr__type_rb__nameOff(struct runtime__type * t, int32_t off, struct runtime_name a3) {
    // 0x80890d0
    abort();
    // UNREACHABLE
}

// Address range: 0x8089110 - 0x808942f
void runtime_resolveTypeOff(char * ptrInModule, int32_t off, struct runtime__type * a3) {
    // 0x8089110
    abort();
    // UNREACHABLE
}

// Address range: 0x8089430 - 0x808946f
void runtime__lb__ptr__type_rb__typeOff(struct runtime__type * t, int32_t off, struct runtime__type * a3) {
    // 0x8089430
    abort();
    // UNREACHABLE
}

// Address range: 0x8089470 - 0x808979f
void runtime__lb__ptr__type_rb__textOff(struct runtime__type * t, int32_t off, char * a3) {
    // 0x8089470
    abort();
    // UNREACHABLE
}

// Address range: 0x80897a0 - 0x808980f
void runtime_name_tagLen(struct runtime_name n, int32_t a2) {
    // 0x80897a0
    abort();
    // UNREACHABLE
}

// Address range: 0x8089810 - 0x808988f
void runtime_name_name(struct runtime_name n, struct string s) {
    // 0x8089810
    abort();
    // UNREACHABLE
}

// Address range: 0x8089890 - 0x808990f
void runtime_name_tag(struct runtime_name n, struct string s) {
    // 0x8089890
    abort();
    // UNREACHABLE
}

// Address range: 0x8089910 - 0x80899ff
void runtime_name_pkgPath(struct runtime_name n, struct string a2) {
    // 0x8089910
    abort();
    // UNREACHABLE
}

// Address range: 0x8089a00 - 0x8089f3f
void runtime_typelinksinit(void) {
    // 0x8089a00
    abort();
    // UNREACHABLE
}

// Address range: 0x8089f40 - 0x808ac2f
void runtime_typesEqual(struct runtime__type * t, struct runtime__type * v, struct hash_lt_runtime__typePair_comma_struct___gt_ * seen, bool a4) {
    // 0x8089f40
    abort();
    // UNREACHABLE
}

// Address range: 0x808af10 - 0x808af5f
void runtime_float64toint64(float64_t d, int64_t y) {
    // 0x808af10
    abort();
    // UNREACHABLE
}

// Address range: 0x808af60 - 0x808afaf
void runtime_float64touint64(float64_t d, int64_t y) {
    // 0x808af60
    abort();
    // UNREACHABLE
}

// Address range: 0x808afb0 - 0x808b09f
void runtime_int64tofloat64(int64_t y, float64_t a2) {
    // 0x808afb0
    abort();
    // UNREACHABLE
}

// Address range: 0x808b0a0 - 0x808b10f
void runtime_uint64tofloat64(int64_t y, float64_t a2) {
    // 0x808b0a0
    abort();
    // UNREACHABLE
}

// Address range: 0x808b110 - 0x808b22f
void runtime__d2v(int64_t * y, float64_t d) {
    // 0x808b110
    abort();
    // UNREACHABLE
}

// Address range: 0x808b230 - 0x808b2cf
void runtime_uint64div(int64_t n, int64_t d, int64_t a3) {
    // 0x808b230
    abort();
    // UNREACHABLE
}

// Address range: 0x808b2d0 - 0x808b36f
void runtime_uint64mod(int64_t n, int64_t d, int64_t a3) {
    // 0x808b2d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808b370 - 0x808b4ef
void runtime_int64div(int64_t n, int64_t d, int64_t a3) {
    // 0x808b370
    abort();
    // UNREACHABLE
}

// Address range: 0x808b4f0 - 0x808b63f
void runtime_int64mod(int64_t n, int64_t d, int64_t a3) {
    // 0x808b4f0
    abort();
    // UNREACHABLE
}

// Address range: 0x808b640 - 0x808b82f
void runtime_dodiv(int64_t n, int64_t d, int64_t q, int64_t r) {
    // 0x808b640
    abort();
    // UNREACHABLE
}

// Address range: 0x808b830 - 0x808b98f
void runtime_slowdodiv(int64_t n, int64_t d, int64_t q, int64_t r) {
    // 0x808b830
    abort();
    // UNREACHABLE
}

// Address range: 0x808b990 - 0x808b9df
void runtime_writeErr(struct _lsb__rsb_uint8 b) {
    // 0x808b990
    abort();
    // UNREACHABLE
}

// Address range: 0x808ba20 - 0x808badf
void runtime_cgoCheckWriteBarrier_func1(void) {
    // 0x808ba20
    abort();
    // UNREACHABLE
}

// Address range: 0x808bae0 - 0x808bb1f
void runtime_cgoCheckTypedBlock_func1(void) {
    // 0x808bae0
    abort();
    // UNREACHABLE
}

// Address range: 0x808bc00 - 0x808bc3f
void runtime__lb__ptr_mcache_rb__nextFree_func1(void) {
    // 0x808bc00
    abort();
    // UNREACHABLE
}

// Address range: 0x808bc40 - 0x808bc8f
void runtime_mallocgc_func1(void) {
    // 0x808bc40
    abort();
    // UNREACHABLE
}

// Address range: 0x808bc90 - 0x808bcff
void runtime_persistentalloc_func1(void) {
    // 0x808bc90
    abort();
    // UNREACHABLE
}

// Address range: 0x808bd00 - 0x808bddf
void runtime_writebarrierptr_prewrite1_func1(void) {
    // 0x808bd00
    abort();
    // UNREACHABLE
}

// Address range: 0x808bde0 - 0x808be9f
void runtime_writebarrierptr_func1(void) {
    // 0x808bde0
    abort();
    // UNREACHABLE
}

// Address range: 0x808c120 - 0x808c1bf
void runtime_freemcache_func1(void) {
    // 0x808c120
    abort();
    // UNREACHABLE
}

// Address range: 0x808c260 - 0x808c30f
void runtime__lb__ptr_gcControllerState_rb__findRunnableGCWorker_func1(int64_t * ptr, bool a2) {
    // 0x808c260
    abort();
    // UNREACHABLE
}

// Address range: 0x808c3a0 - 0x808c3df
void runtime_gcMarkTermination_func1(void) {
    // 0x808c3a0
    abort();
    // UNREACHABLE
}

// Address range: 0x808c3e0 - 0x808c4df
void runtime_gcMarkTermination_func2(void) {
    // 0x808c3e0
    abort();
    // UNREACHABLE
}

// Address range: 0x808c710 - 0x808c73f
void runtime_gcMarkRootPrepare_func1(int32_t bytes, int32_t a2) {
    // 0x808c710
    abort();
    // UNREACHABLE
}

// Address range: 0x808c740 - 0x808c84f
void runtime_markroot_func1(void) {
    // 0x808c740
    abort();
    // UNREACHABLE
}

// Address range: 0x808c890 - 0x808c8cf
void runtime_scanstack_func1(struct runtime_stkframe * frame, char * unused, bool a3) {
    // 0x808c890
    abort();
    // UNREACHABLE
}

// Address range: 0x808c8d0 - 0x808c90f
void runtime_gosweepone_func1(void) {
    // 0x808c8d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808c910 - 0x808c96f
void runtime_getempty_func1(void) {
    // 0x808c910
    abort();
    // UNREACHABLE
}

// Address range: 0x808cbc0 - 0x808cbff
void runtime_mProf_Malloc_func1(void) {
    // 0x808cbc0
    abort();
    // UNREACHABLE
}

// Address range: 0x808cc00 - 0x808cc4f
void runtime_tracealloc_func1(void) {
    // 0x808cc00
    abort();
    // UNREACHABLE
}

// Address range: 0x808cca0 - 0x808cd3f
void runtime_futexwakeup_func1(void) {
    // 0x808cca0
    abort();
    // UNREACHABLE
}

// Address range: 0x808cd40 - 0x808cf1f
void runtime_newdefer_func1(void) {
    // 0x808cd40
    abort();
    // UNREACHABLE
}

// Address range: 0x808cf20 - 0x808d03f
void runtime_newdefer_func2(void) {
    // 0x808cf20
    abort();
    // UNREACHABLE
}

// Address range: 0x808d040 - 0x808d1ff
void runtime_freedefer_func1(void) {
    // 0x808d040
    abort();
    // UNREACHABLE
}

// Address range: 0x808d250 - 0x808d28f
void runtime_dopanic_func1(void) {
    // 0x808d250
    abort();
    // UNREACHABLE
}

// Address range: 0x808d300 - 0x808d33f
void runtime_goready_func1(void) {
    // 0x808d300
    abort();
    // UNREACHABLE
}

// Address range: 0x808d340 - 0x808d3ff
void runtime_casgstatus_func1(void) {
    // 0x808d340
    abort();
    // UNREACHABLE
}

// Address range: 0x808d530 - 0x808d68f
void runtime_entersyscallblock_func1(void) {
    // 0x808d530
    abort();
    // UNREACHABLE
}

// Address range: 0x808d690 - 0x808d7ef
void runtime_entersyscallblock_func2(void) {
    // 0x808d690
    abort();
    // UNREACHABLE
}

// Address range: 0x808d830 - 0x808d8cf
void runtime_exitsyscallfast_func1(void) {
    // 0x808d830
    abort();
    // UNREACHABLE
}

// Address range: 0x808d8d0 - 0x808d91f
void runtime_exitsyscallfast_reacquired_func1(void) {
    // 0x808d8d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808d920 - 0x808d96f
void runtime_malg_func1(void) {
    // 0x808d920
    abort();
    // UNREACHABLE
}

// Address range: 0x808d970 - 0x808d9bf
void runtime_newproc_func1(void) {
    // 0x808d970
    abort();
    // UNREACHABLE
}

// Address range: 0x808da10 - 0x808dabf
void runtime__lb__ptr_rwmutex_rb__rlock_func1(void) {
    // 0x808da10
    abort();
    // UNREACHABLE
}

// Address range: 0x808db00 - 0x808db8f
void runtime_callers_func1(void) {
    // 0x808db00
    abort();
    // UNREACHABLE
}

// Address range: 0x808dd80 - 0x808dfbf
void runtime_rt0_go(void) {
    int32_t v1;
    int32_t v2 = &v1; // 0x808dd88_3
    int32_t v3 = v2 & -16; // 0x808dd8e
    uint32_t v4 = llvm_ctpop_i32(0x1000000 * v3 / 0x1000000); // 0x808dd8e
    g3 = &runtime_g0;
    int32_t v5;
    int32_t v6 = &v5; // 0x808dd9e_0
    g24 = v6;
    g25 = v6;
    runtime_g0 = v6;
    g23 = v2;
    int32_t v7 = v4 % 2 == 1 ? 4 : 0; // 0x808ddb1
    int32_t v8 = 0; // 0x808ddb1
    int32_t v9 = g6 ? 1024 : 0; // 0x808ddb1
    bool v10 = false; // 0x808ddb1
    int32_t v11 = (bool)false ? 0x40000 : 0; // 0x808ddb1
    int32_t v12 = v2 >> 31 & 128 | (v3 == 0 ? 64 : 0) | v7; // 0x808ddb1
    int32_t v13 = v9 | v8 | v12 | (v10 ? 0x4000 : 0) | v11; // 0x808ddb1
    int32_t v14 = v13 & 0x40000; // 0x808ddba
    int32_t v15 = v13 & 0x200000; // 0x808ddb3
    int32_t v16 = v10 ? 0x4000 : 0; // 0x808ddbb
    if (((v8 || v12 || v9 || v16 || v14 || v15 ^ 0x200000 || 2) ^ (v13 || 2)) == 0x200000) {
        // 0x808ddc8
        v1 = 2;
        runtime_write();
        v1 = 1;
        runtime_exit();
        // branch -> 0x808ddf2
    }
    // 0x808ddf2
    g9 = 0;
    int32_t v17 = runtime_bss; // 0x808df0c
    g2 = v17;
    g1 = false;
    g33 = false;
    g35 = v17 == 0;
    g34 = v17 < 0;
    if (v17 == 0) {
        // 0x808df38
        runtime_ldt0setup();
        abort();
        // UNREACHABLE
    }
    // 0x808df16
    g4 = 0x808f5a0;
    v1 = g3;
    ((int32_t (*)(int32_t))v17)((int32_t)setg_gcc);
    int32_t v18 = runtime_g0 + 880; // 0x808df2b
    g2 = v18;
    g24 = v18;
    g25 = v18;
    abort();
    // UNREACHABLE
}

// Address range: 0x808dfc0 - 0x808dfcf
void runtime_asminit(void) {
    // 0x808dfc0
    return;
}

// Address range: 0x808dfd0 - 0x808e00f
void runtime_gosave(void) {
    // 0x808dfd0
    int32_t v1;
    int32_t v2 = v1;
    *(int32_t *)v1 = (int32_t)&v2;
    int32_t v3;
    *(int32_t *)(v1 + 4) = v3;
    *(int32_t *)(v1 + 16) = 0;
    if (*(int32_t *)(v1 + 12) != 0) {
        // 0x808dfee
        runtime_badctxt();
        // branch -> 0x808dff3
    }
    // 0x808dff3
    abort();
    // UNREACHABLE
}

// Address range: 0x808e010 - 0x808e06f
void runtime_gogo(void) {
    // 0x808e010
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x808e017_0
    if (*v2 != 0) {
        // 0x808e01e
        runtime_writebarrierptr_prewrite(v2, 0);
        // branch -> 0x808e035
    }
    // 0x808e035
    abort();
    // UNREACHABLE
}

// Address range: 0x808e070 - 0x808e0bf
void runtime_mcall(void) {
    // 0x808e070
    abort();
    // UNREACHABLE
}

// Address range: 0x808e0d0 - 0x808e15f
void runtime_systemstack(void) {
    // 0x808e0d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e160 - 0x808e1ef
void runtime_morestack(void) {
    // 0x808e160
    abort();
    // UNREACHABLE
}

// Address range: 0x808e1f0 - 0x808e1ff
void runtime_morestack_noctxt(void) {
    // 0x808e1f0
    runtime_morestack();
}

// Address range: 0x808e210 - 0x808e3af
void runtime_reflectcall(void) {
    // 0x808e210
    uint32_t v1;
    if (v1 <= 16) {
        // 0x808e219
        runtime_call16();
        return;
    }
    // 0x808e220
    if (v1 <= 32) {
        // 0x808e225
        runtime_call32();
        return;
    }
    // 0x808e22c
    if (v1 <= 64) {
        // 0x808e231
        runtime_call64();
        return;
    }
    // 0x808e238
    if (v1 <= 128) {
        // 0x808e240
        runtime_call128();
        return;
    }
    // 0x808e247
    if (v1 <= 256) {
        // 0x808e24f
        runtime_call256();
        return;
    }
    // 0x808e256
    if (v1 <= 512) {
        // 0x808e25e
        runtime_call512();
        return;
    }
    // 0x808e265
    if (v1 <= 1024) {
        // 0x808e26d
        runtime_call1024();
        return;
    }
    // 0x808e274
    if (v1 <= 2048) {
        // 0x808e27c
        runtime_call2048();
        return;
    }
    // 0x808e283
    if (v1 <= 0x1000) {
        // 0x808e28b
        runtime_call4096();
        return;
    }
    // 0x808e292
    if (v1 <= 0x2000) {
        // 0x808e29a
        runtime_call8192();
        return;
    }
    // 0x808e2a1
    if (v1 <= 0x4000) {
        // 0x808e2a9
        runtime_call16384();
        return;
    }
    // 0x808e2b0
    if (v1 <= 0x8000) {
        // 0x808e2b8
        runtime_call32768();
        return;
    }
    // 0x808e2bf
    if (v1 <= 0x10000) {
        // 0x808e2c7
        runtime_call65536();
        return;
    }
    // 0x808e2ce
    if (v1 <= 0x20000) {
        // 0x808e2d6
        runtime_call131072();
        return;
    }
    // 0x808e2dd
    if (v1 <= 0x40000) {
        // 0x808e2e5
        runtime_call262144();
        return;
    }
    // 0x808e2ec
    if (v1 <= 0x80000) {
        // 0x808e2f4
        runtime_call524288();
        return;
    }
    // 0x808e2fb
    if (v1 <= 0x100000) {
        // 0x808e303
        runtime_call1048576();
        return;
    }
    // 0x808e30a
    if (v1 <= 0x200000) {
        // 0x808e312
        runtime_call2097152();
        return;
    }
    // 0x808e319
    if (v1 <= 0x400000) {
        // 0x808e321
        runtime_call4194304();
        return;
    }
    // 0x808e328
    if (v1 <= 0x800000) {
        // 0x808e330
        runtime_call8388608();
        return;
    }
    // 0x808e337
    if (v1 <= 0x1000000) {
        // 0x808e33f
        runtime_call16777216();
        return;
    }
    // 0x808e346
    if (v1 <= 0x2000000) {
        // 0x808e34e
        runtime_call33554432();
        return;
    }
    // 0x808e355
    if (v1 <= 0x4000000) {
        // 0x808e35d
        runtime_call67108864();
        return;
    }
    // 0x808e364
    if (v1 <= 0x8000000) {
        // 0x808e36c
        runtime_call134217728();
        return;
    }
    // 0x808e373
    if (v1 <= 0x10000000) {
        // 0x808e37b
        runtime_call268435456();
        return;
    }
    // 0x808e382
    if (v1 <= 0x20000000) {
        // 0x808e38a
        runtime_call536870912();
        return;
    }
    // 0x808e391
    if (v1 > 0x40000000) {
        // 0x808e3a0
        runtime_badreflectcall();
        return;
    }
    // 0x808e399
    runtime_call1073741824();
}

// Address range: 0x808e3b0 - 0x808e3cf
void callRet(void) {
    // 0x808e3b0
    runtime_reflectcallmove((struct runtime__type *)g8, (char *)g7, (char *)g9, g5);
}

// Address range: 0x808e3d0 - 0x808e43f
void runtime_call16(void) {
    // 0x808e3d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e440 - 0x808e4af
void runtime_call32(void) {
    // 0x808e440
    abort();
    // UNREACHABLE
}

// Address range: 0x808e4b0 - 0x808e51f
void runtime_call64(void) {
    // 0x808e4b0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e520 - 0x808e5af
void runtime_call128(void) {
    // 0x808e520
    abort();
    // UNREACHABLE
}

// Address range: 0x808e5b0 - 0x808e63f
void runtime_call256(void) {
    // 0x808e5b0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e640 - 0x808e6cf
void runtime_call512(void) {
    // 0x808e640
    abort();
    // UNREACHABLE
}

// Address range: 0x808e6d0 - 0x808e75f
void runtime_call1024(void) {
    // 0x808e6d0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e760 - 0x808e7ef
void runtime_call2048(void) {
    // 0x808e760
    abort();
    // UNREACHABLE
}

// Address range: 0x808e7f0 - 0x808e87f
void runtime_call4096(void) {
    // 0x808e7f0
    abort();
    // UNREACHABLE
}

// Address range: 0x808e880 - 0x808e91f
void runtime_call8192(void) {
    // 0x808e880
    abort();
    // UNREACHABLE
}

// Address range: 0x808e920 - 0x808e9bf
void runtime_call16384(void) {
    // 0x808e920
    abort();
    // UNREACHABLE
}

// Address range: 0x808e9c0 - 0x808ea5f
void runtime_call32768(void) {
    // 0x808e9c0
    abort();
    // UNREACHABLE
}

// Address range: 0x808ea60 - 0x808eaff
void runtime_call65536(void) {
    // 0x808ea60
    abort();
    // UNREACHABLE
}

// Address range: 0x808eb00 - 0x808eb9f
void runtime_call131072(void) {
    // 0x808eb00
    abort();
    // UNREACHABLE
}

// Address range: 0x808eba0 - 0x808ec3f
void runtime_call262144(void) {
    // 0x808eba0
    abort();
    // UNREACHABLE
}

// Address range: 0x808ec40 - 0x808ecdf
void runtime_call524288(void) {
    // 0x808ec40
    abort();
    // UNREACHABLE
}

// Address range: 0x808ece0 - 0x808ed7f
void runtime_call1048576(void) {
    // 0x808ece0
    abort();
    // UNREACHABLE
}

// Address range: 0x808ed80 - 0x808ee1f
void runtime_call2097152(void) {
    // 0x808ed80
    abort();
    // UNREACHABLE
}

// Address range: 0x808ee20 - 0x808eebf
void runtime_call4194304(void) {
    // 0x808ee20
    abort();
    // UNREACHABLE
}

// Address range: 0x808eec0 - 0x808ef5f
void runtime_call8388608(void) {
    // 0x808eec0
    abort();
    // UNREACHABLE
}

// Address range: 0x808ef60 - 0x808efff
void runtime_call16777216(void) {
    // 0x808ef60
    abort();
    // UNREACHABLE
}

// Address range: 0x808f000 - 0x808f09f
void runtime_call33554432(void) {
    // 0x808f000
    abort();
    // UNREACHABLE
}

// Address range: 0x808f0a0 - 0x808f13f
void runtime_call67108864(void) {
    // 0x808f0a0
    abort();
    // UNREACHABLE
}

// Address range: 0x808f140 - 0x808f1df
void runtime_call134217728(void) {
    // 0x808f140
    abort();
    // UNREACHABLE
}

// Address range: 0x808f1e0 - 0x808f27f
void runtime_call268435456(void) {
    // 0x808f1e0
    abort();
    // UNREACHABLE
}

// Address range: 0x808f280 - 0x808f31f
void runtime_call536870912(void) {
    // 0x808f280
    abort();
    // UNREACHABLE
}

// Address range: 0x808f320 - 0x808f3bf
void runtime_call1073741824(void) {
    // 0x808f320
    abort();
    // UNREACHABLE
}

// Address range: 0x808f3c0 - 0x808f3cf
void runtime_procyield(void) {
    // 0x808f3c0
    return;
}

// Address range: 0x808f3d0 - 0x808f3df
void runtime_publicationBarrier(void) {
    // 0x808f3d0
    return;
}

// Address range: 0x808f3e0 - 0x808f3ff
void runtime_jmpdefer(void) {
    // 0x808f3e0
    int32_t v1;
    g8 = v1;
    int32_t v2;
    int32_t * v3 = (int32_t *)(v2 - 4); // 0x808f3eb_0
    uint32_t v4 = *v3; // 0x808f3eb
    g1 = v4 < 5;
    g33 = (4 - v4 & v4) < 0;
    int32_t v5 = v4 - 5; // 0x808f3eb
    g35 = v5 == 0;
    g34 = v5 < 0;
    *v3 = v5;
    int32_t v6 = *(int32_t *)v1; // 0x808f3ef
    g4 = v6;
    ((int32_t (*)())v6)();
}

// Address range: 0x808f400 - 0x808f43f
void gosave(void) {
    // 0x808f400
    abort();
    // UNREACHABLE
}

// Address range: 0x808f440 - 0x808f4bf
void runtime_asmcgocall(void) {
    // 0x808f440
    abort();
    // UNREACHABLE
}

// Address range: 0x808f5a0 - 0x808f5bf
void setg_gcc(void) {
    // 0x808f5a0
    abort();
    // UNREACHABLE
}

// Address range: 0x808f5c0 - 0x808f5df
void runtime_stackcheck(void) {
    // 0x808f5c0
    abort();
    // UNREACHABLE
}

// Address range: 0x808f5e0 - 0x808f5ff
void runtime_getcallerpc(void) {
    // 0x808f5e0
    return;
}

// Address range: 0x808f600 - 0x808f62f
void runtime_cputicks(void) {
    // 0x808f600
    if (*(char *)&runtime_support_sse2 == 1) {
        // 0x808f609
        unknown_808f617();
        unknown_b617fa04();
        // branch -> 0x808f61a
    }
}

// Address range: 0x808f630 - 0x808f65f
void runtime_ldt0setup(void) {
    // 0x808f630
    runtime_setldt();
}

// Address range: 0x808f660 - 0x808f67f
void runtime_emptyfunc(void) {
    // 0x808f660
    abort();
    // UNREACHABLE
}

// Address range: 0x808f6b0 - 0x808f6cf
void runtime_aeshash(void) {
    // 0x808f6b0
    int32_t v1;
    g2 = v1;
    runtime_aeshashbody();
}

// Address range: 0x808f6f0 - 0x808f6f9
void runtime_aeshashbody(void) {
    // 0x808f6f0
    return;
}

// Address range: 0x808f9b0 - 0x808f9cf
void runtime_checkASM(void) {
    // 0x808f9b0
    return;
}

// Address range: 0x808fa10 - 0x808fa2f
void runtime_eqstring(void) {
    int32_t v1;
    g9 = v1;
    int32_t v2;
    g7 = v2;
    if (v1 == v2) {
        // 0x808fa29
        return;
    }
    // 0x808fa1c
    int32_t v3;
    g4 = v3;
    int32_t v4;
    g2 = &v4;
    runtime_memeqbody();
}

// Address range: 0x808fa30 - 0x808fb0f
void runtime_memeqbody(void) {
    int32_t v1 = g4; // 0x808fa30
    int32_t v2 = v1 - 4; // 0x808fa30
    if (v1 < 4) {
        // 0x808faca
        if (v1 == 0) {
            // 0x808fafe
            *(char *)g2 = (char)true;
            return;
        }
        int32_t v3 = -8 * v1;
        int32_t v4; // 0x808fafa
        if ((char)g9 > 252) {
            uint32_t v5 = *(int32_t *)(v2 + g9); // 0x808fae3
            uint32_t v6 = v3 & 24; // 0x808fae7
            if (v6 != 0) {
                // if_808fae7_0_true
                v4 = v5 >> v6;
                // branch -> 0x808fae9
            } else {
                v4 = v5;
            }
        } else {
            // 0x808fadf
            v4 = *(int32_t *)g9;
            // branch -> 0x808fae9
        }
        // 0x808fae9
        int32_t v7;
        int32_t v8; // 0x808fafa
        if ((char)g7 > 252) {
            uint32_t v9 = *(int32_t *)(v2 + g7); // 0x808faf4
            int32_t v10 = v3 & 24; // 0x808faf8
            if (v10 != 0) {
                // if_808faf8_0_true
                v7 = v10;
                v8 = v9 >> v10;
                // branch -> 0x808fafa
            } else {
                v7 = 0;
                v8 = v9;
            }
        } else {
            // 0x808faf0
            v7 = v3 & 24;
            v8 = *(int32_t *)g7;
            // branch -> 0x808fafa
        }
        // 0x808fafa
        bool v11; // 0x808fafe
        if (v7 != 0) {
            // if_808fafc_0_true
            v11 = v8 - v4 << v7 == 0;
            // branch -> 0x808fafe
        } else {
            v11 = v8 == v4;
        }
        // 0x808fafe
        *(char *)g2 = (char)v11;
        return;
    }
  lab_0x808fa39:
    while (true) {
        // 0x808fa39
        if (v1 >= 64) {
            char v12 = *(char *)&runtime_support_sse2; // 0x808fa3e
            if (v12 == 1) {
                bool v13 = v12 == 0; // 0x808fa53
                int32_t v14; // 0x808fa92
                while (true) {
                    // 0x808fa48
                    *(int32_t *)(g10 - 4) = 0;
                    int32_t * v15 = (int32_t *)(g10 - 8); // 0x808fa52_0
                    *v15 = g9;
                    int32_t v16 = g4; // 0x808fa53
                    uint32_t v17 = g8 / 256; // 0x808fa53
                    unsigned char v18 = (char)v16; // 0x808fa53
                    g7 = *v15;
                    int32_t v19 = 0x1000000 * (v16 + (int32_t)v13 + v17) / 0x1000000;
                    int32_t v20 = v17 % 256 & v19 + v17 + (int32_t)(v18 + (char)v13 + (char)v17 <= v18) | v19 & -256; // 0x808fa5d
                    g4 = v20;
                    unknown_808fa98();
                    unknown_808fa9d();
                    unknown_808fa32();
                    if (v17 == v20) {
                        // 0x808fa48
                        v13 = false;
                        // branch -> 0x808fa48
                        continue;
                    } else {
                        // 0x808fa75
                        unknown_808fa5e();
                        uint32_t v21 = unknown_808fa74(); // 0x808fa7b
                        int32_t v22 = g4; // 0x808fa8b
                        unsigned char v23 = *(char *)(v21 % 256 + v22); // 0x808fa8b
                        char * v24 = (char *)(v22 - 0x387cbf3a); // 0x808fa8c_0
                        uint32_t v25 = (int32_t)*v24; // 0x808fa8c
                        *v24 = (char)(v25 / 128 % 2 | 2 * v25);
                        v14 = ((int32_t)v23 | v21 & -256) + 1;
                        g2 = v14;
                        int32_t v26 = g4 - 64; // 0x808fa93
                        g4 = v26;
                        if (g8 != 0xffff) {
                            // break (via goto) -> 0x808fa9e
                            goto lab_0x808fa9e;
                        }
                        v1 = v26;
                        // continue (via goto) -> 0x808fa39
                        goto lab_0x808fa39;
                    }
                }
              lab_0x808fa9e:
                // 0x808fa9e
                *(char *)v14 = 0;
                return;
            }
        }
        int32_t v27 = g9; // 0x808faab
        // branch -> 0x808faa2
        while (true) {
            int32_t v28 = v1 - 4; // 0x808faa2
            if (v1 < 4 || v28 == 0) {
                int32_t v29 = *(int32_t *)(v27 - 4 + v1); // 0x808fabc
                *(char *)g2 = (char)(v29 == *(int32_t *)(v28 + g7));
                return;
            }
            int32_t v30 = g7; // 0x808faa9
            g7 = v30 + 4;
            if (*(int32_t *)v27 != *(int32_t *)v30) {
                // break -> 0x808fab8
                break;
            }
            v27 += 4;
            v1 = v28;
            // continue -> 0x808faa2
        }
        // 0x808fab8
        *(char *)g2 = 0;
        return;
    }
}

// Address range: 0x808fb10 - 0x808fb2f
void runtime_cmpstring(void) {
    int32_t v1;
    g9 = v1;
    int32_t v2;
    g4 = v2;
    int32_t v3;
    g7 = v3;
    int32_t v4;
    g8 = v4;
    int32_t v5;
    g2 = &v5;
    runtime_cmpbody();
}

// Address range: 0x808fb60 - 0x808fc5f
void runtime_cmpbody(void) {
    int32_t v1 = g8; // ebp
    int32_t v2 = g8 - g4; // 0x808fb62
    int32_t v3 = g8; // 0x808fc27
    if (g8 > g4) {
        // 0x808fb66
        v1 = g4;
        v3 = g4;
        // branch -> 0x808fb68
    }
    int32_t v4 = g9; // 0x808fb68
    int32_t v5 = g7; // 0x808fb68
    int32_t v6; // 0x808fc4d
    if (v4 == v5) {
        v6 = v2;
        // 0x808fc49
        *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
        return;
    }
    int32_t v7 = v3 - 4; // 0x808fb70
    if (v3 < 4) {
        int32_t v8 = 8 * v3; // 0x808fbfe
        int32_t v9 = -v8; // 0x808fc05
        if (v8 == 0) {
            v6 = v2;
            // 0x808fc49
            *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
            return;
        }
        int32_t v10 = g2; // 0x808fc09
        int32_t v11;
        int32_t v12;
        int32_t v13; // 0x808fc2f
        bool v14; // 0x808fc1a60
        if (v4 > 0xfffffffc) {
            uint32_t v15 = *(int32_t *)(v7 + v4); // 0x808fc14
            int32_t v16 = v9 & 24; // 0x808fc18
            if (v16 != 0) {
                // 0x808fc1a
                v12 = v16;
                // branch -> if_808fc1a_0_true
                // if_808fc1a_0_true
                v11 = v12;
                v13 = v15 >> v16 << v12;
                v14 = false;
                // branch -> after_if_808fc1a_0
            } else {
                v11 = 0;
                v13 = v15;
                v14 = true;
            }
        } else {
            int32_t v17 = *(int32_t *)v4; // 0x808fc10
            int32_t v18 = v9 & 24;
            if (v18 != 0) {
                v12 = v18;
                // if_808fc1a_0_true
                v11 = v12;
                v13 = v17 << v12;
                v14 = false;
                // branch -> after_if_808fc1a_0
            } else {
                v11 = 0;
                v13 = v17;
                v14 = true;
            }
        }
        // after_if_808fc1a_0
        g2 = v10;
        int32_t v19; // 0x808fc31
        if (v5 > 0xfffffffc) {
            uint32_t v20 = *(int32_t *)(v7 + v5); // 0x808fc27
            if (!v14) {
                // 0x808fc2d
                // branch -> if_808fc2d_0_true
                // if_808fc2d_0_true
                v19 = v20 >> v11 << v11;
                // branch -> after_if_808fc2d_0
            } else {
                v19 = v20;
            }
        } else {
            int32_t v21 = *(int32_t *)v5; // 0x808fc23
            if (!v14) {
                // 0x808fc2d
                // branch -> if_808fc2d_0_true
                // if_808fc2d_0_true
                v19 = v21 << v11;
                // branch -> after_if_808fc2d_0
            } else {
                v19 = v21;
            }
        }
        int32_t v22 = llvm_bswap_i32(v13); // 0x808fc2f
        int32_t v23 = llvm_bswap_i32(v19); // 0x808fc31
        int32_t v24 = llvm_bswap_i32(v19 ^ v13);
        if (v22 == v23) {
            v6 = v2;
            // 0x808fc49
            *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
            return;
        }
        // 0x808fc37
        int32_t v25; // 0x808fc3a
        if (v13 == v19) {
            // if_808fc37_0_true
            v25 = v9;
            // branch -> after_if_808fc37_0
        } else {
            // if_808fc37_0_false
            v25 = 31 - llvm_ctlz_i32(v24, false);
            // branch -> after_if_808fc37_0
        }
        uint32_t v26 = v25 % 32; // 0x808fc3a
        if (v26 == 0) {
            // after_if_808fc3a_0
            *(int32_t *)v10 = (-((v22 % 2)) & 2) - 1;
            return;
        }
        // if_808fc3a_0_true
        if (v26 == 1) {
            // if_808fc3a_3_true
            // branch -> after_if_808fc3a_0
        }
        // after_if_808fc3a_0
        *(int32_t *)v10 = (-(((v22 >> v26) % 2)) & 2) - 1;
        return;
    }
    int32_t v27 = v5;
    int32_t v28 = v4;
    int32_t v29 = v3;
    uint32_t v30; // 0x808fbef
    int32_t v31;
    int32_t v32; // 0x808fbe6
    int32_t v33; // 0x808fbe8
    int32_t v34; // 0x808fbef
    int32_t v35; // 0x808fbc7
    int32_t v36; // 0x808fbc9
    int32_t v37; // 0x808fbe6
    int32_t v38; // 0x808fbde89
    int32_t v39; // 0x808fbcf90
    int32_t v40; // 0x808fbef
    int32_t v41;
    int32_t v42; // 0x808fbc286
    int32_t v43; // 0x808fbc291
    int32_t v44; // 0x808fbda
    int32_t v45; // 0x808fbde
    if (*(char *)&runtime_support_sse2 == 1) {
        // 0x808fb82
        if (v3 >= 16) {
            while (true) {
                // 0x808fb87
                *(int32_t *)(g10 - 4) = 0;
                uint32_t v46 = g2; // 0x808fb95
                g2 = (int32_t)*(char *)(v46 % 256 + g4) | v46 & -256;
                char * v47 = (char *)(v1 + 11); // 0x808fb9c_0
                *v47 = (char)(v2 / 256 + (int32_t)*v47);
                int32_t v48 = g9 + 16; // 0x808fb9f
                g9 = v48;
                int32_t v49 = g7 + 16; // 0x808fba2
                g7 = v49;
                int32_t v50 = v1 - 16; // 0x808fba5
                v1 = v50;
                if (v50 < 16) {
                    v27 = v49;
                    v28 = v48;
                    v29 = v50;
                    // break -> 0x808fbc2
                    break;
                }
                // continue -> 0x808fb87
            }
            // 0x808fbc2
            v42 = v29 - 4;
            v41 = v29;
            if (v29 < 4 || v42 == 0) {
                // 0x808fbda
                v44 = *(int32_t *)(v28 - 4 + v41);
                v45 = *(int32_t *)(v27 - 4 + v41);
                if (v44 == v45) {
                    // 0x808fbda
                    v6 = v2;
                    // branch -> 0x808fc49
                    // 0x808fc49
                    *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
                    return;
                }
                v33 = v45;
                v32 = v44;
                // 0x808fbe6
                v37 = llvm_bswap_i32(v32);
                v31 = llvm_bswap_i32(v32 ^ v33);
                if (v32 == v33) {
                    // if_808fbec_0_true
                    v34 = v31;
                    // branch -> after_if_808fbec_0
                } else {
                    // if_808fbec_0_false
                    v34 = 31 - llvm_ctlz_i32(v31, false);
                    // branch -> after_if_808fbec_0
                }
                // after_if_808fbec_0
                v30 = v34 % 32;
                if (v30 == 0) {
                    // after_if_808fbef_0
                    *(int32_t *)g2 = (-((v37 % 2)) & 2) - 1;
                    return;
                }
                // if_808fbef_0_true
                if (v30 == 1) {
                    // if_808fbef_3_true
                    // branch -> after_if_808fbef_0
                }
                // after_if_808fbef_0
                *(int32_t *)g2 = (-(((v37 >> v30) % 2)) & 2) - 1;
                return;
            }
            v43 = v42;
            v39 = v28;
            v38 = v27;
            int32_t v51; // 0x808fbcf
            int32_t v52; // 0x808fbd2
            while (true) {
                // 0x808fbc7
                v35 = *(int32_t *)v39;
                v36 = *(int32_t *)v38;
                if (v35 == v36) {
                  lab_0x808fbcf:
                    // 0x808fbcf
                    v51 = v39 + 4;
                    v52 = v38 + 4;
                    int32_t v53 = v43 - 4; // 0x808fbc2
                    if (v43 < 4 || v53 == 0) {
                        v41 = v43;
                        // break -> 0x808fbda
                        break;
                    }
                    v43 = v53;
                    v39 = v51;
                    v38 = v52;
                    // continue -> 0x808fbc7
                    continue;
                } else {
                    // 0x808fbe6
                    v33 = v36;
                    v32 = v35;
                    // branch -> 0x808fbe6
                }
                // 0x808fbe6
                v37 = llvm_bswap_i32(v32);
                v31 = llvm_bswap_i32(v32 ^ v33);
                if (v32 == v33) {
                    // if_808fbec_0_true
                    v34 = v31;
                    // branch -> after_if_808fbec_0
                } else {
                    // if_808fbec_0_false
                    v34 = 31 - llvm_ctlz_i32(v31, false);
                    // branch -> after_if_808fbec_0
                }
                // after_if_808fbec_0
                v30 = v34 % 32;
                if (v30 == 0) {
                    // after_if_808fbef_0
                    *(int32_t *)g2 = (-((v37 % 2)) & 2) - 1;
                    return;
                }
                // if_808fbef_0_true
                v40 = v37 >> v30;
                if (v30 == 1) {
                    // if_808fbef_3_true
                    // branch -> after_if_808fbef_0
                    // after_if_808fbef_0
                    *(int32_t *)g2 = (-((v40 % 2)) & 2) - 1;
                    return;
                }
                // after_if_808fbef_0
                *(int32_t *)g2 = (-((v40 % 2)) & 2) - 1;
                return;
            }
            // 0x808fbda
            v44 = *(int32_t *)(v51 - 4 + v41);
            v45 = *(int32_t *)(v52 - 4 + v41);
            if (v44 == v45) {
                // 0x808fbda
                v6 = v2;
                // branch -> 0x808fc49
                // 0x808fc49
                *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
                return;
            }
            v33 = v45;
            v32 = v44;
            // 0x808fbe6
            v37 = llvm_bswap_i32(v32);
            v31 = llvm_bswap_i32(v32 ^ v33);
            if (v32 == v33) {
                // if_808fbec_0_true
                v34 = v31;
                // branch -> after_if_808fbec_0
            } else {
                // if_808fbec_0_false
                v34 = 31 - llvm_ctlz_i32(v31, false);
                // branch -> after_if_808fbec_0
            }
            // after_if_808fbec_0
            v30 = v34 % 32;
            if (v30 == 0) {
                // after_if_808fbef_0
                *(int32_t *)g2 = (-((v37 % 2)) & 2) - 1;
                return;
            }
            // if_808fbef_0_true
            if (v30 == 1) {
                // if_808fbef_3_true
                // branch -> after_if_808fbef_0
            }
            // after_if_808fbef_0
            *(int32_t *)g2 = (-(((v37 >> v30) % 2)) & 2) - 1;
            return;
        }
        v27 = v5;
        v28 = v4;
        v29 = v3;
    }
    // 0x808fbc2
    v42 = v29 - 4;
    v41 = v29;
    if (v29 >= 4 && v42 != 0) {
        v43 = v42;
        v39 = v28;
        v38 = v27;
        while (true) {
            // 0x808fbc7
            v35 = *(int32_t *)v39;
            v36 = *(int32_t *)v38;
            if (v35 == v36) {
                goto lab_0x808fbcf;
            }
            // 0x808fbe6
            v33 = v36;
            v32 = v35;
            // branch -> 0x808fbe6
            // 0x808fbe6
            v37 = llvm_bswap_i32(v32);
            v31 = llvm_bswap_i32(v32 ^ v33);
            if (v32 == v33) {
                // if_808fbec_0_true
                v34 = v31;
                // branch -> after_if_808fbec_0
            } else {
                // if_808fbec_0_false
                v34 = 31 - llvm_ctlz_i32(v31, false);
                // branch -> after_if_808fbec_0
            }
            // after_if_808fbec_0
            v30 = v34 % 32;
            if (v30 == 0) {
                // after_if_808fbef_0
                *(int32_t *)g2 = (-((v37 % 2)) & 2) - 1;
                return;
            }
            // if_808fbef_0_true
            v40 = v37 >> v30;
            if (v30 == 1) {
                // if_808fbef_3_true
                // branch -> after_if_808fbef_0
                // after_if_808fbef_0
                *(int32_t *)g2 = (-((v40 % 2)) & 2) - 1;
                return;
            }
            // after_if_808fbef_0
            *(int32_t *)g2 = (-((v40 % 2)) & 2) - 1;
            return;
        }
    }
    // 0x808fbda
    v44 = *(int32_t *)(v28 - 4 + v41);
    v45 = *(int32_t *)(v27 - 4 + v41);
    if (v44 == v45) {
        // 0x808fbda
        v6 = v2;
        // branch -> 0x808fc49
        // 0x808fc49
        *(int32_t *)g2 = (int32_t)(v6 != 0) + (v6 >> 31 & 2);
        return;
    }
    v33 = v45;
    v32 = v44;
    // 0x808fbe6
    v37 = llvm_bswap_i32(v32);
    v31 = llvm_bswap_i32(v32 ^ v33);
    if (v32 == v33) {
        // if_808fbec_0_true
        v34 = v31;
        // branch -> after_if_808fbec_0
    } else {
        // if_808fbec_0_false
        v34 = 31 - llvm_ctlz_i32(v31, false);
        // branch -> after_if_808fbec_0
    }
    // after_if_808fbec_0
    v30 = v34 % 32;
    if (v30 == 0) {
        // after_if_808fbef_0
        *(int32_t *)g2 = (-((v37 % 2)) & 2) - 1;
        return;
    }
    // if_808fbef_0_true
    if (v30 == 1) {
        // if_808fbef_3_true
        // branch -> after_if_808fbef_0
    }
    // after_if_808fbef_0
    *(int32_t *)g2 = (-(((v37 >> v30) % 2)) & 2) - 1;
}

// Address range: 0x808fc60 - 0x808fc6f
void runtime_return0(void) {
    // 0x808fc60
    return;
}

// Address range: 0x808fc80 - 0x808fc8f
void runtime_prefetcht0(void) {
    // 0x808fc80
    return;
}

// Address range: 0x808fc90 - 0x808fc9f
void runtime_prefetcht1(void) {
    // 0x808fc90
    return;
}

// Address range: 0x808fca0 - 0x808fcaf
void runtime_prefetcht2(void) {
    // 0x808fca0
    return;
}

// Address range: 0x808fcb0 - 0x808fcbf
void runtime_prefetchnta(void) {
    // 0x808fcb0
    return;
}

// Address range: 0x808fcc0 - 0x808fcdf
void runtime_uint32tofloat64(void) {
    // 0x808fcc0
    return;
}

// Address range: 0x808fce0 - 0x808fd0f
void runtime_float64touint32(void) {
    // 0x808fce0
    return;
}

// Address range: 0x808fd10 - 0x808fd4f
void runtime_duffzero(void) {
    // 0x808fd10
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd10
    int32_t v2 = v1 + g7; // 0x808fd10
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd11
    *(int32_t *)v3 = g2;
    int32_t v4 = v3 + v1; // 0x808fd12
    *(int32_t *)v4 = g2;
    int32_t v5 = v4 + v1; // 0x808fd13
    *(int32_t *)v5 = g2;
    int32_t v6 = v5 + v1; // 0x808fd14
    *(int32_t *)v6 = g2;
    int32_t v7 = v6 + v1; // 0x808fd15
    *(int32_t *)v7 = g2;
    int32_t v8 = v7 + v1; // 0x808fd16
    *(int32_t *)v8 = g2;
    int32_t v9 = v8 + v1; // 0x808fd17
    *(int32_t *)v9 = g2;
    int32_t v10 = v9 + v1; // 0x808fd18
    *(int32_t *)v10 = g2;
    int32_t v11 = v10 + v1; // 0x808fd19
    *(int32_t *)v11 = g2;
    int32_t v12 = v11 + v1; // 0x808fd1a
    *(int32_t *)v12 = g2;
    int32_t v13 = v12 + v1; // 0x808fd1b
    *(int32_t *)v13 = g2;
    int32_t v14 = v13 + v1; // 0x808fd1c
    *(int32_t *)v14 = g2;
    int32_t v15 = v14 + v1; // 0x808fd1d
    *(int32_t *)v15 = g2;
    int32_t v16 = v15 + v1; // 0x808fd1e
    *(int32_t *)v16 = g2;
    int32_t v17 = v16 + v1; // 0x808fd1f
    *(int32_t *)v17 = g2;
    int32_t v18 = v17 + v1; // 0x808fd20
    *(int32_t *)v18 = g2;
    int32_t v19 = v18 + v1; // 0x808fd21
    *(int32_t *)v19 = g2;
    int32_t v20 = v19 + v1; // 0x808fd22
    *(int32_t *)v20 = g2;
    int32_t v21 = v20 + v1; // 0x808fd23
    *(int32_t *)v21 = g2;
    int32_t v22 = v1 + v21; // 0x808fd24
    *(int32_t *)v22 = g2;
    int32_t v23 = v22 + v1; // 0x808fd25
    *(int32_t *)v23 = g2;
    int32_t v24 = v23 + v1; // 0x808fd26
    *(int32_t *)v24 = g2;
    int32_t v25 = v24 + v1; // 0x808fd27
    *(int32_t *)v25 = g2;
    int32_t v26 = v25 + v1; // 0x808fd28
    *(int32_t *)v26 = g2;
    int32_t v27 = v26 + v1; // 0x808fd29
    *(int32_t *)v27 = g2;
    int32_t v28 = v27 + v1; // 0x808fd2a
    *(int32_t *)v28 = g2;
    int32_t v29 = v28 + v1; // 0x808fd2b
    *(int32_t *)v29 = g2;
    int32_t v30 = v29 + v1; // 0x808fd2c
    *(int32_t *)v30 = g2;
    int32_t v31 = v30 + v1; // 0x808fd2d
    *(int32_t *)v31 = g2;
    int32_t v32 = v31 + v1; // 0x808fd2e
    *(int32_t *)v32 = g2;
    int32_t v33 = v32 + v1; // 0x808fd2f
    *(int32_t *)v33 = g2;
    int32_t v34 = v33 + v1; // 0x808fd30
    *(int32_t *)v34 = g2;
    int32_t v35 = v34 + v1; // 0x808fd31
    *(int32_t *)v35 = g2;
    int32_t v36 = v35 + v1; // 0x808fd32
    *(int32_t *)v36 = g2;
    int32_t v37 = v36 + v1; // 0x808fd33
    *(int32_t *)v37 = g2;
    int32_t v38 = v37 + v1; // 0x808fd34
    *(int32_t *)v38 = g2;
    int32_t v39 = v38 + v1; // 0x808fd35
    *(int32_t *)v39 = g2;
    int32_t v40 = v39 + v1; // 0x808fd36
    *(int32_t *)v40 = g2;
    int32_t v41 = v40 + v1; // 0x808fd37
    *(int32_t *)v41 = g2;
    int32_t v42 = g6 ? -4 : 4; // 0x808fd38
    int32_t v43 = v42 + v41; // 0x808fd38
    *(int32_t *)v43 = g2;
    int32_t v44 = v43 + v42; // 0x808fd39
    *(int32_t *)v44 = g2;
    int32_t v45 = v44 + v42; // 0x808fd3a
    *(int32_t *)v45 = g2;
    int32_t v46 = v45 + v42; // 0x808fd3b
    *(int32_t *)v46 = g2;
    int32_t v47 = v46 + v42; // 0x808fd3c
    *(int32_t *)v47 = g2;
    int32_t v48 = v47 + v42; // 0x808fd3d
    *(int32_t *)v48 = g2;
    int32_t v49 = v48 + v42; // 0x808fd3e
    *(int32_t *)v49 = g2;
    int32_t v50 = v49 + v42; // 0x808fd3f
    *(int32_t *)v50 = g2;
    int32_t v51 = v50 + v42; // 0x808fd40
    *(int32_t *)v51 = g2;
    int32_t v52 = v51 + v42; // 0x808fd41
    *(int32_t *)v52 = g2;
    int32_t v53 = v52 + v42; // 0x808fd42
    *(int32_t *)v53 = g2;
    int32_t v54 = v53 + v42; // 0x808fd43
    *(int32_t *)v54 = g2;
    int32_t v55 = v54 + v42; // 0x808fd44
    *(int32_t *)v55 = g2;
    int32_t v56 = v55 + v42; // 0x808fd45
    *(int32_t *)v56 = g2;
    int32_t v57 = v56 + v42; // 0x808fd46
    *(int32_t *)v57 = g2;
    int32_t v58 = v57 + v42; // 0x808fd47
    *(int32_t *)v58 = g2;
    int32_t v59 = v58 + v42; // 0x808fd48
    *(int32_t *)v59 = g2;
    int32_t v60 = v59 + v42; // 0x808fd49
    *(int32_t *)v60 = g2;
    int32_t v61 = v60 + v42; // 0x808fd4a
    *(int32_t *)v61 = g2;
    int32_t v62 = v61 + v42; // 0x808fd4b
    *(int32_t *)v62 = g2;
    int32_t v63 = v42 + v62; // 0x808fd4c
    *(int32_t *)v63 = g2;
    int32_t v64 = v63 + v42; // 0x808fd4d
    *(int32_t *)v64 = g2;
    *(int32_t *)(v64 + v42) = g2;
}

// Address range: 0x808fd5c - 0x808fd5f
void function_808fd5c(void) {
    // 0x808fd5c
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd5c
    int32_t v2 = v1 + g7; // 0x808fd5c
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd5d
    *(int32_t *)v3 = g2;
    *(int32_t *)(v3 + v1) = g2;
}

// Address range: 0x808fd60 - 0x808fd6c
void function_808fd60(void) {
    // 0x808fd60
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd60
    int32_t v2 = v1 + g7; // 0x808fd60
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd61
    *(int32_t *)v3 = g2;
    int32_t v4 = v3 + v1; // 0x808fd62
    *(int32_t *)v4 = g2;
    int32_t v5 = v4 + v1; // 0x808fd63
    *(int32_t *)v5 = g2;
    int32_t v6 = v5 + v1; // 0x808fd64
    *(int32_t *)v6 = g2;
    int32_t v7 = v6 + v1; // 0x808fd65
    *(int32_t *)v7 = g2;
    int32_t v8 = v7 + v1; // 0x808fd66
    *(int32_t *)v8 = g2;
    int32_t v9 = v8 + v1; // 0x808fd67
    *(int32_t *)v9 = g2;
    int32_t v10 = v9 + v1; // 0x808fd68
    *(int32_t *)v10 = g2;
    int32_t v11 = v10 + v1; // 0x808fd69
    *(int32_t *)v11 = g2;
    int32_t v12 = v11 + v1; // 0x808fd6a
    *(int32_t *)v12 = g2;
    *(int32_t *)(v12 + v1) = g2;
}

// Address range: 0x808fd6d - 0x808fd6f
void function_808fd6d(void) {
    // 0x808fd6d
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd6d
    int32_t v2 = v1 + g7; // 0x808fd6d
    *(int32_t *)v2 = g2;
    *(int32_t *)(v2 + v1) = g2;
}

// Address range: 0x808fd70 - 0x808fd76
void function_808fd70(void) {
    // 0x808fd70
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd70
    int32_t v2 = v1 + g7; // 0x808fd70
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd71
    *(int32_t *)v3 = g2;
    int32_t v4 = v3 + v1; // 0x808fd72
    *(int32_t *)v4 = g2;
    int32_t v5 = v4 + v1; // 0x808fd73
    *(int32_t *)v5 = g2;
    int32_t v6 = v5 + v1; // 0x808fd74
    *(int32_t *)v6 = g2;
    *(int32_t *)(v6 + v1) = g2;
}

// Address range: 0x808fd77 - 0x808fd7f
void function_808fd77(void) {
    // 0x808fd77
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd77
    int32_t v2 = v1 + g7; // 0x808fd77
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd78
    *(int32_t *)v3 = g2;
    int32_t v4 = v3 + v1; // 0x808fd79
    *(int32_t *)v4 = g2;
    int32_t v5 = v4 + v1; // 0x808fd7a
    *(int32_t *)v5 = g2;
    int32_t v6 = v5 + v1; // 0x808fd7b
    *(int32_t *)v6 = g2;
    int32_t v7 = v6 + v1; // 0x808fd7c
    *(int32_t *)v7 = g2;
    int32_t v8 = v7 + v1; // 0x808fd7d
    *(int32_t *)v8 = g2;
    *(int32_t *)(v8 + v1) = g2;
}

// Address range: 0x808fd85 - 0x808fd85
void function_808fd85(void) {
    // 0x808fd85
    *(int32_t *)g7 = g2;
}

// Address range: 0x808fd86 - 0x808fd86
void function_808fd86(void) {
    // 0x808fd86
    *(int32_t *)g7 = g2;
}

// Address range: 0x808fd87 - 0x808fd87
void function_808fd87(void) {
    // 0x808fd87
    *(int32_t *)g7 = g2;
}

// Address range: 0x808fd89 - 0x808fd89
void function_808fd89(void) {
    // 0x808fd89
    *(int32_t *)g7 = g2;
}

// Address range: 0x808fd8a - 0x808fd8a
void function_808fd8a(void) {
    // 0x808fd8a
    *(int32_t *)g7 = g2;
}

// Address range: 0x808fd8b - 0x808fd9f
void function_808fd8b(void) {
    // 0x808fd8b
    *(int32_t *)g7 = g2;
    int32_t v1 = g6 ? -4 : 4; // 0x808fd8b
    int32_t v2 = v1 + g7; // 0x808fd8b
    *(int32_t *)v2 = g2;
    int32_t v3 = v2 + v1; // 0x808fd8c
    *(int32_t *)v3 = g2;
    int32_t v4 = v3 + v1; // 0x808fd8d
    *(int32_t *)v4 = g2;
    *(int32_t *)(v4 + v1) = g2;
}

// Address range: 0x8090160 - 0x80901eb
void function_8090160(void) {
    // 0x8090160
    *(int32_t *)g7 = *(int32_t *)g9;
    int32_t v1 = g7 + 4; // 0x8090167
    int32_t v2 = g9 + 4; // 0x809016a
    *(int32_t *)v1 = *(int32_t *)v2;
    int32_t v3 = v1 + 4; // 0x8090171
    int32_t v4 = v2 + 4; // 0x8090174
    *(int32_t *)v3 = *(int32_t *)v4;
    int32_t v5 = v3 + 4; // 0x809017b
    int32_t v6 = v4 + 4; // 0x809017e
    *(int32_t *)v5 = *(int32_t *)v6;
    int32_t v7 = v5 + 4; // 0x8090185
    int32_t v8 = v6 + 4; // 0x8090188
    *(int32_t *)v7 = *(int32_t *)v8;
    int32_t v9 = v7 + 4; // 0x809018f
    int32_t v10 = v8 + 4; // 0x8090192
    *(int32_t *)v9 = *(int32_t *)v10;
    int32_t v11 = v9 + 4; // 0x8090199
    int32_t v12 = v10 + 4; // 0x809019c
    *(int32_t *)v11 = *(int32_t *)v12;
    int32_t v13 = v11 + 4; // 0x80901a3
    int32_t v14 = v12 + 4; // 0x80901a6
    *(int32_t *)v13 = *(int32_t *)v14;
    int32_t v15 = v13 + 4; // 0x80901ad
    int32_t v16 = v14 + 4; // 0x80901b0
    *(int32_t *)v15 = *(int32_t *)v16;
    int32_t v17 = v15 + 4; // 0x80901b7
    int32_t v18 = v16 + 4; // 0x80901ba
    *(int32_t *)v17 = *(int32_t *)v18;
    int32_t v19 = v17 + 4; // 0x80901c1
    int32_t v20 = v18 + 4; // 0x80901c4
    *(int32_t *)v19 = *(int32_t *)v20;
    int32_t v21 = v19 + 4; // 0x80901cb
    int32_t v22 = v20 + 4; // 0x80901ce
    *(int32_t *)v21 = *(int32_t *)v22;
    int32_t v23 = v21 + 4; // 0x80901d5
    int32_t v24 = v22 + 4; // 0x80901d8
    *(int32_t *)v23 = *(int32_t *)v24;
    *(int32_t *)(v23 + 4) = *(int32_t *)(v24 + 4);
}

// Address range: 0x809025a - 0x8090263
void function_809025a(void) {
    // 0x809025a
    *(int32_t *)g7 = *(int32_t *)g9;
}

// Address range: 0x809026e - 0x8090277
void function_809026e(void) {
    // 0x809026e
    *(int32_t *)g7 = *(int32_t *)g9;
}

// Address range: 0x8090278 - 0x80902af
void function_8090278(void) {
    // 0x8090278
    *(int32_t *)g7 = *(int32_t *)g9;
    int32_t v1 = g7 + 4; // 0x809027f
    int32_t v2 = g9 + 4; // 0x8090282
    *(int32_t *)v1 = *(int32_t *)v2;
    int32_t v3 = v1 + 4; // 0x8090289
    int32_t v4 = v2 + 4; // 0x809028c
    *(int32_t *)v3 = *(int32_t *)v4;
    *(int32_t *)(v3 + 4) = *(int32_t *)(v4 + 4);
}

// Address range: 0x80902b0 - 0x809048f
void runtime_memclrNoHeapPointers(void) {
    // 0x80902b0
    int32_t v1;
    int32_t v2 = 0x10000 * v1 / 0x10000;
    int32_t v3;
    int32_t v4 = 0x10000 * v3 / 0x10000;
    int32_t v5 = 0; // eax
    char * v6 = (char *)v2;
    // branch -> 0x80902ba
    while (true) {
        // 0x80902ba
        if (v4 == 0) {
            // 0x80903ae
            return;
        }
        // 0x80902c2
        if (v4 < 3) {
            // 0x80903a7
            *v6 = (char)v5;
            *(char *)(v2 - 1 + v4) = (char)v5;
            return;
        }
        // 0x80902cb
        if (v4 < 4) {
            // 0x80903af
            *(int16_t *)v2 = (int16_t)v5;
            *(char *)(v2 + 2) = (char)v5;
            return;
        }
        // 0x80902d4
        if (v4 == 4) {
            // 0x80903b6
            *(int32_t *)v2 = v5;
            return;
        }
        // 0x80902da
        if (v4 < 9) {
            // 0x80903b9
            *(int32_t *)v2 = v5;
            *(int32_t *)(v2 - 4 + v4) = v5;
            return;
        }
        // 0x80902e3
        if (v4 < 17) {
            // 0x80903c0
            *(int32_t *)v2 = v5;
            *(int32_t *)(v2 + 4) = v5;
            *(int32_t *)(v2 - 8 + v4) = v5;
            *(int32_t *)(v2 - 4 + v4) = v5;
            return;
        }
        // 0x80902ec
        if (*(char *)&runtime_support_sse2 == 1) {
            char * v7 = (char *)v5; // 0x8090303_0
            *v7 = (char)((int32_t)*v7 + v5);
            char * v8 = (char *)(v4 - 0x79f0bf05); // 0x8090305_0
            *v8 = (char)(v5 + (int32_t)*v8);
            return;
        }
        // 0x8090473
        memset(v6, v5, v4 / 4);
        int32_t v9 = v4 % 4; // 0x809047a
        if (v9 == 0) {
            // break -> 0x8090483
            break;
        }
        v4 = v9;
        // continue -> 0x80902ba
    }
}

// Address range: 0x8090490 - 0x809062f
void runtime_memmove(void) {
    int32_t v1;
    int32_t v2 = 0x1000000 * v1;
    if ((v2 || 0xffffff) < 0x1ffffff) {
        // 0x809055b
        return;
    }
    int32_t v3 = v2 / 0x1000000;
    while (true) {
        // 0x80904a4
        int32_t v4;
        int32_t v5;
        if (v3 < 2 || v3 == 2) {
            // 0x809054e
            *(char *)v4 = *(char *)v5;
            *(char *)(v4 - 1 + v3) = *(char *)(v3 - 1 + v5);
            return;
        }
        int32_t v6 = v3 - 4; // 0x80904ad
        if (v3 < 4) {
            // 0x809055c
            *(int16_t *)v4 = *(int16_t *)v5;
            *(char *)(v4 + 2) = *(char *)(v5 + 2);
            return;
        }
        // 0x80904b6
        if (v6 == 0) {
            // 0x8090569
            *(int32_t *)v4 = *(int32_t *)v5;
            return;
        }
        int32_t v7 = v3 - 8; // 0x80904bc
        if (v3 < 8 || v7 == 0) {
            // 0x809056e
            *(int32_t *)v4 = *(int32_t *)v5;
            *(int32_t *)(v4 - 4 + v3) = *(int32_t *)(v6 + v5);
            return;
        }
        // 0x80904c5
        if (v3 < 16 || v3 == 16) {
            // 0x809057b
            *(int32_t *)v4 = *(int32_t *)v5;
            *(int32_t *)(v4 + 4) = *(int32_t *)(v5 + 4);
            *(int32_t *)(v4 - 8 + v3) = *(int32_t *)(v7 + v5);
            *(int32_t *)(v4 - 4 + v3) = *(int32_t *)(v6 + v5);
            return;
        }
        // 0x80904ce
        uint32_t v8; // 0x80904f5
        uint32_t v9; // 0x80904f5
        if (*(char *)&runtime_support_sse2 == 1) {
            // 0x80904d7
            unsigned char v10; // 0x80905b3
            char v11; // 0x80905c8
            bool v12; // 0x80905b343
            bool v13; // of
            int32_t v14; // 0x80905b9
            int32_t v15; // 0x80905b3
            int32_t v16; // 0x80905c8
            bool v17; // sf
            int32_t v18;
            int32_t v19; // 0x80905c8
            bool v20; // 0x80905cb
            uint32_t v21; // 0x80905b3
            uint32_t v22; // 0x80905b3
            uint32_t v23; // 0x80905b3
            int32_t v24; // 0x80905b3
            int32_t v25; // 0x80905b342
            bool v26; // 0x80905cb
            bool v27; // 0x80905cb
            uint32_t v28; // 0x80905b3
            uint32_t v29; // 0x80905c8
            bool v30; // 0x80905c8
            unsigned char v31; // 0x80905b3
            char v32; // 0x80905c8
            char v33; // 0x80905b3
            char v34; // 0x80905c8
            bool v35; // zf
            if (v3 < 32 || v3 == 32) {
                // 0x8090596
                v18 = 0;
                int32_t v36 = &v18; // 0x8090599_0
                if (v36 < 1 ^ (v36 & -v36) < 0) {
                    // 0x80905a8
                    return;
                }
            } else {
                // 0x80904e0
                if (v3 < 64 || v3 == 64) {
                    // 0x80905ae
                    // branch -> 0x80905ae
                    // 0x80905ae
                    v28 = g8 / 256;
                    v33 = v28;
                    v12 = v3 < 64;
                    v25 = v3;
                    v31 = (char)v25;
                    v10 = (char)v12 + v33 + v31;
                    v21 = v25 + v28 + (int32_t)v12;
                    v15 = 0x1000000 * v21;
                    v22 = v25 & -256;
                    v23 = v21 % 256;
                    v24 = v23 | v22;
                    v14 = g5 - 1;
                    // branch -> 0x80905ae
                    while (v14 != 0 && v15 != 0) {
                        // 0x80905ae
                        v12 = v10 <= v31;
                        v25 = v24;
                        v31 = (char)v25;
                        v10 = (char)v12 + v33 + v31;
                        v21 = v25 + v28 + (int32_t)v12;
                        v15 = 0x1000000 * v21;
                        v22 = v25 & -256;
                        v23 = v21 % 256;
                        v24 = v23 | v22;
                        v14--;
                        // continue -> 0x80905ae
                    }
                    // 0x80905bb
                    v13 = ((v10 ^ v31) & (v10 ^ v33)) < 0;
                    v35 = v15 == 0;
                    v17 = v15 < 0;
                    g5 = v14;
                    v27 = v15 == 0;
                    v26 = ((v10 ^ v31) & (v10 ^ v33)) < 0;
                    v20 = v15 < 0;
                    if (v22 <= v23) {
                        // 0x80905c4
                        unknown_8090617();
                        v19 = v24;
                        v29 = g8 / 256;
                        v30 = v10 <= v31;
                        v32 = v19;
                        v34 = v29;
                        v11 = v34 + v32 + (char)v30;
                        v13 = ((v11 ^ v32) & (v11 ^ v34)) < 0;
                        v16 = 0x1000000 * (v29 + v19 + (int32_t)v30);
                        v35 = v16 == 0;
                        v17 = v16 < 0;
                        v27 = v16 == 0;
                        v26 = ((v11 ^ v32) & (v11 ^ v34)) < 0;
                        v20 = v16 < 0;
                        // branch -> 0x80905cb
                    }
                    // 0x80905cb
                    if (v27 || v26 ^ v20) {
                        // 0x80905cd
                        unknown_80905c3();
                        if (v17 ^ v13 || v35) {
                            // 0x80905d3
                            return;
                        }
                        // 0x809062f
                        return;
                    }
                    // 0x80905cb
                    // branch -> 0x8090621
                    // 0x8090621
                    unknown_809061a();
                    return;
                }
                // 0x80904e9
                if (v3 < 128 || v3 == 128) {
                    // 0x80905d6
                    v18 = 0;
                    unknown_809068a();
                    // branch -> 0x8090621
                    // 0x8090621
                    unknown_809061a();
                    return;
                }
                // 0x80904f5
                v8 = v5;
                v9 = v4;
                int32_t v37; // 0x8090545
                if (v8 <= v9) {
                  lab_0x8090521:;
                    uint32_t v38 = v8 + v3; // 0x8090523
                    if (v38 > v9) {
                        int32_t v39 = v9 + v3; // 0x8090529
                        v3 %= 4;
                        g5 = (int32_t)memcpy((char *)(v39 - 4), (char *)(v38 - 4), v3 / 4);
                        v37 = v3;
                        v4 = v39 - v37;
                        v5 = v38 - v37;
                        // branch -> 0x809049c
                      lab_0x809049c:
                        // 0x809049c
                        if (v37 == 0) {
                            // break -> 0x809055b
                            break;
                        }
                        v3 = v37;
                        // continue -> 0x80904a4
                        continue;
                    }
                }
              lab_0x80904f9:
                // 0x80904f9
                if (*(char *)&runtime_support_erms == 1) {
                    int32_t v40 = v9 | v8; // 0x8090504
                    g2 = v40;
                    if (v40 != 3) {
                        // 0x809050d
                        memcpy((char *)v9, (char *)v8, v3);
                        return;
                    }
                }
                // 0x8090512
                v3 %= 4;
                g5 = (int32_t)memcpy((char *)v9, (char *)v8, v3 / 4);
                v37 = v3;
                // branch -> 0x809049c
                goto lab_0x809049c;
            }
            // 0x80905ae
            v28 = g8 / 256;
            v33 = v28;
            v12 = v3 < 32;
            v25 = v3;
            v31 = (char)v25;
            v10 = (char)v12 + v33 + v31;
            v21 = v25 + v28 + (int32_t)v12;
            v15 = 0x1000000 * v21;
            v22 = v25 & -256;
            v23 = v21 % 256;
            v24 = v23 | v22;
            v14 = g5 - 1;
            // branch -> 0x80905ae
            while (v14 != 0 && v15 != 0) {
                // 0x80905ae
                v12 = v10 <= v31;
                v25 = v24;
                v31 = (char)v25;
                v10 = (char)v12 + v33 + v31;
                v21 = v25 + v28 + (int32_t)v12;
                v15 = 0x1000000 * v21;
                v22 = v25 & -256;
                v23 = v21 % 256;
                v24 = v23 | v22;
                v14--;
                // continue -> 0x80905ae
            }
            // 0x80905bb
            v13 = ((v10 ^ v31) & (v10 ^ v33)) < 0;
            v35 = v15 == 0;
            v17 = v15 < 0;
            g5 = v14;
            v27 = v15 == 0;
            v26 = ((v10 ^ v31) & (v10 ^ v33)) < 0;
            v20 = v15 < 0;
            if (v22 <= v23) {
                // 0x80905c4
                unknown_8090617();
                v19 = v24;
                v29 = g8 / 256;
                v30 = v10 <= v31;
                v32 = v19;
                v34 = v29;
                v11 = v34 + v32 + (char)v30;
                v13 = ((v11 ^ v32) & (v11 ^ v34)) < 0;
                v16 = 0x1000000 * (v29 + v19 + (int32_t)v30);
                v35 = v16 == 0;
                v17 = v16 < 0;
                v27 = v16 == 0;
                v26 = ((v11 ^ v32) & (v11 ^ v34)) < 0;
                v20 = v16 < 0;
                // branch -> 0x80905cb
            }
            // 0x80905cb
            if (v27 || v26 ^ v20) {
                // 0x80905cd
                unknown_80905c3();
                if (v17 ^ v13 || v35) {
                    // 0x80905d3
                    return;
                }
                // 0x809062f
                return;
            }
            // 0x80905cb
            // branch -> 0x8090621
            // 0x8090621
            unknown_809061a();
            return;
        }
        // 0x80904f5
        v8 = v5;
        v9 = v4;
        if (v8 > v9) {
            goto lab_0x80904f9;
        }
        goto lab_0x8090521;
    }
}

// Address range: 0x8090650 - 0x8090657
int main(int argc, char ** argv) {
    // 0x8090650
    runtime_rt0_go();
    return g2;
}

// Address range: 0x8090660 - 0x809066f
void runtime_exit(void) {
    // 0x8090660
    return;
}

// Address range: 0x8090670 - 0x809067f
void runtime_exit1(void) {
    // 0x8090670
    return;
}

// Address range: 0x8090680 - 0x80906a5
void runtime_open(void) {
    // 0x8090680
    return;
}

// Address range: 0x80906b0 - 0x80906cf
void runtime_closefd(void) {
    // 0x80906b0
    return;
}

// Address range: 0x80906d0 - 0x80906ff
void runtime_write(void) {
    // 0x80906d0
    int32_t v1;
    g5 = v1;
    int32_t v2;
    g8 = v2;
}

// Address range: 0x8090700 - 0x809072f
void runtime_read(void) {
    // 0x8090700
    return;
}

// Address range: 0x8090730 - 0x809076f
void runtime_usleep(void) {
    // 0x8090730
    return;
}

// Address range: 0x8090770 - 0x809077f
void runtime_gettid(void) {
    // 0x8090770
    return;
}

// Address range: 0x80907c0 - 0x80907df
void runtime_setitimer(void) {
    // 0x80907c0
    return;
}

// Address range: 0x80907e0 - 0x80907ff
void runtime_mincore(void) {
    // 0x80907e0
    return;
}

// Address range: 0x8090800 - 0x809082f
void runtime_walltime(void) {
    // 0x8090800
    return;
}

// Address range: 0x8090830 - 0x809086f
void runtime_nanotime(void) {
    // 0x8090830
    int32_t v1;
    g4 = v1;
}

// Address range: 0x8090870 - 0x809089f
void runtime_rtsigprocmask(void) {
    // 0x8090870
    return;
}

// Address range: 0x80908a0 - 0x80908bf
void runtime_rt_sigaction(void) {
    // 0x80908a0
    return;
}

// Address range: 0x8090960 - 0x809096f
void runtime_sigreturn(void) {
    // 0x8090960
    return;
}

// Address range: 0x8090970 - 0x80909af
void runtime_mmap(void) {
    // 0x809099c
    return;
}

// Address range: 0x80909b0 - 0x80909cf
void runtime_munmap(void) {
    // 0x80909b0
    return;
}

// Address range: 0x80909d0 - 0x80909ef
void runtime_madvise(void) {
    // 0x80909d0
    return;
}

// Address range: 0x80909f0 - 0x8090a1f
void runtime_futex(void) {
    // 0x80909f0
    return;
}

// Address range: 0x8090a20 - 0x8090acf
void runtime_clone(void) {
    g7 = 0;
    int32_t v1;
    int32_t v2 = v1 - 16; // 0x8090a31
    g5 = v2;
    int32_t v3;
    *(int32_t *)v2 = v3;
    int32_t v4;
    *(int32_t *)(g5 + 4) = v4;
    int32_t v5;
    *(int32_t *)(g5 + 8) = v5;
    *(int32_t *)(g5 + 12) = 1234;
    // 0x8090a56
    return;
    // 0x8090a5b
    g3 = v3;
    g2 = 224;
    int32_t v6;
    g4 = v6;
    int32_t v7;
    g8 = v7;
    g9 = v1;
    g1 = false;
    g33 = false;
    g35 = v6 == 0;
    g34 = v6 < 0;
    if (v6 == 0) {
        // 0x8090abf
        ((int32_t (*)())v1)();
        runtime_exit1();
        *(int32_t *)0x1005 = 0x1234;
        return;
    }
    // 0x8090a80
    g1 = false;
    g33 = false;
    g35 = v7 == 0;
    g34 = v7 < 0;
    if (v7 == 0) {
        // 0x8090abf
        ((int32_t (*)())v1)();
        runtime_exit1();
        *(int32_t *)0x1005 = 0x1234;
        return;
    }
    // 0x8090a85
    *(int32_t *)(v6 + 36) = 224;
    runtime_setldt();
    abort();
    // UNREACHABLE
}

// Address range: 0x8090ad0 - 0x8090aef
void runtime_sigaltstack(void) {
    // 0x8090ad0
    return;
}

// Address range: 0x8090af0 - 0x8090b4f
void runtime_setldt(void) {
    // 0x8090af0
    int32_t v1;
    int32_t v2 = v1 + 4; // 0x8090af7
    *(int32_t *)v2 = v2;
    int32_t v3 = runtime_tls_entry_number; // 0x8090afc
    if (v3 == -1) {
        // 0x8090b36
        runtime_tls_entry_number = -1;
        // branch -> 0x8090b3c
    }
    // 0x8090b3c
    g2 = 8 * v3 | 3;
}

// Address range: 0x8090b50 - 0x8090b5f
void runtime_osyield(void) {
    // 0x8090b50
    return;
}

// Address range: 0x8090b60 - 0x8090b7f
void runtime_sched_getaffinity(void) {
    // 0x8090b60
    return;
}

// Address range: 0x8090bc0 - 0x8090bdf
void runtime_epollwait(void) {
    // 0x8090bc0
    return;
}

// Address range: 0x8090c00 - 0x8090c0f
void runtime_sbrk0(void) {
    // 0x8090c00
    return;
}

// Address range: 0x8090c10 - 0x8090c3f
void runtime__mul64by32(void) {
    // 0x8090c10
    uint32_t v1;
    int64_t v2 = v1; // 0x8090c18
    int32_t v3;
    uint64_t v4 = v2 * (int64_t)v3; // 0x8090c18
    int32_t v5;
    *(int32_t *)v5 = (int32_t)v4;
    int32_t v6;
    *(int32_t *)(v5 + 4) = (int32_t)(v4 / 0x100000000) + (int32_t)(v2 * (int64_t)v6);
}

// Address range: 0x8090c40 - 0x8090c5f
void runtime__div64by32(void) {
    // 0x8090c40
    int32_t v1;
    int32_t v2;
    int32_t v3;
    int32_t v4;
    *(int32_t *)v2 = (int32_t)((uint64_t)(0x100000000 * (int64_t)v4 | (int64_t)v3) % (uint64_t)(int64_t)v1);
}

// --------------- Instruction-Idiom Functions ----------------

// int32_t llvm_bswap_i32(int32_t a1);
// int32_t llvm_ctlz_i32(int32_t a1, bool a2);
// int32_t llvm_ctpop_i32(int32_t a1);
// int32_t llvm_cttz_i32(int32_t a1, bool a2);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (golang)
// Detected language: Go
// Detected functions: 617
// Decompiler release: VERSION
// Decompilation date: DATE
