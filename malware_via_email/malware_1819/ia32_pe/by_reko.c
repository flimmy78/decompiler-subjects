// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	__align(fp - 0x04);
	Eq_10 eax_9 = GetModuleHandleA(null);
	Eq_16 edi_12 = *((word32) eax_9 + 0x003C);
	word32 edx_13 = (word32) Mem0[eax_9 + 0x06 + edi_12:word16];
	word32 ebx_114 = edi_12 + 0xF8 + eax_9;
	if (edx_13 > 0x00)
	{
		int32 esi_111 = 0x00;
		while (fn004018F0(ebx_114, &globals->t402230, 0x06) != 0x00)
		{
			esi_111 = esi_111 + 0x01;
			ebx_114 = ebx_114 + 0x28;
			if (esi_111 >= edx_13)
				break;
		}
	}
	VirtualProtect(eax_9, 0x1000, 0x04, fp - 0x0410);
	*((word32) edi_12 + ((word32) eax_9 + 0x0088)) = ebx_114->dw000C;
	*((word32) edi_12 + ((word32) eax_9 + 0x008C)) = ebx_114->dw0008;
	Eq_57 eax_49 = FindResourceA(eax_9, (CHAR *) 311, &globals->t402240);
	LockResource(LoadResource(eax_9, eax_49));
	SizeofResource(eax_9, eax_49);
	Eq_57 eax_72 = FindResourceA(0x00, (CHAR *) 0x0138, &globals->t402240);
	SizeofResource(0x00, eax_72);
	LockResource(LoadResource(0x00, eax_72));
	fn00401550(mm0, mm1);
	*(fp - 2204) = 0x0104;
	*(fp - 0x08A0) = fp - 0x05CC;
	*(fp - 2212) = 0x00;
	GetModuleFileNameA(*(fp - 2212), *(fp - 0x08A0), *(fp - 2204));
	*(fp - 0x0464) = globals->ow4020D0;
}

// 004014BC: Register word32 fn004014BC(Register Eq_165 eax, Register Eq_13 edx)
word32 fn004014BC(Eq_165 eax, LPCSTR edx)
{
	wsprintfA(fp - 0x98, &globals->t402150, SLICE(0x00402150, <unknown>, 32));
	struct Eq_179 * esp_101 = fp - 188;
	if (RegCreateKeyExA((struct HKEY__ *) 0x80000001, fp - 0x98, 0x00, 0x00, 0x00, 0x000F003F, null, fp - 0x14, fp - 0x10) == 0x00)
	{
		RegSetValueExA(dwLoc38, edx, 0x00, 0x04, fp - 0x3C, 0x04);
		RegCloseKey(dwLoc50);
		esp_101 = fp - 0xD8;
	}
	return esp_101->dw0090;
}

// 00401550: void fn00401550(Register word64 mm0, Register word64 mm1)
void fn00401550(word64 mm0, word64 mm1)
{
	__align(fp - 0x04);
	Eq_237 eax_13 = 0x30;
	do
	{
		Mem19[fp - 0x88 + eax_13:word32] = Mem0[eax_13 + 4202604:word32];
		Mem21[fp - 0x8C + eax_13:word32] = Mem19[eax_13 + 4202600:word32];
		Mem23[fp - 0x90 + eax_13:word32] = Mem21[eax_13 + 0x00402064:word32];
		Mem25[fp - 0x94 + eax_13:word32] = Mem23[eax_13 + 0x00402060:word32];
		eax_13 = eax_13 - 0x10;
	} while (eax_13 != 0x00);
	Eq_271 eax_41 = 0x00;
	do
	{
		word128 xmm1_47 = Mem25[fp - 0x84 + eax_41:word128];
		mm1 = __pxor(mm1, mm0);
		Mem50[fp - 0x84 + eax_41:word128] = xmm1_47;
		eax_41 = eax_41 + 0x10;
	} while (eax_41 < 0x30);
	__pxor(mm1, mm0);
	wsprintfA(fp - 0x0644, &globals->t402158, SLICE(4202840, <unknown>, 32));
	if ((int32) bLoc0644 == 0x00)
	{
		fn004014BC(fp - 0x0130, &globals->t402160);
		fn004014BC(fp - 0x0130, &globals->t40216C);
		fn004014BC(fp - 0x0130, &globals->t402160);
		fn004014BC(fp - 0x0130, &globals->t402160);
		fn004014BC(fp - 0x0130, &globals->t40216C);
		fn004014BC(fp - 0x0130, &globals->t402160);
		fn004014BC(fp - 0x0130, &globals->t40216C);
		fn004014BC(fp - 0x0130, &globals->t402160);
	}
}

// 004018F0: Register word32 fn004018F0(Stack Eq_26 dwArg04, Stack Eq_26 dwArg08, Stack uint32 dwArg0C)
word32 fn004018F0(HMODULE dwArg04, HMODULE dwArg08, uint32 dwArg0C)
{
	if (dwArg04 != dwArg08 && dwArg0C != 0x00)
	{
		if (true)
		{
			uint32 ebx_89 = 0x00;
			do
			{
				if (dwArg04[ebx_89 * 0x04 / 0x0028] != dwArg08[(ebx_89 * 0x04) / 0x0028])
				{
					int32 eax_100 = (word32) dwArg04[ebx_89 * 0x04 / 0x0028];
					int32 ecx_101 = (word32) dwArg08[ebx_89 * 0x04 / 0x0028];
					if (eax_100 != ecx_101)
					{
						word32 eax_107 = 0x01;
						if (eax_100 <= ecx_101)
							eax_107 = ~0x00;
						return eax_107;
					}
					int32 eax_116 = (word32) dwArg04->a0001[ebx_89].b0000;
					int32 ecx_117 = (word32) dwArg08->a0001[ebx_89].b0000;
					if (eax_116 != ecx_117)
					{
						word32 eax_123 = 0x01;
						if (eax_116 <= ecx_117)
							eax_123 = ~0x00;
						return eax_123;
					}
					int32 eax_132 = (word32) dwArg04->a0002[ebx_89].b0000;
					int32 ecx_133 = (word32) dwArg08->a0002[ebx_89].b0000;
					if (eax_132 == ecx_133)
					{
						word32 eax_150 = 0x01;
						if ((word32) dwArg04->a0003[ebx_89].b0000 <= (word32) ((dwArg08->a0003))[ebx_89].b0000)
							eax_150 = ~0x00;
						return eax_150;
					}
					else
					{
						word32 eax_139 = 0x01;
						if (eax_132 <= ecx_133)
							eax_139 = ~0x00;
						return eax_139;
					}
				}
				ebx_89 = ebx_89 + 0x01;
			} while (ebx_89 < dwArg0C >> 0x02);
		}
		Eq_406 (* ebx_58)[] = dwArg04 + ((dwArg0C >> 0x02) * 0x04) / 0x0028;
		Eq_406 (* edx_59)[] = dwArg08 + ((dwArg0C >> 0x02) * 0x04) / 0x0028;
		if ((dwArg0C & 0x03) != 0x00)
		{
			Eq_406 eax_63[] = null;
			do
			{
				if ((word32) Mem0[eax_63 + ebx_58:byte] != (word32) Mem0[eax_63 + edx_59:byte])
				{
					word32 eax_78 = 0x01;
					if ((word32) Mem0[eax_63 + ebx_58:byte] <= (word32) Mem0[eax_63 + edx_59:byte])
						eax_78 = ~0x00;
					return eax_78;
				}
				eax_63 = (Eq_406 (*)[]) (eax_63 + 0x01);
			} while (eax_63 < (dwArg0C & 0x03));
		}
	}
	return 0x00;
}

