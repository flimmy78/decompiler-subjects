// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00411298: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	struct Eq_3 * esp_121 = fp - 44;
l00411311:
	esp_121->dw000C = 0x00;
l00411315:
	esp_121->t0018.u1 = ~0x6A1CA1D3;
	int32 * esp_81 = esp_121 - 0x04;
	*esp_81 = ecx;
	*(esp_81 - 0x04) = 0x00;
	*(esp_81 - 0x08) = 0x00;
l00411328:
	struct Eq_186 * esp_95;
	byte SCZO_97;
	word32 ecx_98;
	word32 esi_100;
	byte bl_101;
	byte Z_102;
	byte SZO_103;
	byte al_104;
	byte S_105;
	word16 dx_106;
	word16 ax_107;
	byte D_109;
	byte dl_110;
	byte SCZDOP_111;
	byte C_112;
	word32 edx_113;
	byte ch_114;
	word32 ebp_115;
	byte dh_116;
	word16 di_117;
	byte ah_118;
	***************************************************************************************************** edi_145;
	Eq_19 ebx_108;
	Eq_122 eax_144;
	globals->ptr415318();
	ecx = esp_95->dw0000;
	esp_95->dw001C = eax_144 + esp_95->dw001C / 0x02;
	esp_95->dw0024 = 0x00411340;
	esp_121 = (struct Eq_3 *) (&esp_95->dw0000 + 0x01);
	while (true)
	{
		Eq_11 bl_150 = esp_121->t0018;
		byte * esi_149 = esp_121->ptr0020;
		ebx_108 = DPB(ebx_108, bl_150, 0);
		if (esp_121->dw0008 == 666)
			*esi_149 = *esi_149 - bl_150;
		esp_121->ptr0020 = esp_121->ptr0020 + 0x01;
		if (esp_121->ptr0020 > &globals->b4115E2)
			break;
		esp_121->t0018 = esp_121->t0018 >> 0x08;
		esp_121->dw000C = esp_121->dw000C + 0x01;
		if (esp_121->dw000C == 0x04)
		{
			esp_121->dw000C = 0x00;
			esp_121->t0018.u1 = ~0x6A1CA1D3;
			int32 * esp_180 = esp_121 - 0x04;
			*esp_180 = ecx;
			*(esp_180 - 0x04) = 0x00;
			*(esp_180 - 0x08) = 0x00;
			eax_144 = GetMenuItemID(*(esp_180 - 0x08), *(esp_180 - 0x04));
			ecx = esp_187->dw0000;
			esp_187->dw001C = eax_144 + esp_187->dw001C / 0x02;
			esp_121 = (struct Eq_3 *) (&esp_187->dw0000 + 0x01);
			ebx_108 = ebx_200;
			edi_145 = edi_188;
		}
	}
	esp_121->dw0008 = esp_121->dw0008 + 0x01;
	bool Z_225 = cond(esp_121->dw0008 - 1000);
	do
	{
		if (Z_225)
			goto l00411311;
		edi_145 = Mem223[edi_145 + 0x00:word32];
		word16 di_246 = (word16) edi_145;
		esp_121 = (struct Eq_3 *) ((char *) edi_145 + 0x04);
		ecx = ecx + 0x01;
		eax_144 = (Eq_122) DPB(eax_144, __inb(0x8A), 0);
		Z_225 = cond(ecx);
	} while (ecx < 0x00);
	do
	{
		int64 edx_eax_263 = (int64) eax_144;
		__outw(SLICE(edx_eax_263, word16, 32), (word16) edx_eax_263);
		word32 ebx_270 = ebx_108 - globals->dw41162D;
		byte bl_279 = (byte) ebx_270 - globals->b4115C5;
		union Eq_19 * eax_264 = (word32) edx_eax_263;
		cu8 dl_267 = SLICE(edx_eax_263, byte, 32);
		Eq_122 ebx_280 = DPB(ebx_270, bl_279, 0);
		if (bl_279 == 0x00 && true)
			goto l00411328;
		Eq_19 eax_290 = *eax_264;
		*eax_264 = (union Eq_19 *) cond(dl_267 - 121);
		*(eax_290 - 0x7C) = 0x23;
		eax_144 = ebx_280;
		word16 ax_295 = (word16) ebx_280;
		ebx_108 = eax_290;
		if (dl_267 < 121)
		{
			*((word32) eax_290 - 25249343) = (word32) *((word32) eax_290 - 25249343) - 1231690913;
			__aad(ax_295);
			ecx = ~0x6A58B2C6;
			esp_121 = (struct Eq_3 *) ((char *) eax_264 + 0x04);
			if (~0x6A58B2C6 == 0x00)
				goto l00411315;
		}
	} while (2510807609 == 0x00);
	*(eax_264 - 0x02) = di_246;
	byte al_345 = globals->b4115E2;
	__sti();
	struct Eq_299 * eax_346 = DPB(2510807609, al_345, 0);
	eax_346->dw20AC91FC = -eax_346->dw20AC91FC;
	*(eax_264 - 0x02) = 100;
	struct Eq_315 * ebx_358 = *(eax_264 - 0x02) - globals->dw411606;
	ebx_280->w0000 = (int16) rArg0;
	word32 esp_370;
	word32 edi_371;
	byte SCZO_372;
	word32 ecx_373;
	Eq_2 eax_374;
	word32 esi_375;
	byte bl_376;
	byte Z_377;
	byte SZO_378;
	byte al_379;
	byte S_380;
	word16 dx_381;
	word16 ax_382;
	word32 ebx_383;
	byte D_384;
	byte dl_385;
	byte SCZDOP_386;
	byte C_387;
	word32 edx_388;
	byte ch_389;
	word32 ebp_390;
	byte dh_391;
	word16 di_392;
	byte ah_393;
	ebx_358->ptr005D();
	return eax_374;
}

