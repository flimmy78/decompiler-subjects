// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401020: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	fn00403640(35116, dwLoc14);
	Eq_10 eax_17 = fn00403590();
	if (eax_17 == 0x00)
		return 0x00;
	else
	{
		Eq_17 eax_128 = globals->t40603C;
		struct Eq_20 * ecx_130 = globals->a401C00;
		ui32 * ebx_134 = (word32) fp - 14948;
		do
		{
			*ebx_134 = (globals->t40603C | 0xA605EF2A) ^ ecx_130->dw0000;
			ecx_130 = ecx_130 + 0x01;
			ebx_134 = ebx_134 - eax_128 * 0x05 + 0x04;
		} while (ecx_130 <= (struct Eq_20 *) ~0x00400490);
		struct Eq_46 * ecx_157 = null;
		int32 eax_162 = ((word32) eax_128 + 0x01) * 0x04;
		do
		{
			*ebx_134 = (word32) (eax_128 >= ~0x59FA10D4) - 1509560534 ^ ecx_157->dw404060;
			ebx_134 = ebx_134 + eax_162;
			ecx_157 = ecx_157 + (uint32) (0x04 /u ((word32) eax_128 + 0x01));
		} while (ecx_157 <= (struct Eq_46 *) 0x1A57);
		ui32 edx_1761 = (word32) fp - 2204 ^ (word32) fp - 2204;
		byte * dwLoc88D4_1743 = (word32) fp - 14948;
		struct Eq_81 * dwLoc890C_1774 = (word32) fp - 2204;
		byte dl_1762 = (byte) edx_1761;
		word16 dx_1763 = (word16) edx_1761;
		do
		{
			dwLoc890C_1774->w0000 = dx_1763;
			if ((dl_1762 & 0x01) == 0x00)
			{
				dwLoc890C_1774->b0004 = (byte) ((word32) *dwLoc88D4_1743 >> (byte) ((word32) bLoc8914));
				edx_1761 = edx_1761 + 0x01;
				dl_1762 = (byte) edx_1761;
				dx_1763 = (word16) edx_1761;
				dwLoc890C_1774 = dwLoc890C_1774 + 0x01;
				if (edx_1761 == (eax_128 | 0x0108))
					break;
				continue;
			}
			dwLoc890C_1774->b0004 = (byte) ((word32) *dwLoc88D4_1743 & 0x0F);
			edx_1761 = edx_1761 + 0x01;
			dl_1762 = (byte) edx_1761;
			dx_1763 = (word16) edx_1761;
			dwLoc88D4_1743 = dwLoc88D4_1743 + 0x01;
			dwLoc890C_1774 = dwLoc890C_1774 + 0x01;
		} while (edx_1761 != (eax_128 | 0x0108));
		int32 eax_233 = 0x02;
		do
		{
			eax_233 - 0x1F + (fp - 0x04) = (byte *) 0x00;
			eax_233 = eax_233 + 0x01;
		} while (eax_233 != 0x11);
		int32 ecx_246 = ~0x0893;
		do
		{
			ci8 al_259 = (byte) (word32) *((word32) (fp - (uint32 *) 0x04) + (ecx_246 + 0x00));
			if (al_259 > 0x00)
			{
				Eq_154 edx_1755 = (uint32) ((uint64) (uint32) (int32) al_259 % (eax_128 - 0x01));
				Mem1758[fp - 0x22 + edx_1755:byte] = Mem238[fp - 0x22 + edx_1755:byte] + 0x01;
			}
			ecx_246 = ecx_246 + 0x06;
		} while (ecx_246 != 0x0EC4);
		uint32 ebx_271 = 0x00;
		int32 edx_274 = 0x01;
		do
		{
			ebx_271 = ebx_271 + (int32) (*((word32) (fp - (uint32 *) 0x04) + (edx_274 - 0x1F))) << (byte) ((0x00 - (eax_128 < 0x01)) + 0x02);
			*((word32) (fp - 100) + edx_274 * 0x04) = (word32) eax_128 + ebx_271;
			edx_274 = edx_274 + 0x01;
		} while (edx_274 != 0x10);
		word32 ecx_298 = fp + ~0x0897;
		do
		{
			int32 edx_303 = (int32) *ecx_298;
			word32 eax_304 = *((word32) (fp - 100) + edx_303 * 0x04);
			*(ecx_298 - 0x02) = (word16) eax_304;
			*((word32) (fp - 100) + edx_303 * 0x04) = eax_304 + 0x01;
			ecx_298 = ecx_298 + 0x06;
		} while (ecx_298 != fp - 616);
		uint32 ebx_345;
		uint32 eax_319 = (uint32) (0x0108 /u ((word32) eax_128 + 0x01));
		byte cl_321 = 0x00;
		uint32 edx_323 = 0x00;
		if (0x00 >= eax_319 - 0x01)
		{
			do
			{
				if (cl_321 == 0x00)
				{
					int32 edi_1002 = 0x80;
					uint32 edx_457 = SLICE(eax_128 * ~0x00FF00FE, word32, 32);
					Eq_297 dwLoc88CC_461 = -eax_128;
					while (true)
					{
						while (true)
						{
							int32 ebx_1001 = edi_1002;
							ui32 esi_1666 = 0x00;
							int32 edi_492 = 0x00;
							int32 dwLoc88A4_494 = 0x00;
							struct Eq_409 * dwLoc88D0_1696 = (struct Eq_409 *) ~0x00;
							do
							{
								ui32 edx_514 = eax_128 | 0x01;
								ui32 ecx_1746 = 0x00;
								do
								{
									ecx_1746 = ecx_1746 * 0x02;
									if (((word32) *dwLoc88D4_1743 & ebx_1001) != 0x00)
										ecx_1746 = ecx_1746 | 0x01;
									ebx_1001 = ebx_1001 >> 0x01;
									if (ebx_1001 == 0x00)
									{
										dwLoc88D4_1743 = dwLoc88D4_1743 + 0x01;
										ebx_1001 = 0x80;
									}
									edx_514 = edx_514 - 0x01;
								} while (edx_514 != 0x00);
								int32 v30_561 = dwLoc88A4_494 << 0x01 | ecx_1746;
								Eq_377 eax_564 = esi_1666 * 0x03 * 0x02;
								edi_492 = edi_492 + 0x01;
								dwLoc88A4_494 = v30_561;
								word32 edx_1732 = (int32) Mem313[fp + ~0x0897 + eax_564:byte];
								if (edi_492 > edx_1732)
								{
									word32 eax_1726 = fp + ~0x089B + eax_564 + 0x0A;
									do
									{
										edx_1732 = (int32) *eax_1726;
										esi_1666 = esi_1666 + 0x01;
										eax_1726 = eax_1726 + 0x06;
									} while (edi_492 > edx_1732);
								}
								if (edi_492 == edx_1732)
								{
									ui32 eax_1677 = esi_1666 * 0x03;
									word32 edx_1683 = fp + ~0x089B + eax_1677 * 0x02;
									if ((int32) *((word32) fp + (eax_1677 * 0x02 - 2202)) != v30_561)
									{
										do
										{
											esi_1666 = esi_1666 + 0x01;
											if ((int32) *((word32) edx_1792 + 0x0A) != edi_492)
												goto l0040177D;
											edx_1683 = (word32) edx_1792 + 0x06;
											Eq_415 edx_1792 = edx_1683;
										} while ((int32) *((word32) edx_1792 + 0x08) != v30_561);
									}
									int32 eax_1692 = (int32) *((word32) fp + ((esi_1666 * 0x03) * 0x02 - 2204));
									dwLoc88D0_1696 = (struct Eq_409 *) ~0x00;
									if (eax_1692 == ~0x00)
										continue;
									struct Eq_409 * edx_1702 = (uint32) ((uint64) (uint32) eax_1692 % (eax_128 - 0x01));
									dwLoc88D0_1696 = edx_1702;
									if (edx_1702 >= null)
										break;
									continue;
								}
l0040177D:
							} while (dwLoc88D0_1696 < null);
							word32 edx_597 = eax_128 + 0x01 << 0x08;
							if (dwLoc88D0_1696 >= edx_597)
								break;
							Mem609[fp + 4294932324 + dwLoc88CC_461:byte] = (byte) (word32) bLoc88D0;
							edi_1002 = ebx_1001;
							dwLoc88CC_461 = dwLoc88CC_461 + 0x01;
						}
						if (dwLoc88D0_1696 == (edx_457 >> 0x08) + 0x0100)
							break;
						byte cl_1005;
						ui32 esi_1008;
						byte bLoc88ED_1007;
						Eq_495 dwLoc88C0_650;
						word32 v33_621 = dwLoc88D0_1696 - (edx_597 + (eax_128 + 0x01));
						word32 eax_630 = (uint32) ((uint64) (uint32) (int32) (v33_621 * 0x03)->a405AC0[v33_621].w0000 /u (eax_128 + 0x01));
						word16 ax_637 = (word16) (word32) (v33_621 * 0x03)->a405AC2[v33_621].w0000;
						word16 di_639 = (word16) (word32) (v33_621 * 0x03)->a405AC4[v33_621].w0000;
						if (eax_630 != 0x00)
						{
							cl_1005 = (byte) (word32) *dwLoc88D4_1743;
							dwLoc88C0_650 = eax_630;
							edi_1002 = ebx_1001 >> 0x01;
							bLoc88ED_1007 = cl_1005;
							esi_1008 = (word32) cl_1005;
						}
						else
						{
							int32 edx_911 = (int32) ax_637;
							cl_1005 = (byte) (word32) *dwLoc88D4_1743;
							ui32 dwLoc88BC_1019 = 0x00;
							int32 eax_1012 = edx_911 - (edx_911 | 0x01) *s eax_128;
							bLoc88ED_1007 = cl_1005;
							do
							{
								ui32 v38_943 = dwLoc88BC_1019 << 0x01;
								esi_1008 = (word32) cl_1005;
								dwLoc88BC_1019 = v38_943;
								if ((esi_1008 & ebx_1001) != 0x00)
									dwLoc88BC_1019 = v38_943 | 0x01;
								ebx_1001 = ebx_1001 >> 0x01;
								if (ebx_1001 == 0x00)
								{
									byte * v41_992 = dwLoc88D4_1743 + 0x01;
									cl_1005 = (byte) (word32) *v41_992;
									dwLoc88D4_1743 = v41_992;
									eax_1012 = eax_1012 - 0x01;
									ebx_1001 = 0x80;
									edi_1002 = 0x40;
									bLoc88ED_1007 = cl_1005;
									esi_1008 = (word32) cl_1005;
									if (eax_1012 == 0x00)
										break;
									continue;
								}
								edi_1002 = ebx_1001 >> 0x01;
								eax_1012 = eax_1012 - 0x01;
							} while (eax_1012 != 0x00);
							Eq_648 eax_966 = (int32) di_639;
							uint32 edx_977 = (word32) eax_966 + (uint32) ((uint64) ((uint32) eax_128) /u (eax_966 | 0x01));
							dwLoc88C0_650 = (uint32) ((uint64) (uint32) eax_128 /u (edx_977 | 0x01)) + edx_977 + dwLoc88BC_1019;
						}
						int32 dwLoc88B4_667;
						ui32 eax_674;
						if (edi_1002 != 0x00)
						{
							dwLoc88B4_667 = edi_1002 >> 0x01;
							eax_674 = esi_1008;
						}
						else
						{
							byte * v40_885 = dwLoc88D4_1743 + 0x01;
							cl_1005 = (byte) (word32) *v40_885;
							dwLoc88D4_1743 = v40_885;
							edi_1002 = 0x80;
							dwLoc88B4_667 = 0x40;
							eax_674 = (word32) cl_1005;
							bLoc88ED_1007 = cl_1005;
						}
						ui32 dwLoc88C4_684 = 0x07;
						if ((esi_1008 & ebx_1001) != 0x00)
						{
							if (dwLoc88B4_667 == 0x00)
							{
								byte * v36_869 = dwLoc88D4_1743 + 0x01;
								dwLoc88D4_1743 = v36_869;
								dwLoc88B4_667 = 0x80;
								bLoc88ED_1007 = (byte) (word32) *v36_869;
							}
							cl_1005 = (byte) (word32) bLoc88ED_1007;
							edi_1002 = dwLoc88B4_667;
							dwLoc88C4_684 = (word32) ((eax_674 & edi_1002) != 0x00) + (eax_128 | 0x08);
						}
						struct Eq_568 * eax_701 = dwLoc88C4_684 * 0x03;
						uint32 edx_698 = ~0x00;
						word32 ebx_703 = (int32) Mem313[eax_701 + 0x00405AC2 + eax_701:word16];
						if (ebx_703 != ~0x00)
							edx_698 = (uint32) ((uint64) (uint32) ebx_703 % (eax_128 - (struct Eq_613 *) 0x01));
						Eq_609 esi_712 = 0x00;
						while (true)
						{
							esi_712 = esi_712 * 0x02;
							if (((word32) cl_1005 & edi_1002) != 0x00)
								esi_712 = esi_712 | 0x01;
							edi_1002 = edi_1002 >> 0x01;
							if (edi_1002 == 0x00)
							{
								dwLoc88D4_1743 = dwLoc88D4_1743 + 0x01;
								edi_1002 = 0x80;
							}
							edx_698 = edx_698 - 0x01;
							if (edx_698 == 0x00)
								break;
							cl_1005 = (byte) (word32) *dwLoc88D4_1743;
						}
						struct Eq_1564 * eax_750 = dwLoc88C4_684 * 0x03;
						word32 edx_754 = (int32) Mem313[eax_750 + 0x00405AC4 + eax_750:word16];
						if (eax_128 != 0x00)
							edx_754 = edx_754 * 0x02;
						if (dwLoc88C0_650 > 0x00)
						{
							word32 ebx_786 = fp + 4294932324 + dwLoc88CC_461;
							word32 dwLoc890C_792 = ebx_786 - ((esi_712 + eax_128) + edx_754);
							Eq_495 esi_793 = 0x00;
							do
							{
								*ebx_786 = (byte) (uint32) ((uint64) (uint32) (word32) *dwLoc890C_792 /u ((word32) globals->t40603C + 0x01));
								esi_793 = (word32) esi_793 + 0x01;
								dwLoc890C_792 = dwLoc890C_792 + 0x01;
								ebx_786 = ebx_786 + 0x01;
							} while (esi_793 != dwLoc88C0_650);
						}
						dwLoc88CC_461 = dwLoc88CC_461 + dwLoc88C0_650 - (dwLoc88C0_650 | 0x01) *s Mem313[0x0040603C:word32];
					}
					if (dwLoc88CC_461 > 0x00)
					{
						word32 edi_1541 = eax_128 + 0x01 + (eax_128 + 0x01) * 0x02;
						struct Eq_911 * esi_1542 = (struct Eq_911 *) ~0x00;
						Eq_297 ebx_1547 = 0x00;
						Eq_17 edi_1548 = 0x00;
						ui32 v44_1553 = 0x40 - eax_128 * 0x41;
						do
						{
							Eq_922 eax_1569 = (word32) *((word32) (fp - (uint32 *) 0x04) + ((word32) ebx_1547 - 0x00008898));
							byte al_1571 = (byte) eax_1569;
							if (eax_128 != 0x00)
							{
								eax_1569 = (uint32) ((uint64) (uint32) eax_1569 /u eax_128);
								al_1571 = (byte) eax_1569;
							}
							Eq_922 edx_1581 = eax_1569;
							if (esi_1542 <= (struct Eq_911 *) 0x43)
							{
								if (edi_1548 < (eax_128 | 0x10))
								{
									if (*((word32) edi_1548 + 0x00404000) != al_1571)
									{
										edi_1548 = eax_128;
										edx_1581 = eax_1569;
									}
									else
									{
										edi_1548 = (word32) edi_1548 + 0x01;
										edx_1581 = eax_1569;
									}
								}
								else
								{
									esi_1542 = esi_1542 + 0x01;
									if (esi_1542 <= (struct Eq_911 *) 0x2F)
									{
										int32 eax_1622 = (int32) esi_1542[0x00404010];
										edx_1581.u0 = ~0x00;
										if (eax_1622 != ~0x00)
											edx_1581 = (uint32) ((uint64) (uint32) eax_1622 % (eax_128 - (struct Eq_1555 *) 0x01));
									}
									else if (esi_1542 <= (struct Eq_911 *) 0x3F)
										edx_1581 = (int32) (esi_1542 - (edi_1541 << 0x04))->b404040;
									else
										edx_1581 = (int32) (esi_1542 - v44_1553)->b406000;
								}
							}
							Mem1598[ebx_1547 + ~0x8897 + (fp - 0x04):byte] = (byte) (edx_1581 *s (eax_128 + 0x01));
							ebx_1547 = (word32) ebx_1547 + 0x01;
						} while (ebx_1547 != dwLoc88CC_461);
					}
					*(fp - 0x10) = 4219229612;
					globals->dw406028 = 0x00;
					*(fp - 0x0C) = eax_17;
					int32 eax_1037 = fn00403390(dwArg00, dwArg04);
					*(fp - (uint32 *) 0x10) = 3424463584;
					*(fp - 0x0C) = eax_17;
					globals->dw406028 = eax_1037;
					int32 eax_1042 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1043 = globals->t40603C;
					*(fp - 0x0C) = fp - 0x026C;
					*(fp - (uint32 *) 0x10) = 0x0104;
					globals->dw406014 = eax_1042;
					<anonymous> * eax_1048 = eax_1042 *s ((word32) edx_1043 + 0x01);
					struct Eq_738 * esp_1050;
					word32 ebp_1051;
					word32 eax_1052;
					word32 edi_1053;
					word32 esi_1054;
					word32 ebx_1055;
					byte SZO_1056;
					byte C_1057;
					byte Z_1058;
					word32 edx_1059;
					word32 ecx_1060;
					byte SCZO_1061;
					byte CZ_1062;
					byte al_1063;
					byte dl_1064;
					word16 dx_1065;
					byte cl_1066;
					word16 ax_1067;
					word16 cx_1068;
					byte S_1069;
					word16 di_1070;
					eax_1048();
					*(esp_1050 - 0x04) = esi_1054;
					*(esp_1050 - 0x08) = ~0x6B8AA076;
					int32 eax_1075 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1076 = globals->t40603C;
					*(esp_1050 - 0x08) = (union Eq_776 *) (fp - (uint32 *) 0x026C);
					esp_1050->dw0000 = 0x00;
					*(esp_1050 - 0x04) = 0x00;
					globals->dw406010 = eax_1075;
					esp_1050->t0004 = fp - 0x0168;
					<anonymous> * eax_1082 = eax_1075 *s ((word32) edx_1076 + 0x01);
					struct Eq_802 * esp_1086;
					word32 ebp_1087;
					word32 eax_1088;
					word32 edi_1089;
					word32 esi_1090;
					word32 ebx_1091;
					byte SZO_1092;
					byte C_1093;
					byte Z_1094;
					word32 edx_1095;
					word32 ecx_1096;
					byte SCZO_1097;
					byte CZ_1098;
					byte al_1099;
					byte dl_1100;
					word16 dx_1101;
					byte cl_1102;
					word16 ax_1103;
					word16 cx_1104;
					byte S_1105;
					word16 di_1106;
					eax_1082();
					*(esp_1086 - 0x0C) = esi_1090;
					*(esp_1086 - 0x10) = 2165515512;
					int32 eax_1112 = fn00403390(dwArg00, dwArg04);
					Eq_17 edx_1113 = globals->t40603C;
					esp_1086->dw0008 = 0x00;
					esp_1086->dw0004 = 0x00;
					esp_1086->dw0000 = 0x02;
					*(esp_1086 - 0x04) = 0x00;
					globals->dw406004 = eax_1112;
					*(esp_1086 - 0x08) = 0x01;
					*(esp_1086 - 0x0C) = 0xC0000000;
					*(esp_1086 - 0x10) = (union Eq_873 *) (fp - 0x0168);
					<anonymous> * eax_1120 = eax_1112 *s ((word32) edx_1113 + 0x01);
					ptr32 esp_1125;
					word32 ebp_1126;
					word32 eax_1127;
					word32 edi_1128;
					word32 esi_1129;
					word32 ebx_1130;
					byte SZO_1131;
					byte C_1132;
					byte Z_1133;
					word32 edx_1134;
					word32 ecx_1135;
					byte SCZO_1136;
					byte CZ_1137;
					byte al_1138;
					byte dl_1139;
					word16 dx_1140;
					byte cl_1141;
					word16 ax_1142;
					word16 cx_1143;
					byte S_1144;
					word16 di_1145;
					eax_1120();
					if (eax_1127 != ~0x00)
					{
						*(esp_1125 - 0x1C) = 2390103535;
						*(esp_1125 - 0x18) = (union Eq_10 *) eax_17;
						int32 eax_1154 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1155 = globals->t40603C;
						*(esp_1125 - 0x08) = 0x00;
						*(esp_1125 - 0x10) = 0x00;
						*(esp_1125 - 0x14) = 0x04;
						*(esp_1125 - 0x18) = 0x00;
						globals->dw40602C = eax_1154;
						*(esp_1125 - 0x1C) = eax_1127;
						word32 edx_1165 = dwLoc88CC_461 + 0x01;
						*(esp_1125 - 0x0C) = (union Eq_995 *) edx_1165;
						<anonymous> * eax_1162 = eax_1154 *s ((word32) edx_1155 + 0x01);
						ptr32 esp_1168;
						word32 ebp_1169;
						word32 eax_1170;
						word32 edi_1171;
						word32 esi_1172;
						word32 ebx_1173;
						byte SZO_1174;
						byte C_1175;
						byte Z_1176;
						word32 edx_1177;
						word32 ecx_1178;
						byte SCZO_1179;
						byte CZ_1180;
						byte al_1181;
						byte dl_1182;
						word16 dx_1183;
						byte cl_1184;
						word16 ax_1185;
						word16 cx_1186;
						byte S_1187;
						word16 di_1188;
						eax_1162();
						*(esp_1168 - 0x14) = (union Eq_10 *) eax_17;
						*(esp_1168 - 0x18) = 0xFC1F1484;
						int32 eax_1195 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1196 = globals->t40603C;
						*(esp_1168 - 0x08) = 0x00;
						*(esp_1168 - 0x0C) = 0x00;
						*(esp_1168 - 0x10) = 0x00;
						globals->dw406030 = eax_1195;
						*(esp_1168 - 0x14) = 0x02;
						*(esp_1168 - 0x18) = eax_1170;
						<anonymous> * eax_1203 = eax_1195 *s ((word32) edx_1196 + 0x01);
						word32 esp_1207;
						word32 ebp_1208;
						word32 eax_1209;
						word32 edi_1210;
						word32 esi_1211;
						word32 ebx_1212;
						byte SZO_1213;
						byte C_1214;
						byte Z_1215;
						word32 edx_1216;
						word32 ecx_1217;
						byte SCZO_1218;
						byte CZ_1219;
						byte al_1220;
						byte dl_1221;
						word16 dx_1222;
						byte cl_1223;
						word16 ax_1224;
						word16 cx_1225;
						byte S_1226;
						word16 di_1227;
						eax_1203();
						word32 esi_1229 = eax_1209;
						struct Eq_1101 * esp_1231 = esp_1207 - 0x14;
						if (dwLoc88CC_461 > 0x00)
						{
							Eq_297 ebx_1498 = 0x00;
							do
							{
								Eq_17 edx_1506 = globals->t40603C;
								esp_1231->t0004 = fp - 0x12;
								word32 eax_1511 = (word32) ebx_1498 + esi_1229;
								<anonymous> * edx_1513 = ((word32) edx_1506 + 0x01) *s globals->dw406028;
								esp_1231->dw0000 = eax_1511;
								word32 esp_1516;
								word32 ebp_1517;
								word32 eax_1518;
								word32 edi_1519;
								byte SZO_1522;
								byte C_1523;
								byte Z_1524;
								word32 edx_1525;
								word32 ecx_1526;
								byte SCZO_1527;
								byte CZ_1528;
								byte al_1529;
								byte dl_1530;
								word16 dx_1531;
								byte cl_1532;
								word16 ax_1533;
								word16 cx_1534;
								byte S_1535;
								word16 di_1536;
								edx_1513();
								esp_1231 = esp_1516 - 0x08;
							} while (ebx_1498 != dwLoc88CC_461);
						}
						esp_1231->dw0000 = ~0x3489B267;
						esp_1231->t0004 = eax_17;
						int32 eax_1240 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1241 = globals->t40603C;
						esp_1231->dw0000 = esi_1229;
						globals->dw406034 = eax_1240;
						<anonymous> * eax_1245 = eax_1240 *s ((word32) edx_1241 + 0x01);
						union Eq_10 * esp_1247;
						word32 ebp_1248;
						word32 eax_1249;
						word32 edi_1250;
						word32 esi_1251;
						word32 ebx_1252;
						byte SZO_1253;
						byte C_1254;
						byte Z_1255;
						word32 edx_1256;
						word32 ecx_1257;
						byte SCZO_1258;
						byte CZ_1259;
						byte al_1260;
						byte dl_1261;
						word16 dx_1262;
						byte cl_1263;
						word16 ax_1264;
						word16 cx_1265;
						byte S_1266;
						word16 di_1267;
						eax_1245();
						*esp_1247 = (union Eq_10 *) eax_17;
						*(esp_1247 - 0x04) = 0x941A1EE1;
						int32 eax_1273 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1274 = globals->t40603C;
						*(esp_1247 - 0x04) = eax_1170;
						globals->dw406008 = eax_1273;
						<anonymous> * eax_1280 = eax_1273 *s ((word32) edx_1274 + 0x01);
						ptr32 esp_1282;
						word32 ebp_1283;
						word32 eax_1284;
						word32 edi_1285;
						word32 esi_1286;
						word32 ebx_1287;
						byte SZO_1288;
						byte C_1289;
						byte Z_1290;
						word32 edx_1291;
						word32 ecx_1292;
						byte SCZO_1293;
						byte CZ_1294;
						byte al_1295;
						byte dl_1296;
						word16 dx_1297;
						byte cl_1298;
						word16 ax_1299;
						word16 cx_1300;
						byte S_1301;
						word16 di_1302;
						eax_1280();
						<anonymous> * eax_1305 = ((word32) globals->t40603C + 0x01) *s globals->dw406008;
						*(esp_1282 - 0x04) = edi_1285;
						union Eq_10 * esp_1309;
						word32 ebp_1310;
						word32 eax_1311;
						word32 edi_1312;
						word32 esi_1313;
						word32 ebx_1314;
						byte SZO_1315;
						byte C_1316;
						byte Z_1317;
						word32 edx_1318;
						word32 ecx_1319;
						byte SCZO_1320;
						byte CZ_1321;
						byte al_1322;
						byte dl_1323;
						word16 dx_1324;
						byte cl_1325;
						word16 ax_1326;
						word16 cx_1327;
						byte S_1328;
						word16 di_1329;
						eax_1305();
						*esp_1309 = (union Eq_10 *) eax_17;
						*(esp_1309 - 0x04) = 0xDE0B22C2;
						int32 eax_1335 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1336 = globals->t40603C;
						globals->dw40601C = eax_1335;
						*(esp_1309 - 0x04) = (union Eq_1247 *) (fp - 0x0168);
						<anonymous> * eax_1339 = eax_1335 *s ((word32) edx_1336 + 0x01);
						struct Eq_1256 * esp_1343;
						word32 ebp_1344;
						word32 eax_1345;
						Eq_1259 edi_1346;
						word32 esi_1347;
						word32 ebx_1348;
						byte SZO_1349;
						byte C_1350;
						byte Z_1351;
						word32 edx_1352;
						word32 ecx_1353;
						byte SCZO_1354;
						byte CZ_1355;
						byte al_1356;
						byte dl_1357;
						word16 dx_1358;
						byte cl_1359;
						word16 ax_1360;
						word16 cx_1361;
						byte S_1362;
						word16 di_1363;
						eax_1339();
						esp_1343->t0000 = edi_1346;
						*(esp_1343 - 0x04) = 2843221742;
						int32 eax_1369 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1370 = globals->t40603C;
						esp_1343->t0000 = fp - 0x026C;
						esp_1343->dw0004 = 0x0104;
						*(esp_1343 - 0x04) = 0x00;
						globals->dw406018 = eax_1369;
						<anonymous> * eax_1377 = eax_1369 *s ((word32) edx_1370 + 0x01);
						ptr32 esp_1379;
						word32 ebp_1380;
						word32 eax_1381;
						word32 edi_1382;
						word32 esi_1383;
						word32 ebx_1384;
						byte SZO_1385;
						byte C_1386;
						byte Z_1387;
						word32 edx_1388;
						word32 ecx_1389;
						byte SCZO_1390;
						byte CZ_1391;
						byte al_1392;
						byte dl_1393;
						word16 dx_1394;
						byte cl_1395;
						word16 ax_1396;
						word16 cx_1397;
						byte S_1398;
						word16 di_1399;
						eax_1377();
						*(esp_1379 - 0x08) = ebx_1384;
						*(esp_1379 - 0x0C) = 4229121209;
						int32 eax_1404 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1405 = globals->t40603C;
						*(esp_1379 - 0x0C) = (union Eq_1351 *) (fp - 0x026C);
						globals->dw406038 = eax_1404;
						<anonymous> * eax_1409 = eax_1404 *s ((word32) edx_1405 + 0x01);
						word32 * esp_1411;
						word32 ebp_1412;
						word32 eax_1413;
						word32 edi_1414;
						word32 esi_1415;
						word32 ebx_1416;
						byte SZO_1417;
						byte C_1418;
						byte Z_1419;
						word32 edx_1420;
						word32 ecx_1421;
						byte SCZO_1422;
						byte CZ_1423;
						byte al_1424;
						byte dl_1425;
						word16 dx_1426;
						byte cl_1427;
						word16 ax_1428;
						word16 cx_1429;
						byte S_1430;
						word16 di_1431;
						eax_1409();
						*esp_1411 = edi_1414;
						*(esp_1411 - 0x04) = ~0x61F0C037;
						int32 eax_1436 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1437 = globals->t40603C;
						*(esp_1411 - 0x04) = ebx_1416;
						globals->dw406020 = eax_1436;
						<anonymous> * eax_1441 = eax_1436 *s ((word32) edx_1437 + 0x01);
						word32 * esp_1443;
						word32 ebp_1444;
						word32 eax_1445;
						word32 edi_1446;
						word32 esi_1447;
						word32 ebx_1448;
						byte SZO_1449;
						byte C_1450;
						byte Z_1451;
						word32 edx_1452;
						word32 ecx_1453;
						byte SCZO_1454;
						byte CZ_1455;
						byte al_1456;
						byte dl_1457;
						word16 dx_1458;
						byte cl_1459;
						word16 ax_1460;
						word16 cx_1461;
						byte S_1462;
						word16 di_1463;
						eax_1441();
						*esp_1443 = edi_1446;
						*(esp_1443 - 0x04) = 2651074515;
						int32 eax_1468 = fn00403390(dwArg00, dwArg04);
						Eq_17 edx_1469 = globals->t40603C;
						*(esp_1443 - 0x04) = 0x00;
						globals->dw406024 = eax_1468;
						<anonymous> * eax_1473 = eax_1468 *s ((word32) edx_1469 + 0x01);
						word32 esp_1475;
						word32 ebp_1476;
						word32 eax_1477;
						word32 edi_1478;
						word32 esi_1479;
						word32 ebx_1480;
						byte SZO_1481;
						byte C_1482;
						byte Z_1483;
						word32 edx_1484;
						word32 ecx_1485;
						byte SCZO_1486;
						byte CZ_1487;
						byte al_1488;
						byte dl_1489;
						word16 dx_1490;
						byte cl_1491;
						word16 ax_1492;
						word16 cx_1493;
						byte S_1494;
						word16 di_1495;
						eax_1473();
					}
					return 0x00;
				}
				cl_321 = 0x00;
				ebx_345 = 0x00;
l00401249:
				edx_323 = ebx_345;
l0040124B:
			} while (edx_323 >= eax_319 - 0x01);
		}
		word32 edi_339 = fp - 0x10 + (edx_323 * 0x03) * 0x02;
		ebx_345 = edx_323 + 0x01;
		byte al_344 = (byte) (word32) *((word32) edi_339 - 0x0888);
		word32 eax_350 = fp - 0x10 + (ebx_345 * 0x03) * 0x02;
		if ((byte) (word32) al_344 > *(eax_350 - 0x0888))
		{
			word16 dx_362 = (word16) (word32) *((word32) edi_339 - 0x088A);
			Eq_307 cx_364 = (word16) (word32) *((word32) edi_339 - 0x088C);
			*((word32) edi_339 - 0x088C) = *((word32) eax_350 - 0x088C);
			*((word32) edi_339 - 0x0888) = (word16) (word32) *(eax_350 - 0x0888);
			*(eax_350 - 0x088A) = dx_362;
			*(eax_350 - 0x0888) = (byte) (word32) al_344;
			*((word32) eax_350 - 0x088C) = cx_364;
			cl_321 = 0x01;
			edx_323 = ebx_345;
			goto l0040124B;
		}
		goto l00401249;
	}
}

// 00403390: Register uint32 fn00403390(Stack ui32 dwArg04, Stack (ptr Eq_698) dwArg08)
uint32 fn00403390(ui32 dwArg04, Eq_698 * dwArg08)
{
	uint32 edx_132;
	Eq_17 ebx_155 = globals->t40603C;
	Eq_1636 edi_26 = dwArg08 | ebx_155;
	struct Eq_1638 * edx_30 = (word32) edi_26 + 0x0078 + dwArg08->dw003C + (dwArg08 - (dwArg08 | 0x01) *s ebx_155);
	struct Eq_1651 * esp_15 = fp - 0xAC;
	Eq_17 dwLoc84_161 = ebx_155;
	word16 * eax_31 = edx_30->ptr0024;
	ui32 ecx_34 = edx_30->dw0020;
	if ((uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) != 0x00)
	{
		uint32 dwLoc88_141 = 0x00;
		struct Eq_1849 * ecx_143[] = dwArg08 + (ecx_34 - (ecx_34 | 0x01) *s ebx_155) / 0x0040;
		word32 dwLoc8C_146 = edi_26 + eax_31;
l00403422:
		word32 ecx_165 = dwArg08 + ecx_143[dwLoc88_141 * 0x04];
		Eq_1686 esi_166 = 0x00;
		byte al_171 = (byte) (word32) ecx_165->a0000[0x00];
		if (al_171 != 0x00)
		{
			Eq_1686 edi_302 = 0x00;
			do
			{
				Eq_1693 eax_321 = (int32) al_171;
				if (ebx_155 != 0x00)
					eax_321 = (uint32) ((uint64) (uint32) eax_321 /u ebx_155);
				Eq_1698 eax_330 = (word32) ebx_155 + 0x01;
				byte dl_328 = (byte) eax_321;
				<anonymous> * ecx_333 = eax_330 *s globals->dw406028;
				if (ecx_333 == null)
				{
					int32 edx_355 = (int32) dl_328;
					esi_166 - 110 + (fp - 0x04) = (byte *) (byte) (edx_355 - (edx_355 | 0x01) *s ebx_155);
				}
				else
				{
					esp_15->dw0004 = (uint32) ((uint64) (uint32) (fp - 0x12) /u eax_330);
					ptr32 eax_371 = (word32) edi_302.u0 + (fp - 114);
					esp_15->ptr0000 = eax_371;
					word32 esp_374;
					word32 ebp_375;
					word32 edi_376;
					word32 ebx_378;
					byte SCZO_379;
					word32 eax_380;
					word32 ecx_381;
					word32 edx_382;
					byte SZO_383;
					byte C_384;
					byte Z_385;
					byte al_386;
					byte dl_387;
					byte CZ_388;
					ecx_333();
					ebx_155 = globals->t40603C;
					esp_15 = esp_374 - 0x08;
				}
				esi_166 = (word32) esi_166.u0 + 0x01;
				edi_302 = esi_166;
				al_171 = (byte) (word32) Mem0[ecx_165 + esi_166:byte];
			} while (al_171 != 0x00);
		}
		Eq_1686 edx_188 = (word32) ebx_155 + 0x0030;
		if (edx_188 > esi_166)
		{
			byte * eax_288 = (word32) esi_166.u0 + (fp - 114);
			Eq_1686 esi_292 = esi_166;
			do
			{
				*eax_288 = 0x00;
				esi_292 = (word32) esi_292.u0 + 0x01;
				eax_288 = eax_288 + 0x01;
			} while (edx_188 > esi_292);
		}
		ui32 ecx_196 = 0x01;
		ui32 eax_198 = dwLoc84_161 | dwArg04;
		do
		{
			ui32 edx_210 = (fp - 118)[ecx_196];
			if (ebx_155 != 0x00)
				edx_210 = edx_210 * 0x02;
			ecx_196 = ecx_196 + 0x01;
			eax_198 = eax_198 ^ edx_210;
		} while (ecx_196 != 0x0D);
		if (eax_198 != ~0x00)
		{
			Eq_1817 ecx_244 = ebx_155 - 0x01;
			if ((uint32) ((uint64) (uint32) eax_198 % ecx_244) == 2305906339)
			{
				edx_132 = ~0x00;
				word32 eax_260 = ((ebx_155 + 0x01) *s (dwArg08 + Mem0[edx_30 + 0x1C:word32]))[(word32) Mem0[dwLoc8C_146 + 0x00:word16] * 0x04] + dwArg08;
				if (eax_260 != ~0x00)
					return (uint32) ((uint64) (uint32) eax_260 % ecx_244);
				return edx_132;
			}
		}
		uint32 v21_228 = dwLoc88_141 + 0x01;
		dwLoc88_141 = v21_228;
		if ((uint32) ((uint64) (uint32) edx_30->dw0018 /u ((word32) ebx_155 + 0x01)) > v21_228)
		{
			dwLoc8C_146 = dwLoc8C_146 + 0x02;
			dwLoc84_161 = ebx_155;
			goto l00403422;
		}
	}
	edx_132 = 0x00;
	return edx_132;
}

// 00403590: Register uint32 fn00403590()
uint32 fn00403590()
{
	Eq_17 esi_21 = globals->t40603C;
	int32 ebx_22 = fs->ptr0018->ptr0030->dw000C;
	ui32 edi_30 = (word32) (uint32) ((uint64) (uint32) esi_21 /u (ebx_22 | 0x01)) + 0x001C + ebx_22;
	struct Eq_1888 * ecx_36 = edi_30 - (edi_30 | 0x01) *s esi_21;
	byte al_38 = (byte) (((word32) esi_21 + 0x01) *s 0x6B);
	byte al_47 = (byte) (((word32) esi_21 + 0x01) *s 114);
	byte dl_50 = (byte) (((esi_21 - 1148159575 >> 0x01) + 1148159575 >> 0x06) + 101);
	do
	{
		uint32 edx_107;
		struct Eq_1917 * eax_59 = (uint32) ((uint64) (uint32) ecx_36->dw0020 /u ((word32) esi_21 + 0x01));
		if (eax_59->b0000 == (byte) ((word32) al_38) && (eax_59->b0002 == (byte) ((word32) dl_50) && eax_59->b0004 == (byte) ((word32) al_47)))
		{
			word32 ebx_106 = ecx_36->dw0008;
			edx_107 = ~0x00;
			if (ebx_106 != ~0x00)
				edx_107 = (uint32) ((uint64) (uint32) ebx_106 % (esi_21 - 0x01));
			return edx_107;
		}
		ecx_36 = ecx_36->dw0000 | esi_21;
	} while (edi_30 != ecx_36->dw0000);
	edx_107 = 0x00;
	return edx_107;
}

// 00403640: void fn00403640(Register uint32 eax, Stack (ptr code) dwArg00)
void fn00403640(uint32 eax, code * dwArg00)
{
	struct Eq_1966 * ecx_10 = fp + 0x04;
	while (eax >= 0x1000)
	{
		ecx_10 = ecx_10 - 0x1000;
		ecx_10->dw0000 = ecx_10->dw0000;
		eax = eax - 0x1000;
	}
	word32 * ecx_22 = ecx_10 - eax;
	*ecx_22 = *ecx_22;
	word32 esp_32;
	word32 ecx_33;
	byte SCZO_34;
	word32 eax_35;
	byte C_36;
	byte SZO_37;
	bcuiposr0 None_38;
	dwArg00();
}

