// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 004190D4: Register Eq_2 Win32CrtStartup()
DWORD Win32CrtStartup()
{
}

// 004190D5: Register Eq_3 fn004190D5(Register Eq_3 eax, Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_3 fn004190D5(Eq_3 eax, Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	esp = fp;
	v5 = Mem0[eax + 0x60:word32] + ebp;
	*((word32) eax + 0x0060) = v5;
	SCZO = cond(v5);
	ecx = fn004190D8(ecx, ebp, esi, edi, out ebp, out esi, out edi);
	return ecx;
}

// 004190D8: Register Eq_3 fn004190D8(Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
Eq_3 fn004190D8(Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_3 ebp_7;
	Eq_3 esi_8;
	Eq_3 edi_9;
	real64 rLoc1_10;
	Eq_3 ecx_11 = fn004190DD(ecx, ebp, esi, edi, dwLoc04, out ebp_7, out esi_8, out edi_9, out rLoc1_10);
	word32 ebp_13;
	word32 esi_14;
	word32 edi_15;
	real64 rLoc1_16;
	return fn004190DD(ecx_11, ebp_7, esi_8, edi_9, dwArg00, out ebp_13, out esi_14, out edi_15, out rLoc1_16);
}

// 004190DD: Register Eq_3 fn004190DD(Register Eq_3 ecx, Register Eq_3 ebp, Register Eq_3 esi, Register Eq_3 edi, Stack (ptr Eq_85) dwArg00, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut, FpuStack out Eq_89 rLoc1Out)
Eq_3 fn004190DD(Eq_3 ecx, Eq_3 ebp, Eq_3 esi, Eq_3 edi, Eq_85 * dwArg00, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut, Eq_89 & rLoc1Out)
{
	*ebpOut = ebp;
	*esiOut = esi;
	*ediOut = edi;
	struct Eq_133 * esp_1 = fp;
	struct Eq_85 * ebx_28 = dwArg00;
	do
	{
		struct Eq_140 * ebx_29 = (char *) ebx_28 + 0x0012;
		ebx_29->dw0000 = ebx_29->dw0000 - 0x0006B1E8;
		*(ebx_29 - 0x03) = *(ebx_29 - 0x03) - 0x01;
		esp_255->t0000 = esp_255->t0000 - 0xAC;
		if (esp_255 != null)
		{
			if (esp_255 == null)
			{
				*((word32) ecx + 0x7AD70473) = 0x73812FF7;
				*edi = *edi - esi;
			}
			else
			{
				ebx_29->dw0004 = ebx_29->dw0004 ^ 0x2FF77AD7;
				ebx_29->dw0019 = ebx_29->dw0019 ^ 0xB7430077;
			}
			return ecx;
		}
		if (false)
		{
			word32 esi_250;
			*esiOut = *((word32) edi - 0x00070000) *s ~0x1C;
			word32 ebp_253;
			*ebpOut = *ebp;
			return ecx;
		}
		ecx = esp_255->t0018;
		byte * eax_107 = esp_255->ptr001C;
		int32 edx_101 = esp_255->dw0014;
		edi = esp_255->t0000;
		*ediOut = edi;
		word32 esi_91 = esp_255->dw0004;
		*ebpOut = esp_255->dw0008;
		ebx_28 = esp_255->ptr0010;
		word16 dx_111 = (word16) (edx_101 + 0x01);
		__outdw(dx_111, eax_107);
		byte cl_104 = (byte) ecx;
		byte al_108 = (byte) eax_107;
		esp_1 = (struct Eq_133 *) ((char *) &esp_255->t001F + 0x01);
		*esiOut = esi_91 + 0x04;
		struct Eq_133 * esp_255 = esp_1;
	} while (edx_101 < 0x01);
	*eax_107 = *eax_107 + al_108;
	*((word32) ecx + 110) = (word32) *((word32) ecx + 110) + cl_104;
	Eq_272 esi_119 = ebx_28->a006F[eax_107].dw0000 *s 0x6E6F6D6D;
	__outdw(dx_111, eax_107);
	__outb(dx_111, al_108);
	if (ebx_28 == (struct Eq_85 *) 0x01)
		;
	else
	{
		__outdw(dx_111, eax_107);
		*edi = __in(dx_111);
		*eax_107 = *eax_107 + al_108;
		__outdw(dx_111, eax_107);
		Eq_3 eax_154 = esp_255->t003B;
		struct Eq_313 * edx_147 = esp_255->ptr0033;
		word32 ebx_142 = esp_255->dw002F;
		Eq_3 ecx_150 = esp_255->t0037;
		byte al_155 = (byte) eax_154;
		Eq_3 edi_135 = esp_255->t001F;
		*ediOut = edi_135;
		Eq_3 esi_137 = esp_255->t0023;
		*esiOut = esi_137;
		Eq_3 ebp_139 = esp_255->t0027;
		*ebpOut = ebp_139;
		word32 * esp_158 = edx_147->dw0072 *s 1098478177;
		*eax_154 = (word32) *eax_154 + al_155;
		cu8 v26_161 = (word32) *((word32) edi_135 + 101) + al_155;
		*((word32) edi_135 + 101) = v26_161;
		word16 bx_143 = (word16) ebx_142;
		byte bl_144 = (byte) ebx_142;
		byte ch_152 = SLICE(ecx_150, byte, 8);
		if (v26_161 != 0x00)
		{
			if (v26_161 >= 0x00)
			{
				__arpl(*((word32) ecx_150 + 100), bx_143, &*((word32) ecx_150 + 100));
				if (v26_161 < 0x00)
					;
				else if (v26_161 >= 0x00)
					;
				else
				{
					word32 ebp_203;
					word32 esi_204;
					word32 edi_205;
					return fn004190D5(eax_154, ecx_150, ebp_139, esi_137, edi_135, out ebp_203, out esi_204, out edi_205);
				}
			}
			__sti();
			struct Eq_407 * ebx_213 = DPB(ebx_142, bl_144 + ch_152, 0);
			ebx_213->dw404F0D95 = ebx_213->dw404F0D95 - 0x01;
		}
		else
		{
			word32 esp_219;
			word32 ebx_220;
			byte SCZO_221;
			byte SZO_222;
			word32 esi_223;
			byte C_224;
			byte Z_225;
			Eq_3 ecx_226;
			word32 edi_227;
			union Eq_3 * ebp_228;
			word32 edx_229;
			word32 eax_230;
			word16 dx_231;
			byte S_232;
			byte al_233;
			byte cl_234;
			word16 bx_235;
			byte bl_236;
			byte ch_237;
			byte bh_238;
			(*((word32) ebp_139 + 0x0033))();
			ebp_139 = *ebp_228;
			*ebpOut = ebp_139;
			esp_158 = (word32 *) ((char *) ebp_228 + 0x04);
			ecx_150 = ecx_226;
			if (ecx_226 == 0x00)
				fn0041912F(dwLoc04);
			edx_147 = (struct Eq_313 *) *((word32) ebp_139 + 4214541);
		}
		word32 eax_186 = edx_147->dw003C;
		*((word32) ebp_139 + 4214551) = edx_147 + eax_186 / 118;
		if (true)
			fn00419167();
		else if (true)
		{
			fn00419168();
			return ecx_150;
		}
		else
		{
			*esp_158 = *esp_158 + 0x17;
			return ecx_150;
		}
	}
}

// 0041912F: void fn0041912F(Stack ptr32 dwArg00)
void fn0041912F(ptr32 dwArg00)
{
	word32 esp_7;
	word32 edx_8;
	byte SCZO_9;
	(dwArg00 - 11)();
}

// 00419167: void fn00419167()
void fn00419167()
{
}

// 00419168: void fn00419168()
void fn00419168()
{
	esp = fp;
	esp = fp - 0x02;
	wLoc02 = es;
}

