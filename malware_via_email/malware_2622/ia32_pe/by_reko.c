// subject.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401000: Register Eq_2 fn00401000(Register Eq_2 eax, Register word32 ecx, Register (ptr Eq_4) ebp, Register Eq_5 esi, Stack Eq_2 tArg04, Stack Eq_7 tArg08, Stack Eq_2 tArg0C, Stack Eq_2 tArg10, Register out ptr32 ebpOut)
Eq_2 fn00401000(Eq_2 eax, word32 ecx, Eq_4 * ebp, Eq_5 esi, Eq_2 tArg04, SIZE_T tArg08, Eq_2 tArg0C, Eq_2 tArg10, ptr32 & ebpOut)
{
	*(v3 - 0x04) = (struct Eq_4 **) ebp;
	*(v3 - 0x08) = ecx;
	*(v3 - 0x0C) = (union Eq_5 *) esi;
	*(v3 - 0x60) = 0x00;
	*(v3 - 0x10) = v3 - 0x60;
	*(v3 - 0x14) = v3 - 0x60;
	*(v3 - 0x18) = v3 - 0x60;
	*(v3 - 0x1C) = v3 - 0x60;
	*(v3 - 0x20) = v3 - 0x60;
	*(v3 - 0x24) = v3 - 0x60;
	*(v3 - 0x28) = v3 - 0x60;
	ptr32 esp_30;
	word32 edi_31;
	ptr32 ebp_32;
	int32 ecx_33;
	word32 esi_34;
	ui32 edx_35;
	ui32 eax_36;
	byte SZO_37;
	byte C_38;
	byte SCZO_39;
	byte Z_40;
	word32 ebx_41;
	byte dl_42;
	byte bl_43;
	byte al_44;
	WS2_32.dll!WSAConnect();
	ui32 edx_46 = edx_35 & eax_36 + 0x01;
	*(ebp_32 - 0x04) = *(ebp_32 - 0x04) & edx_46;
	*(ebp_32 - 0x08) = *(ebp_32 - 0x08) & edx_46;
	*(esp_30 - 0x04) = edx_46;
	*(ebp_32 - 0x0C) = *(ebp_32 - 0x0C) & edx_46;
	*(esp_30 - 0x08) = eax_36 + 0x01;
	*(esp_30 - 0x0C) = eax_36 + 0x01;
	*(ebp_32 - 0x0C) = *(ebp_32 - 0x0C) + (ecx_33 *s 0x00 - 0x01);
	*(ebp_32 - 0x5C) = 0x00;
	*(esp_30 - 0x10) = ebp_32 - 0x5C;
	*(esp_30 - 0x14) = ebp_32 - 0x5C;
	*(esp_30 - 0x18) = ebp_32 - 0x5C;
	*(esp_30 - 0x1C) = ebp_32 - 0x5C;
	*(esp_30 - 0x20) = ebp_32 - 0x5C;
	*(esp_30 - 0x24) = ebp_32 - 0x5C;
	*(esp_30 - 0x28) = ebp_32 - 0x5C;
	word32 esp_83;
	word32 edi_84;
	struct Eq_4 * ebp_85;
	word32 ecx_86;
	word32 esi_87;
	word32 edx_88;
	word32 eax_89;
	byte SZO_90;
	byte C_91;
	byte SCZO_92;
	byte Z_93;
	word32 ebx_94;
	byte dl_95;
	byte bl_96;
	byte al_97;
	WS2_32.dll!WSAConnect();
	if (eax_89 == 0x01)
	{
		word32 ebp_112;
		return fn00401067(eax_89 + 0x01, ebp_85, out ebp_112);
	}
	else
		return VirtualAlloc(tArg04, tArg08, tArg0C, tArg10);
}

// 00401067: Register Eq_2 fn00401067(Register Eq_2 eax, Register (ptr Eq_4) ebp, Register out ptr32 ebpOut)
Eq_2 fn00401067(Eq_2 eax, Eq_4 * ebp, ptr32 & ebpOut)
{
	uint32 edi_5 = ebp->dw0010;
	if (*(ebp - 0x08) < edi_5)
	{
		ui32 eax_55 = -*(ebp - 0x0C);
		*(ebp - 0x14) = ~((word32) (eax & 0x00) + ebp->dw000C + *(ebp - 0x08));
		ui32 eax_60 = ~(eax_55 - 0x01 | *(ebp - 0x14));
		ui32 edx_63 = ebp->ptr0014 + *(ebp - 0x04);
		*(ebp - 0x14) = 0xFF;
		ui32 ebx_70 = edx_63 & *(ebp - 0x14);
		*(ebp - 0x14) = ~0x00;
		ui32 ebx_74 = ebx_70 ^ *(ebp - 0x14);
		ui32 ebx_82 = ebx_74 + 0x01 & 0x00 ^ ebp->dw0008;
		*(ebp - 0x08) = -*(ebp - 0x08);
		Eq_2 ebx_85 = ebx_82 - *(ebp - 0x08);
		*(ebp - 0x10) = *(ebp - 0x10) & 0x00;
		*(ebp - 0x10) = *(ebp - 0x10) | ebx_85;
		word32 ebx_96 = DPB(*ebx_85, (byte) ((eax_60 & 0xFF) + (ebx_74 + 0x01)), 0);
		*(ebp - 0x08) = -*(ebp - 0x08);
		*(v3 - 0x04) = 0x00;
		*ebx_85 = *(v3 - 0x04);
		*(v3 - 0x04) = (union Eq_2 *) ebx_85;
		*ebx_85 = (byte) fn00401420() + ((word32) (*ebx_85) + -ebx_96);
		ui32 edx_118 = *ebx_85 ^ *(ebp - 0x14);
		*ebx_85 = edx_118 + 0x01;
		word32 edi_126 = (edi_5 & 0x00) + *(ebp - 0x04);
		*(ebp - 0x04) = edi_126 + 0x01;
		eax = ebx_85;
		if (edi_126 == 0x00)
			*(ebp - 0x04) = *(ebp - 0x04) & 0x00;
		if (*(ebp - 0x04) != 0x9A)
		{
			word32 ebp_136;
			return fn00401330(ebx_85, edx_118 + 0x01, ebp, out ebp_136);
		}
	}
	word32 ebp_42;
	*ebpOut = ebp->dw0000;
	return eax;
}

// 00401128: Register Eq_2 Win32CrtStartup()
Eq_2 Win32CrtStartup()
{
	word32 esp_40;
	struct Eq_4 * ebp_41;
	word32 edx_42;
	byte SCZO_43;
	word32 esi_44;
	word32 edi_45;
	word32 ebx_46;
	word32 ecx_47;
	byte SZO_49;
	byte C_50;
	byte Z_51;
	Eq_2 eax_48;
	WS2_32.dll!WSAConnect();
	ptr32 esp_64 = fp - 0x20 - ((fp - (ui32 *) 0x60 ^ eax_48) + 0x01);
	*(esp_64 - 0x04) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x08) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x0C) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x10) = fp - (ui32 *) 0x04;
	int32 ecx_74 = fp - (ui32 *) 0x60 - (fp - (ui32 *) 0x60);
	word32 ecx_110 = 0xFFFF;
	do
	{
		eax_48 = (word32) eax_48 + 0x0010;
		if (eax_48 == ~0x01120521)
		{
			word32 ebp_436;
			return fn00401000(eax_48, ecx_110, ebp_41, fp - (ui32 *) 0x60, tArg04, tArg08, tArg0C, tArg10, out ebp_436);
		}
		ecx_110 = ecx_110 - 0x01;
	} while (ecx_110 != 0x00);
	*(esp_64 - 0x14) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x18) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x1C) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x20) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x24) = fp - (ui32 *) 0x60;
	*(esp_64 - 0x28) = fp - (ui32 *) 0x60;
	*(esp_64 - 44) = fp - (ui32 *) 0x60;
	ptr32 esp_129;
	struct Eq_4 * ebp_130;
	word32 edx_131;
	byte SCZO_132;
	Eq_5 esi_133;
	word32 edi_134;
	word32 ebx_135;
	word32 ecx_136;
	word32 eax_137;
	byte SZO_138;
	byte C_139;
	byte Z_140;
	WS2_32.dll!WSAConnect();
	if (fp != (ui32 *) 0x5F)
	{
		word32 ebp_434;
		return fn00401000(fp - (ui32 *) 0x5F, ecx_136, ebp_130, esi_133, tArg04, tArg08, tArg0C, tArg10, out ebp_434);
	}
	else
	{
		*(esp_129 - 0x04) = fp - (ui32 *) 0x50;
		*(esp_129 - 0x08) = fp - (ui32 *) 0x50;
		*(esp_129 - 0x0C) = fp - (ui32 *) 0x50;
		*(esp_129 - 0x10) = fp - (ui32 *) 0x50;
		*(esp_129 - 0x14) = fp - (ui32 *) 0x50;
		struct Eq_4 * ebp_159;
		word32 edx_160;
		byte SCZO_161;
		word32 esi_162;
		word32 edi_163;
		word32 ebx_164;
		word32 ecx_165;
		word32 eax_166;
		byte SZO_167;
		byte C_168;
		byte Z_169;
		ptr32 esp_158;
		OLECLI32.dll!OleClone();
		if (eax_166 == 0x0D)
		{
			ui32 * edi_196 = fp - (ui32 *) 0x50 - (fp - (ui32 *) 0x50);
			*(esp_158 - 0x04) = edi_196;
			*(esp_158 - 0x08) = edi_196;
			*(esp_158 - 0x0C) = edi_196;
			*(esp_158 - 0x10) = edi_196;
			if (OleLoad(*(esp_158 - 0x10), *(esp_158 - 0x0C), *(esp_158 - 0x08), *(esp_158 - 0x04)) == 0x80070057)
			{
				*(esp_158 - 0x04) = 0x00;
				*(esp_158 - 0x08) = 0x80000004;
				esp_158 = esp_158 - 0x08;
				Eq_2 eax_214 = RegDeleteValueW(*(esp_158 - 0x08), *(esp_158 - 0x04));
				if (eax_214 == ~0x05 && eax_214 == ~0x05)
				{
					Eq_2 eax_227 = -0x7FF00685;
					int32 v20_228 = ecx_74 - eax_227;
					ui32 v21_234 = v20_228 + ((dwLoc4C & (edi_196 & 0x00)) + 2272615812 ^ 0x077AA4FF);
					Mem239[fp - 0x04 + -0x18:word32] = v21_234;
					int32 ebx_245 = v20_228 + 2152753531 ^ ~0x00;
					word32 esi_255 = fp - 0x04 + -(((ebx_245 + 0x01) *s 0x00 ^ 0x02A8) + ~0xFF);
					*(esp_158 - 0x0C) = 0x004147C8;
					ui32 edx_278 = (~(~((word32) esi_255 + (ecx & 0x00) - ~0x0F & 0x00) & ~0x30) ^ ~0x00) - ~0x00;
					*(esp_158 - 0x10) = ~((edx_278 & 0x00) + ((esi & v21_234) + edx_278)) - ((edx_278 & 0x00) - 0x01);
					*(esp_158 - 0x14) = fp - (ui32 *) 0x60 + (v21_234 - (ebx_245 + 0x01));
					*(esp_158 - 0x18) = fp - (ui32 *) 0x01AC;
					struct Eq_4 * ebp_302 = fn004013C1(eax_227, ~0x00, ebp_159, esi_255);
					*(ebp_302 - 0x08) = *(ebp_302 - 0x08) & 0x00;
					*(ebp_302 - 0x24) = (char *) **(ebp_302 - 0x10) + *(*(ebp_302 - 0x10) - ~0x03);
					*(esp_158 - 0x14) = 0x40;
					*(ebp_302 - 0x18) = *(ebp_302 - 0x18) & 0x00;
					*(esp_158 - 0x18) = 0x3000;
					*(esp_158 - 0x1C) = ebp_302 - 0x24;
					*(esp_158 - 0x20) = 0x00;
					Eq_2 eax_329 = VirtualAlloc(*(esp_158 - 0x20), *(esp_158 - 0x1C), *(esp_158 - 0x18), *(esp_158 - 0x14));
					*(ebp_302 - 0x08) = *(ebp_302 - 0x08) | eax_329;
					*(ebp_302 - 0x20) = eax_329 & 0x00;
					*(ebp_302 - 0x20) = *(ebp_302 - 0x20) | 0x00400000;
					*(ebp_302 - 0x01AC) = *(ebp_302 - 0x01AC) & (eax_329 & 0x00);
					ptr32 esp_327 = esp_158 - 0x20;
					if ((eax_329 & 0x00) == 0x00)
					{
						while (true)
						{
							Eq_5 esi_353 = *(ebp_302 - 0x01AC);
							if (esi_353 >= *((char *) (*(ebp_302 - 0x10)) + 0x08))
								break;
							word32 * esp_358 = esp_327 - 0x04;
							*esp_358 = *(ebp_302 - 0x28);
							*(esp_358 - 0x04) = *((char *) *(ebp_302 - 0x1C) + 0x04);
							*(esp_358 - 0x08) = (char *) **(ebp_302 - 0x1C) + *(ebp_302 - 0x20);
							word32 ecx_370 = *(ebp_302 - 0x08) + *(ebp_302 - 0x18);
							*(esp_358 - 0x0C) = ecx_370;
							ebp_302 = fn004013B6(ecx_370, ebp_302, esi_353);
							*(ebp_302 - 0x18) = (char *) *((char *) *(ebp_302 - 0x1C) + 0x04) + *(ebp_302 - 0x18);
							esp_327 = esp_358 - 0x0C;
							*(ebp_302 - 0x01AC) = *(ebp_302 - 0x01AC) + 0x01;
							*(ebp_302 - 0x1C) = *(ebp_302 - 0x1C) + 0x08;
						}
						word32 * esp_390 = esp_327 - 0x04;
						*esp_390 = *(ebp_302 - 0x20);
						ui32 edi_396 = *(ebp_302 - 0x08) + -~0x152F;
						*(ebp_302 - 0x14) = v11;
						*(ebp_302 - 0x14) = v12;
						*(esp_390 - 0x04) = v13;
						struct Eq_1137 * edi_410 = (edi_396 & 0x00) + *(ebp_302 - 0x10);
						*(ebp_302 - 0x08) = v14;
						Eq_2 eax_414 = *(ebp_302 - 0x08);
						ui32 ebx_416 = (edi_396 & 0x00) - eax_414 + edi_410->dw0004;
						*(esp_390 - 0x08) = ebx_416;
						ui32 ebx_420 = ebx_416 & 0x00 | *(ebp_302 - 0x14);
						*(esp_390 - 0x0C) = ebx_420;
						*(esp_390 - 0x10) = ebx_420 + 0xCC00;
						*(esp_390 - 0x14) = *(ebp_302 - 0x14);
						return eax_414;
					}
					else
					{
						word32 ebp_345;
						return fn00401330(eax_329 & 0x00, 0x40, ebp_302, out ebp_345);
					}
				}
			}
		}
		word32 * esp_178 = esp_158 - 0x04;
		*esp_178 = 0x00;
		*(esp_178 - 0x04) = 0x00;
		*(esp_178 - 0x08) = 0x00;
		*(esp_178 - 0x0C) = 0x00;
		*(esp_178 - 0x10) = 0x00;
		OleSave(*(esp_178 - 0x10), *(esp_178 - 0x0C), *(esp_178 - 0x08));
		*(esp_178 - 0x14) = 0x00;
		*(esp_178 - 0x18) = 0x80000004;
		return RegDeleteValueA(*(esp_178 - 0x18), *(esp_178 - 0x14));
	}
}

// 00401330: Register Eq_2 fn00401330(Register Eq_2 eax, Register int32 edx, Register (ptr Eq_4) ebp, Register out ptr32 ebpOut)
Eq_2 fn00401330(Eq_2 eax, int32 edx, Eq_4 * ebp, ptr32 & ebpOut)
{
	*(v3 - 0x04) = (union Eq_2 *) eax;
	ui32 ebx_11 = *(ebp - 0x08) - *(ebp - 0x0C);
	*(ebp - 0x08) = *(ebp - 0x08) & edx *s 0x00;
	*(ebp - 0x08) = *(ebp - 0x08) | ebx_11;
	word32 ebp_21;
	return fn00401067(eax, ebp, out ebp_21);
}

// 004013B6: Register (ptr Eq_4) fn004013B6(Register word32 ecx, Register (ptr Eq_4) ebp, Register Eq_5 esi)
Eq_4 * fn004013B6(word32 ecx, Eq_4 * ebp, Eq_5 esi)
{
	if (true)
	{
		struct Eq_4 * ebp_15;
		fn00401000(0x00, ecx, ebp, esi, tArg04, tArg08, tArg0C, tArg10, out ebp_15);
		return ebp_15;
	}
	else
		return fn004013C1(0x00, ecx, ebp, esi);
}

// 004013C1: Register (ptr Eq_4) fn004013C1(Register Eq_2 eax, Register word32 ecx, Register (ptr Eq_4) ebp, Register Eq_5 esi)
Eq_4 * fn004013C1(Eq_2 eax, word32 ecx, Eq_4 * ebp, Eq_5 esi)
{
	if (true)
	{
		struct Eq_4 * ebp_65;
		fn00401000(eax, ecx, ebp, esi, tArg04, tArg08, tArg0C, tArg10, out ebp_65);
		return ebp_65;
	}
	else
	{
		word32 edi_28 = *(ebp - 0x08) + -~0x152F;
		*(ebp - 0x14) = *(ebp - 0x14) & 0x00;
		*(ebp - 0x14) = *(ebp - 0x14) + edi_28;
		*(ebp - 0x08) = -*(ebp - 0x08);
		return ebp;
	}
}

// 00401420: FlagGroup bool fn00401420()
bool fn00401420()
{
	return false;
}

